{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"evalio","text":"<p>evalio is a tool for Evaluating Lidar-Inertial Odometry.</p> <p>Specifically, it provides a common interface for using LIO datasets and LIO pipelines. This allows for easy addition of new datasets and pipelines as well as a common location to evaluate them. This makes benchmarks significantly easier to run and data significantly easier to access. It features,</p> <ul> <li>Download and manage datasets via the CLI interface</li> <li>Simple to use python package API for friction-free access to data</li> <li>No ROS dependency! (though it can still load rosbag datasets using the wonderful rosbags package)</li> <li>Easy to add new datasets and pipelines, see the example</li> <li>Unified representation of lidar scan, e.g. row (scan-line) major order, stamped at the start of the scan, point stamps are relative from the start of the scan.</li> <li>Run pipelines via the CLI interface and yaml config files</li> <li>Compute statistics for resulting trajectory runs</li> </ul> <p>Checkout quickstart for a quick overview of the package. Additionally, evalio eases a number of common tasks, check out the examples for some common use cases. </p>"},{"location":"install/","title":"Source Build","text":"<p>For the majority of use cases, we simply recommend installing via your favorite python package manager, <pre><code>uv add evalio      # uv\npip install evalio # pip\n</code></pre></p>"},{"location":"install/#building-from-source","title":"Building from Source","text":"<p>Building all the available pipelines together is difficult, so we've done our best to separate a build option for just the core types of evalio, and then pipelines can be optionally added in.</p>"},{"location":"install/#base","title":"Base","text":"<p>We've attempted to make building from source as easy as possible. We generally build through scikit-core-build which provides a simple wrapper for building CMake projects as python packages. <code>uv</code> is our frontend of choice for this process, but it is also possible via pip <pre><code>uv sync --verbose  # uv version\npip install -e .   # pip version\n</code></pre></p> <p>Of course, building via the usual <code>CMake</code> way is also possible, with the only default dependency being <code>Eigen3</code>, <pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre></p>"},{"location":"install/#pipelines","title":"Pipelines","text":"<p>By default, pipelines are not included due to their large dependencies. We use vpckg to handle a reliable build of these dependencies and pipelines. vcpkg and the pipelines can be setup via running <pre><code>./cpp/setup_pipelines.sh\n</code></pre></p> <p>This will clone and setup vcpkg in the <code>.vcpkg</code> directory, and the pipelines (including some minor patches) to <code>cpp/bindings/pipelines-src</code>. vcpkg will automatically be picked up by CMake in this directory, so the build process then continues as in the base section.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>evalio is available on PyPi, so simply install via your favorite python package manager, <pre><code>uv add evalio      # uv\npip install evalio # pip\n</code></pre></p> <p>evalio can be used both as a python library and as a CLI for both datasets and pipelines.</p>"},{"location":"quickstart/#datasets","title":"Datasets","text":"<p>Once evalio is installed, datasets can be listed and downloaded via the CLI interface. For example, to list all datasets and then download a sequence from the hilti-2022 dataset, <pre><code>evalio ls datasets\nevalio download hilti_2022/basement_2\n</code></pre> evalio downloads data to the path given by <code>-D</code>, <code>EVALIO_DATA</code> environment variable, or if both are unset to the local folder <code>./evalio_data</code>. All the trajectories in a dataset can also be downloaded by using the wildcard <code>hilti_2022/*</code>, making sure to escape the asterisk as needed.</p> <p>Tip</p> <p>evalio also comes with autocomplete, which makes typing the long dataset and pipeline names much easier. To install, do one of the following, <pre><code>eval \"$(evalio --show-completion)\" # install for the current session\nevalio --install-completion        # install for all future sessions\n</code></pre></p> <p>Note</p> <p>Many datasets use gdown to download datasets from google drive. Unfortunately, this can occasionally be finicky due to google's download limits, however downloading cookies from your browser can often help.</p> <p>Once downloaded, a trajectory can then be easily used in python, <pre><code>from evalio import datasets as ds\n\n# for all data\nfor mm in ds.Hilti2022.basement_2:\n    print(mm)\n\n# for lidars\nfor scan in ds.Hilti2022.basement_2.lidar():\n    print(scan)\n\n# for imu\nfor imu in ds.Hilti2022.basement_2.imu():\n    print(imu)\n</code></pre></p> <p>For example, you can easily get a single scan to plot a bird-eye view, <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# get the 10th scan\nscan = ds.Hilti2022.basement_2.get_one_lidar(10)\n# always in row-major order, with stamp at start of scan\nx = np.array([p.x for p in scan.points])\ny = np.array([p.y for p in scan.points])\nz = np.array([p.z for p in scan.points])\nplt.scatter(x, y, c=z, s=1)\nplt.axis('equal')\nplt.show()\n</code></pre> evalio also comes with a built wrapper for converting to rerun types, <pre><code>import rerun as rr\nfrom evalio.rerun import convert\n\nrr.init(\"evalio\")\nrr.connect_tcp()\nfor scan in ds.Hilti2022.basement_2.lidar():\n    rr.set_time(\"timeline\", timestamp=scan.stamp.to_sec())\n    rr.log(\"lidar\", convert(scan, color=[255, 0, 255]))\n</code></pre></p> <p>Note</p> <p>To run the rerun visualization, rerun must be installed. This can be done by installing <code>rerun-sdk</code> or <code>evalio[vis]</code> from PyPi.</p> <p>Once installed, rerun must be spawned from the CLI simply by running <code>rerun</code> in a terminal. This will start the rerun viewer, which can then be used to visualize the data logged by evalio.</p> <p>We recommend checking out the API reference for more information on how to interact with datasets, and the example for an example of how to create your own dataset.</p>"},{"location":"quickstart/#pipelines","title":"Pipelines","text":"<p>The other half of evalio is the pipelines that can be run on various datasets. All pipelines and their parameters can be shown via, <pre><code>evalio ls pipelines\n</code></pre> For example, to run KissICP on a dataset, <pre><code>evalio run -o results -d hilti_2022/basement_2 -p kiss\n</code></pre> This will run the pipeline on the dataset and save the results to the <code>results</code> folder. The results can then be used to compute statistics on the trajectory, <pre><code>evalio stats results\n</code></pre></p> <p>Note</p> <p>KissICP does poorly by default on hilti_2022/basement_2, due to the close range and large default voxel size. You can visualize this by adding <code>-s ms</code> to the <code>run</code> command to visualize the map and scan in rerun.</p> <p>More complex experiments can be run, including varying pipeline parameters, via specifying a config file, <pre><code># If not specified, defaults to ./evalio_results/config_file_name\noutput_dir: ./results/\n\ndatasets:\n  # Run on all of newer college trajectories\n  - hilti_2022/*\n  # Run on first 1000 scans of multi campus\n  - name: multi_campus/ntu_day_01\n    length: 1000\n\npipelines:\n  # Run vanilla kiss with default parameters\n  - kiss\n  # Tweak kiss parameters\n  - name: kiss_tweaked\n    pipeline: kiss\n    deskew: true\n    # Perform a parameter sweep over other parameters\n    sweep:\n      voxel_size: [0.1, 0.5, 1.0]\n      # Can also eval python code to create sweep (including numpy functionality)\n      initial_threshold: linspace(0.5, 2.0, 4)\n</code></pre> This can then be run via <pre><code>evalio run -c config.yml\n</code></pre></p> <p>Additionally, the run command supports visualization via rerun as well. <code>-v</code> will do a simple visualization of the ground truth trajectory and odometry, while <code>-s</code> can be used to enable additional visualizations, <pre><code>evalio run -o results -d hilti_2022/basement_2 -p kiss -s msif\n</code></pre> where m -&gt; map, s -&gt; scan, i -&gt; intensity image, and f -&gt; extracted features can all be selectively visualized in rerun. </p> <p>Note</p> <p>As mentioned above, rerun must be installed and launched to visualize the results.</p> <p>That's about the gist of it! Try playing around the CLI interface to see what else is possible. Feel free to open an issue if you have any questions, suggestions, or problems. </p> <p>Additionally, we recommend checking out the examples section for specific use cases for evalio.</p>"},{"location":"examples/data_loading/","title":"Data Loading","text":"<p>Loading robotics datasets can be tedious and time-consuming due to the lack of standardization in the datasets formats. evalio provides a unified interface for loading datasets, making it trivial to get up and running with real-world lidar and IMU data.</p> <p>Datasets are managed via the CLI interface, specifically, using <code>evalio dl</code> to download datasets and <code>evalio rm</code> command to remove unwanted datasets. <code>evalio ls datasets</code> is also useful to visualize what has been installed. </p> <p>Once a dataset is downloaded, it can be used via the <code>evalio</code> library. Each dataset is an enum, with each sequence being a member.</p> <pre><code>from evalio.datasets import Hilti2022\n\ndata = Hilti2022.basement_2\n</code></pre> <p>Each datasets provides helpers for iterating over data,</p> <pre><code>from evalio.datasets import Hilti2022\n\n# Iterate through all data in the dataset\nfor mm in Hilti2022.basement_2:\n    print(mm)\n\n# Access only lidar scans\nfor scan in Hilti2022.basement_2.lidar():\n    print(scan)\n\n# Access only IMU data\nfor imu in Hilti2022.basement_2.imu():\n    print(imu)\n</code></pre> <p>Each time an iteration function is called, it will reload the data from the beginning. This obviously has a performance cost, so use wisely.</p> <p>Helpers also exist for just gathering a single data point,</p> <pre><code>from evalio.datasets import Hilti2022\n\n# Get the 10th IMU data point\nimu = Hilti2022.basement_2.get_one_imu(10)\n\n# Get the 10th lidar data point\nlidar = Hilti2022.basement_2.get_one_lidar(10)\n</code></pre> <p>Warning</p> <p>There is a cost to these single data point functions; at the moment this will cause a full iteration over the dataset to find the data point. This is a known issue and will be fixed in the future.</p> <p>Each lidar measurement (type LidarMeasurement) consists of a stamp and a vector of points (type Point). The measurement follows a meticulous order, and always adhered to the following properties,</p> <ul> <li>The measurement stamp is always at the start of the scan</li> <li>Scans are in row-major order</li> <li>Scans contain all points, i.e. invalid points are NOT dropped. This is important information that is used in some algorithms for feature extractions. For example, a 128x1024 scan will contain 128x1024 points</li> <li>Points stamps are always relative to the start of the scan, so absolute point times can be calculated via <code>scan.stamp + scan.points[i].stamp</code></li> </ul> <p>Points are then easy to work with, as can be seen below. <pre><code>from evalio.datasets import Hilti2022\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nscan = Hilti2022.basement_2.get_one_lidar(10)\n\n# Extract x, y, z coordinates\nx = np.array([p.x for p in scan.points])\ny = np.array([p.y for p in scan.points])\nz = np.array([p.z for p in scan.points])\n\n# Plot the bird's-eye view\nplt.scatter(x, y, c=z, s=1)\nplt.axis('equal')\nplt.title(\"Bird's-Eye View of Point Cloud\")\nplt.show()\n</code></pre></p> <p>Additionally, a conversion to rerun types is also available for easy visualization, see rerun for more details.</p> <pre><code>import rerun as rr\nfrom evalio.rerun import convert\n\n# Initialize rerun\nrr.init(\"evalio\")\nrr.connect_tcp()\n\n# Stream lidar scans to rerun\nfor scan in Hilti2022.basement_2.lidar():\n    rr.set_time(\"timeline\", timestamp=scan.stamp.to_sec())\n    rr.log(\"lidar\", convert(scan, color=\"z\"))\n</code></pre> <p>If anything is unclear, please open an issue on the evalio repository. We are always looking to improve the documentation and make it easier to use.</p>"},{"location":"examples/dataset/","title":"Custom Dataset","text":"<p>While evalio comes with a number of built-in datasets, you can also easily create your own dataset without having to build any of evalio from source. In addition to this guide, we also provide evalio-example with examples. </p> <p>To get evalio to find your custom dataset, simply point the environment variable <code>EVALIO_CUSTOM=my_module</code> to the module where your dataset is defined.</p> <p>To create a dataset, one simply has to inherit from the <code>Dataset</code> class,</p> <p><pre><code>from evalio.datasets import Dataset, DatasetIterator\nfrom evalio.types import Trajectory, SE3, ImuParams, LidarParams\n\nfrom typing import Sequence, Optional\nfrom pathlib import Path\nfrom enum import auto\n\nclass MyDataset(Dataset):\n    sequence_1 = auto()\n    sequence_2 = auto()\n    sequence_3 = auto()\n\n    def data_iter(self) -&gt; DatasetIterator: ...\n\n    def ground_truth_raw(self) -&gt; Trajectory: ...\n\n    def files(self) -&gt; Sequence[str | Path]: ...\n\n    def imu_T_lidar(self) -&gt; SE3: ...\n\n    def imu_T_gt(self) -&gt; SE3: ...\n\n    def imu_params(self) -&gt; ImuParams: ...\n\n    def lidar_params(self) -&gt; LidarParams: ...\n</code></pre> The most obvious thing to note is the list of sequences; as each Dataset class is an enum, we list all of the sequences as enum members.</p> <p>After that are the methods. The last four methods are fairly self-explanatory, but we'll elaborate more on the first three.</p>"},{"location":"examples/dataset/#data_iter","title":"data_iter","text":"<p>Arguably the most important method, as is the main interface to the actual data. It returns a <code>DatasetIterator</code> object, which provides iterators over the data.</p> <p>While you are welcome to provide a custom <code>DatasetIterator</code>, evalio provides some for the most common use cases in <code>RosbagIter</code> that iterates over topics found in a rosbag, and <code>RawDataIter</code> takes in iterators for imu and lidar data to return.</p> <p>An example of <code>RosbagIter</code> can be found in the Hilti2022 source code and <code>RawDataIter</code> in the Helipr source code. There is also examples of each in evalio-example.</p>"},{"location":"examples/dataset/#ground_truth_raw","title":"ground_truth_raw","text":"<p>This method provides the ground truth trajectory in an arbitrary frame (often a GPS or prism frame). Many times this is provided in a csv file, which can be loaded via <code>Trajectory.from_tum</code> or<code>Trajectory.from_csv</code>. Naturally, <code>Trajectory</code> can also be created manually from a list of <code>Stamp</code> and <code>SE3</code> objects.</p> <p>It will be transformed into the IMU frame using transform given by the <code>imu_T_gt</code> method.</p>"},{"location":"examples/dataset/#files","title":"files","text":"<p>This provides a list of files that are required to run the dataset. evalio will internally use them to check to make sure the dataset is complete before running anything.</p> <p>If a returned file is a <code>str</code> it is assumed to be a path relative to the sequence directory in <code>EVALIO_DATA</code>, which is given by <code>folder</code>. If it is a <code>Path</code> object, it is assumed to be an absolute path stored wherever you desire.</p>"},{"location":"examples/dataset/#optionals","title":"optionals","text":"<p>Additionally, there is a number of optional methods that you can implement to add more functionality and information to the <code>evalio ls</code> command. Each of these already have default implementations. These methods are (continuing from the above example):</p> <p><pre><code>    @classmethod\n    def dataset_name(cls) -&gt; str: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    def environment(self) -&gt; str: ...\n\n    def vehicle(self) -&gt; str: ...\n\n    def download(self) -&gt; str: ...\n\n    def quick_len(self) -&gt; Optional[int]: ...\n</code></pre> The first one provides a base dataset name to be used. By default this is the class name converted to snake case, but it can be overridden. This will be the name used when running CLI commands.</p> <p>The next three are again self-explanatory, all of which provide information for the <code>evalio ls</code> command.</p> <p><code>download</code> does exactly what it says - downloads the datasets. See the newer college 2020 for an example downloading from google drive, and hilti 2022 for an example downloading directly from a url.</p> <p><code>quick_len</code> returns a hardcoded number of scans in a dataset, used for <code>evalio ls</code> and for computing time estimates in <code>evalio run</code>. If not set, evalio will load the data to compute the length.</p> <p>That's all there is to it! Datasets are fairly simple - mostly just parameter setting and easy-to-use iterator wrappers. If you have an dataset implementation of an open-source dataset, feel free to make a PR to add it to evalio so others can use it as well.</p>"},{"location":"examples/evaluation/","title":"Evaluation","text":"<p>One of the main uses of <code>evalio</code> is to evaluate the performance of lidar-inertial odometry pipelines. The <code>evalio run</code> command is dedicated to this task. It has usage both as a quick command, and via loading of a config file. See cli for more details.</p> <p>Tip</p> <p>evalio also comes with autocomplete, which makes typing the long dataset and pipeline names much easier. To install, do one of the following, <pre><code>eval \"$(evalio --show-completion)\" # install for the current session\nevalio --install-completion        # install for all future sessions\n</code></pre></p>"},{"location":"examples/evaluation/#quick-command","title":"Quick command","text":"<p>For one off evaluations without parameter changes, <code>evalio run</code> can be used directly, <pre><code>evalio run -d newer_college_2020/short_experiment \\\n            -d hilti_2022/basement_2 \\\n            -p kiss -p liosam \\\n            -o evalio_results\n</code></pre> Also available are the <code>-l/--length</code> which will set a maximum length for every dataset run on, and <code>-s/--show</code> which will visualize the results in an open rerun window, with <code>m</code> showing the map, <code>s</code> the scan, <code>f</code> the extracted features, and <code>i</code> the intensity image.</p>"},{"location":"examples/evaluation/#config-file","title":"Config file","text":"<p>For more complex evaluations, a config file can be used. Here's an example config file, <pre><code>output_dir: ./results/\n\ndatasets:\n  # Run on all of newer college trajectories\n  - hilti_2022/*\n  # Run on first 1000 scans of multi campus\n  - name: multi_campus/ntu_day_01\n    length: 1000\n\npipelines:\n  # Run vanilla kiss with default parameters\n  - kiss\n  # Tweak kiss parameters\n  - name: kiss_tweaked\n    pipeline: kiss\n    deskew: true\n    # Perform a parameter sweep over other parameters\n    sweep:\n      voxel_size: [0.1, 0.5, 1.0]\n      # Can also eval python code to create sweep (including numpy functionality)\n      initial_threshold: linspace(0.5, 2.0, 4)\n</code></pre></p> <p>A few notes, - For datasets, a wildcard <code>*</code> can be used to run on all sequences in that dataset. - In the dataset section, a bare item <code>- hilti_2022/basement_2</code> is shorthand for <code>- name: hilti_2022/basement_2</code>. - Similarly for pipelines, a bare item <code>- kiss</code> is shorthand for <code>- pipeline: kiss</code>. - If a pipeline name is not set, it defaults to the pipeline name. - The <code>sweep</code> section is used to run the pipeline with different parameters. The parameters are set as a list, and the pipeline will be run for each parameter in the list, with the name of the pipeline being set to <code>name__parameter-value</code>. - <code>sweep</code> values can also be python code snippets that will be evaluated to generate the list of values for larger and more complex sweeps. This includes usage of a subset of functions in <code>math</code> and <code>numpy</code>.</p> <p>The config file can be run with, <pre><code>evalio run -c config.yaml\n</code></pre> Results will be saved to the <code>output_dir</code> specified in the config file, with nested results based on the dataset. Visualization options can also be used here. Mixing the config file and command line options is not allowed, just for reducing the number of possible combinations.</p>"},{"location":"examples/evaluation/#evaluating","title":"Evaluating","text":"<p>Once trajectories have been run, statistics can be calculated, <pre><code>evalio stats -d results -m mean -w 200 -s RTEt\n</code></pre> With <code>-m/--metric</code> specifying the metric to calculate with options including mean, median, and sse and <code>-w/--window</code> specifying the window size for RTE, with a default of 100 scans. Only first part of all trajectories can also be done using the <code>-l/--length</code> option. Sorting of the results can be done with the <code>-s/--sort</code> option, with any column heading being an allowed option. </p>"},{"location":"examples/odometry/","title":"Odometry","text":"<p>If one off odometry is needed, such as for testing a loop closure algorithm, evalio can generate it for you. For example, to generate odometry for the first 2000 scans of the Newer College 2020 dataset using KissICP, <pre><code>evalio run -p kiss -d newer_college_2020/short_experiment -o odometry.csv -l 2000\n</code></pre></p> <p>The odometry will be in the IMU frame and saved in the TUM format,  $$ [t\\ \\text{(sec)}, p_x, p_y, p_z, q_x, q_y, q_z, q_w] $$ along with metadata about how the trajectory was generated behind the '#' character. The above for the first 10 scans would look like: <pre><code># name: kiss\n# pipeline: kiss\n# version: 1.2.2\n# convergence_criterion: 0.0001\n# deskew: False\n# initial_threshold: 2.0\n# max_num_iterations: 500\n# max_num_threads: 0\n# max_points_per_voxel: 20\n# min_motion_th: 0.1\n# voxel_size: 1.0\n#\n# dataset: newer_college_2020\n# sequence: short_experiment\n# length: 100\n#\n# timestamp, x, y, z, qx, qy, qz, qw\n1583836591.082580992,0.006252999883145094,-0.011775000020861626,-0.007644999772310257,0.0,0.0,-1.0,0.0\n1583836591.182590976,0.002104584749512301,-0.014210604585971584,-0.007355713813266136,-2.675152057596367e-05,-8.363399211902303e-06,-0.9999999975888385,-6.353528931178803e-05\n1583836591.282592512,0.0027150532454897226,-0.004297982387396928,-0.015746353734418864,-4.334993947940944e-05,-6.124874074873121e-05,-0.999999996655854,3.2521785965193945e-05\n1583836591.382579456,0.00597131720748457,-0.011520632994006833,-0.006492858132001103,6.470950992969571e-05,-4.590305780285223e-05,-0.9999999968522549,1.0386708003358978e-06\n1583836591.482568704,0.007478720199430491,-0.009223450849391,-0.003496780595402071,1.4720267758293692e-06,3.463391730777789e-05,-0.9999999993679838,7.896668660298116e-06\n1583836591.582553088,0.0012911112076719805,-0.012163729075573013,-0.001935118832270371,1.711692196181323e-05,5.2587891622865136e-05,-0.9999999978422404,3.545481795975868e-05\n1583836591.682529024,0.0026154127249510307,-0.0111173632560525,-0.005718297889001694,-2.7387527703120896e-05,2.907679171021379e-05,-0.9999999988611495,-2.6118280969886083e-05\n1583836591.782496512,0.0042376370480087765,-0.01660435415391814,-0.004709413029178095,-5.202183158898017e-05,6.121947284618483e-05,-0.9999999961629367,-3.492895473336578e-05\n1583836591.882515968,0.003165756615792398,-0.012502098488453172,-0.0014189397620055577,-1.48525422597923e-05,6.736687040505698e-05,-0.9999999976119399,4.150543609892368e-06\n1583836591.982548736,-0.000298752072032382,-0.009307858981044354,-0.01089797673030992,-1.0989202198288011e-05,-4.521269654356091e-05,-0.999999998085071,4.0803279324257364e-05\n</code></pre></p> <p>This file can then by loaded and aligned to the ground truth as needed using the python API. <pre><code>from evalio.types import Trajectory\nfrom evalio.datasets import NewerCollege2020\nfrom evalio import stats\n\ntraj = Trajectory.from_experiment(\"odometry.csv\")\ngt = NewerCollege2020.short_experiment.ground_truth()\n\n# Align the odometry to the ground truth\ntraj_aligned, gt_aligned = stats.align(traj, gt)\n\n# Compute metrics as desired (will align if not already aligned)\nerror =  stats.rte(traj, gt).mean()\n</code></pre></p>"},{"location":"examples/pipeline/","title":"Custom Pipeline","text":"<p>evalio comes with a small number of built-in pipelines, but is made to be easily extensible. Custom pipelines can be created in C++ with nanobind, or in Python. See evalio-example for some examples of building C++ pipelines as well as custom python pipelines.</p> <p>To get evalio to find your custom pipeline, simply point the environment variable <code>EVALIO_CUSTOM=my_module</code> to the module where your pipeline is defined.</p> <p>To create a pipeline, simply inherit from the <code>Pipeline</code> class,</p> PythonC++ <pre><code>from evalio.pipelines import Pipeline\nfrom evalio.types import (\n    SE3,\n    Point,\n    ImuParams,\n    LidarParams,\n    ImuMeasurement,\n    LidarMeasurement,\n)\n\nclass MyPipeline(Pipeline):\n    def __init__(self):\n        super().__init__()\n\n    # Info\n    @staticmethod\n    def version() -&gt; str: ...\n    @staticmethod\n    def url() -&gt; str: ...\n    @staticmethod\n    def name() -&gt; str: ...\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...;\n\n    # Getters\n    def pose(self) -&gt; SE3: ...\n    def map(self) -&gt; list[Point]: ...\n\n    # Setters\n    def set_imu_params(self, params: ImuParams): ...\n    def set_lidar_params(self, params: LidarParams): ...\n    def set_imu_T_lidar(self, T: SE3): ...\n    def set_params(self, params: dict[str, bool | int | float | str]): ...\n\n    # Doers\n    def initialize(self): ...\n    def add_imu(self, mm: ImuMeasurement): ...\n    def add_lidar(self, mm: LidarMeasurement) -&gt; list[Point]: ...\n</code></pre> <pre><code>#include \"evalio/pipeline.h\"\n#include \"evalio/types.h\"\n\n#include &lt;nanobind/nanobind.h&gt;\n#include &lt;nanobind/stl/map.h&gt;\n#include &lt;nanobind/stl/string.h&gt;\n#include &lt;nanobind/stl/variant.h&gt;\n\nnamespace nb = nanobind;\n\nclass MyPipeline : public evalio::Pipeline {\npublic:\n    MyPipeline() : evalio::Pipeline() {}\n\n    // Info\n    static std::string version() { ... }\n    static std::string url() { ... }\n    static std::string name() { ... }\n    static std::map&lt;std::string, Param&gt; default_params() { ... };\n\n    // Getters\n    const SE3 pose() { ... };\n    const std::vector&lt;Point&gt; map() { ... };\n\n    // Setters\n    void set_imu_params(ImuParams params) { ... };\n    void set_lidar_params(LidarParams params) { ... };\n    void set_imu_T_lidar(SE3 T) { ... };\n    void set_params(std::map&lt;std::string, Param&gt;) { ... };\n\n    // Doers\n    void initialize() { ... };\n    void add_imu(ImuMeasurement mm) { ... };\n    std::vector&lt;Point&gt; add_lidar(LidarMeasurement mm) { ... };\n}\n</code></pre> <p>We'll cover each section of methods in turn.</p>"},{"location":"examples/pipeline/#info","title":"Info","text":"<p>The first four methods are all static methods that provide information about the pipeline. <code>version</code>, <code>url</code>, and <code>name</code> are all self-explanatory. <code>default_params</code> is a static method that returns a dictionary of the default parameters for the pipeline. This is used to verify parameters before they are passed in, as well as ensure a consistent output for each run.</p>"},{"location":"examples/pipeline/#getters","title":"Getters","text":"<p>The next two methods are getters for the pose and map. The pose is the most up-to-date estimate for the IMU and is polled after each lidar measurement is passed in. </p> <p>The map current map/submap/etc and is only used for visualization purposes.</p>"},{"location":"examples/pipeline/#setters","title":"Setters","text":"<p>These are to set both dataset specific parameters and pipeline specific parameters. The dataset specific parameters are <code>imu_params</code>, <code>lidar_params</code>, and <code>imu_T_lidar</code>. These are all set before the pipeline is run.</p> <p>The pipeline specific parameters are set using <code>set_params</code>, which takes in a dictionary of parameters. This is used to set any parameters that are specific to the pipeline, such as the number of iterations or the convergence threshold. <code>default_params</code> is updated with any parameters and passed at the start of each run.</p>"},{"location":"examples/pipeline/#doers","title":"Doers","text":"<p>Arguably the most important part. </p> <p><code>initialize</code> is called right after all parameters are set. Think of it as a delayed constructor.</p> <p><code>add_imu</code> is called for each IMU measurement. This is where the IMU data is processed and used to update the pose.</p> <p><code>add_lidar</code> is called for each lidar measurement. This is where the lidar data is processed and used to update the map. It returns a list of features were extracted from the scan and are used for visualization.</p>"},{"location":"examples/pipeline/#c-building","title":"C++ Building","text":"<p>If done in C++, you will need to build the pipeline as a shared library. This is done by a nanobind wrapper, which can be defined at the bottom of your file as follows, <pre><code>NB_MODULE(_core, m) {\n  m.doc() = \"Custom evalio pipeline example\";\n\n  nb::module_ evalio = nb::module_::import_(\"evalio\");\n\n  // Only have to override the static methods here\n  // All the others will be automatically inherited from the base class\n  nb::class_&lt;MyCppPipeline, evalio::Pipeline&gt;(m, \"MyCppPipeline\")\n      .def(nb::init&lt;&gt;())\n      .def_static(\"name\", &amp;MyCppPipeline::name)\n      .def_static(\"url\", &amp;MyCppPipeline::url)\n      .def_static(\"default_params\", &amp;MyCppPipeline::default_params);\n}\n</code></pre></p> <p>We recommend then setting everything up to be built with <code>scikit-build-core</code>. You can see evalio-example for an example of how to set this up.</p> <p>Warning</p> <p>In order for nanobind to share types between the <code>evalio</code> shared object and your custom pipeline, they will have to be compiled with the same version of <code>libstdc++</code>. This pybind PR discusses this in more detail.</p> <p>The \"abi_tag\" used in your version of evalio can be gotten using <code>evalio._abi_tag()</code>, or by running <code>python -c \"import evalio; print(evalio._abi_tag())</code>\". To make sure it matches your nanobind module's, add this to your <code>NB_MODULE</code> definition:</p> <pre><code>m.def(\"abi_tag\", []() { return nb::detail::abi_tag(); });\n</code></pre> <p>That's all there is to it! Pipelines should be fairly easy to implement and are usually just a simple wrapper around your existing code to provide a common interface. Once your pipeline is open-source/published/etc, feel free to make a PR to add it to evalio. This both improves the visibility of your work and of evalio.</p>"},{"location":"included/datasets/","title":"Datasets","text":"<p>evalio comes with a variety of datasets that can be used for easy loading. Below is a table of all datasets that are included, which mirrors the output of <code>evalio ls datasets</code>.</p> Name Sequences Len Env Vehicle IMU LiDAR Info enwide field_dfield_sintersection_dintersection_skatzensee_dkatzensee_srunway_drunway_stunnel_dtunnel_s \u00a02.5min\u00a02.8min\u00a03.0min\u00a03.3min\u00a01.4min\u00a02.7min\u00a03.2min\u00a03.7min\u00a02.0min\u00a04.0min FieldFieldPlanar\u00a0RoadPlanar\u00a0RoadFieldFieldPlanar\u00a0RoadPlanar\u00a0RoadTunnelTunnel HandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheld TDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HT Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128 link cumulti kittredge_loop_robot1kittredge_loop_robot2kittredge_loop_robot3kittredge_loop_robot4main_campus_robot1main_campus_robot2main_campus_robot3main_campus_robot4 \u2011\u2011\u2011\u2011\u2011\u2011\u2011\u2011 CU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0Campus ATVATVATVATVATVATVATVATV MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7 Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07) link newer_college_2020 short_experimentlong_experimentquad_with_dynamicsdynamic_spinningparkland_mound 25.5min44.3min\u2011\u2011\u2011 Oxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0Campus HandheldHandheldHandheldHandheldHandheld TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948 Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164 link helipr kaist_05kaist_06dcc_05dcc_06riverside_05riverside_06 20.8min20.3min18.0min17.9min14.3min19.9min Urban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0Driving CarCarCarCarCarCar Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300 Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128 link hilti_2022 construction_upper_level_1construction_upper_level_2construction_upper_level_3basement_2attic_to_upper_gallery_2corridor_lower_gallery_2 \u00a02.1min\u00a02.1min\u00a02.5min\u00a01.2min\u00a03.3min\u00a01.8min IndoorIndoorIndoorIndoorIndoorIndoor HandheldHandheldHandheldHandheldHandheldHandheld Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085 Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132 link multi_campus ntu_day_01ntu_day_02ntu_day_10ntu_night_04ntu_night_08ntu_night_13kth_day_06kth_day_09kth_day_10kth_night_01kth_night_04kth_night_05tuhh_day_02tuhh_day_03tuhh_day_04tuhh_night_07tuhh_night_08tuhh_night_09 10.0min\u00a03.8min\u00a05.4min\u00a04.9min\u00a07.8min\u00a03.9min14.9min12.8min10.3min16.1min12.4min11.1min\u00a08.3min14.0min\u00a03.1min\u00a07.4min11.8min\u00a03.1min NTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0Campus ATVATVATVATVATVATVHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheld VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200 Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164 link oxford_spires blenheim_palace_01blenheim_palace_02blenheim_palace_05bodleian_library_02christ_church_01christ_church_02christ_church_03christ_church_05keble_college_02keble_college_03keble_college_04observatory_quarter_01observatory_quarter_02 \u00a06.8min\u00a06.1min\u00a05.7min\u00a08.3min\u2011\u2011\u00a05.2min13.3min\u00a05.0min\u00a04.8min\u2011\u00a04.8min\u00a04.6min Indoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusOxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusOxford\u00a0CampusOxford\u00a0Campus BackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpack Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085 Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164 link botanic_garden b1005_00b1005_01b1005_07b1006_01b1008_03b1018_00b1018_13 \u00a09.7min\u00a07.9min\u00a09.1min12.4min10.5min\u00a02.4min\u00a03.5min Botanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0Garden ATVATVATVATVATVATVATV Xsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680G Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116 link newer_college_2021 quad_easyquad_mediumquad_hardstairscloisterparkmaths_easymaths_mediummaths_hard \u00a03.3min\u00a03.2min\u00a03.1min\u00a02.0min\u00a04.6min26.2min\u00a03.6min\u00a03.0min\u00a04.1min Oxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0Campus HandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheld TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948 Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128 link"},{"location":"included/pipelines/","title":"Pipelines","text":"<p>evalio comes with a variety of pipelines that can be used for evaluation. Below is a table of all pipelines that are included and their parameters, which mirrors the output of <code>evalio ls pipelines</code>.</p> Name Version Params Default Info liosam 0.1.0 downsampleRateedgeFeatureMinValidNumedgeThresholdglobalMapVisualizationLeafSizeglobalMapVisualizationPoseDensityglobalMapVisualizationSearchRadiusmappingCornerLeafSizemappingProcessIntervalmappingSurfLeafSizenumberOfCoresodometrySurfLeafSizerotation_tolerancesurfFeatureMinValidNumsurfThresholdsurroundingKeyframeDensitysurroundingKeyframeSearchRadiussurroundingkeyframeAddingAngleThresholdsurroundingkeyframeAddingDistThresholdz_tolerance 1101.01.010.01000.00.20.150.440.41000.01000.12.050.00.21.01000.0 link ct 0.0.1 beta_constant_velocitybeta_location_consistencybeta_orientation_consistencybeta_small_velocityct_init_num_framesdistancedistance_error_thresholdestimate_normal_from_neighborhoodinit_num_framesinit_sample_voxel_sizeinit_voxel_sizeinitializationloss_functionls_max_num_itersls_num_threadsls_sigmals_tolerant_min_thresholdmax_dist_to_plane_ct_icpmax_num_points_in_voxelmax_num_residualsmax_number_neighborsmin_distance_pointsmin_num_residualsmin_number_neighborsmotion_compensationnum_closest_neighborsnum_iters_icppoint_to_plane_with_distortionpower_planaritysample_voxel_sizesize_voxel_mapsolverthreshold_orientation_normthreshold_translation_normthreshold_voxel_occupancyvoxel_neighborhoodvoxel_sizeweight_alphaweight_neighborhoodweighting_scheme 0.0010.0010.00.020CT_POINT_TO_PLANE5.0True201.00.2INIT_CONSTANT_VELOCITYCAUCHY1080.10.050.520\u20111200.110020CONTINUOUS130True2.01.51.0CERES0.00010.001110.50.90.1ALL link loam 1.0.0 edge_feat_thresholdmax_avg_point_plane_distmax_edge_feats_per_sectormax_edge_neighbor_distmax_icf_iterationsmax_planar_feats_per_sectormax_plane_neighbor_distmin_line_condition_numbermin_line_fit_pointsmin_plane_fit_pointsneighbor_pointsnum_edge_neighborsnum_local_map_scansnum_plane_neighborsnumber_sectorsocclusion_threshparallel_threshplanar_feat_thresholdposition_convergence_threshrotation_convergence_thresh 100.00.252.020504.05.034353560.51.01.00.0010.0001 link mad 0.0.10 b_maxb_minb_ratiodeskewnum_keyframesnum_threadsp_threaltimerho_ker 0.20.10.02False800.8True0.1 link genz 0.2.0 convergence_criteriondesired_num_voxelized_pointsdeskewinitial_thresholdmax_num_iterationsmax_points_per_voxelmin_motion_thplanarity_thresholdvoxel_size 0.00012000False2.010010.10.20.3 link kiss 1.2.2 convergence_criteriondeskewinitial_thresholdmax_num_iterationsmax_num_threadsmax_points_per_voxelmin_motion_thvoxel_size 0.0001False2.05000200.11.0 link"},{"location":"ref/cli/","title":"<code>evalio</code>","text":"<p>Tool for evaluating Lidar-Inertial Odometry pipelines on open-source datasets</p> <p>Usage:</p> <pre><code>$ evalio [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>-D, --data-dir PATH</code>: Directory to store downloaded datasets.</li> <li><code>-M, --module TEXT</code>: Custom module to load (for custom datasets or pipelines). Can be used multiple times.</li> <li><code>-V, --version</code>: Show version and exit.</li> <li><code>--install-completion</code>: Install completion for the current shell.</li> <li><code>--show-completion</code>: Show completion for the current shell, to copy it or customize the installation.</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>dl</code>: Download datasets</li> <li><code>rm</code>: Remove dataset(s)</li> <li><code>filter</code>: Filter rosbag dataset(s) to only include...</li> <li><code>ls</code>: List dataset and pipeline information</li> <li><code>run</code>: Run pipelines on datasets</li> <li><code>stats</code>: Evaluate the results of experiments.</li> </ul>"},{"location":"ref/cli/#evalio-dl","title":"<code>evalio dl</code>","text":"<p>Download datasets</p> <p>Usage:</p> <pre><code>$ evalio dl [OPTIONS] DATASETS...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DATASETS...</code>: The dataset(s) to use  [required]</li> </ul> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-rm","title":"<code>evalio rm</code>","text":"<p>Remove dataset(s)</p> <p>If --force is not used, will ask for confirmation.</p> <p>Usage:</p> <pre><code>$ evalio rm [OPTIONS] DATASETS...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DATASETS...</code>: The dataset(s) to use  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-f, --force</code>: Force deletion without confirmation</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-filter","title":"<code>evalio filter</code>","text":"<p>Filter rosbag dataset(s) to only include lidar and imu data. Useful for shrinking disk size.</p> <p>Usage:</p> <pre><code>$ evalio filter [OPTIONS] DATASETS...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DATASETS...</code>: The dataset(s) to use  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-f, --force</code>: Force deletion without confirmation</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-ls","title":"<code>evalio ls</code>","text":"<p>List dataset and pipeline information</p> <p>Usage:</p> <pre><code>$ evalio ls [OPTIONS] KIND:{datasets|pipelines}\n</code></pre> <p>Arguments:</p> <ul> <li><code>KIND:{datasets|pipelines}</code>: The kind of object to list  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-s, --search TEXT</code>: Fuzzy search for a pipeline or dataset by name</li> <li><code>-q, --quiet</code>: Output less verbose information</li> <li><code>--show-hyperlinks</code>: Output full links. For terminals that don't support hyperlinks (OSC 8).</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-run","title":"<code>evalio run</code>","text":"<p>Run pipelines on datasets</p> <p>Usage:</p> <pre><code>$ evalio run [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-c, --config PATH</code>: Config file to load from</li> <li><code>-d, --datasets TEXT</code>: The dataset(s) to use</li> <li><code>-p, --pipelines TEXT</code>: The pipeline(s) to use</li> <li><code>-o, --output PATH</code>: Output directory to save results</li> <li><code>-l, --length INTEGER</code>: Number of scans to process for each dataset</li> <li><code>-v, --visualize</code>: Visualize the results via rerun</li> <li><code>-s, --show PARSE</code>: Show visualization options (m: map, i: image, s: scan, f: features). Automatically implies -v.</li> <li><code>--rerun-failed</code>: Rerun failed experiments. If not set, will skip previously failed experiments.</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-stats","title":"<code>evalio stats</code>","text":"<p>Evaluate the results of experiments.</p> <p>Usage:</p> <pre><code>$ evalio stats [OPTIONS] DIRECTORIES...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DIRECTORIES...</code>: Directory of results to evaluate.  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-v, --visualize</code>: Visualize results.</li> <li><code>-S, --sort TEXT</code>: Sort results by the name of a column. Defaults to RTEt.</li> <li><code>-r, --reverse</code>: Reverse the sorting order. Defaults to False.</li> <li><code>-f, --filter TEXT</code>: Python expressions to filter results rows. 'True' rows will be kept. Example: --filter 'RTEt &lt; 0.5'</li> <li><code>--only-complete</code>: Only show results for trajectories that completed.</li> <li><code>--only-failed</code>: Only show results for trajectories that failed.</li> <li><code>-h, --hide TEXT</code>: Columns to hide, may be repeated.</li> <li><code>-s, --show TEXT</code>: Columns to force show, may be repeated.</li> <li><code>--print-columns</code>: Print the names of all available columns.</li> <li><code>--w-meters FLOAT</code>: Window size in meters for RTE computation. May be repeated. Defaults to 30m.</li> <li><code>--w-seconds FLOAT</code>: Window size in seconds for RTE computation. May be repeated. Defaults to none.</li> <li><code>--metric [mean|median|sse]</code>: Metric to use for ATE/RTE computation. Defaults to sse.  [default: sse]</li> <li><code>-l, --length INTEGER</code>: Specify subset of trajectory to evaluate.</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/datasets/","title":"evalio.datasets","text":"<p>For more information about the datasets included in evalio, see the included datasets section.</p> <p>Classes:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>The base class for all datasets.</p> </li> <li> <code>DatasetIterator</code>           \u2013            <p>This is the base class for iterating over datasets.</p> </li> <li> <code>RawDataIter</code>           \u2013            <p>An iterator for loading from python iterables.</p> </li> <li> <code>RosbagIter</code>           \u2013            <p>An iterator for loading from rosbag files.</p> </li> <li> <code>BotanicGarden</code>           \u2013            <p>Dataset taken from a botanical garden, specifically for testing unstructured environments. Ground truth is gathered using a survey grade lidar.</p> </li> <li> <code>CUMulti</code>           \u2013            <p>Dataset collected by a ground robot (AgileX - Hunter) on the University of Colorado Boulder Campus.</p> </li> <li> <code>EnWide</code>           \u2013            <p>Dataset taken in purposely degenerate locations such as a field, intersections, tunnels, and runways. All data comes directly from the Ouster unit.</p> </li> <li> <code>HeLiPR</code>           \u2013            <p>Self-driving car dataset taken in urban environments. Ground truth is generated using filtering of an RTK-GNSS system.</p> </li> <li> <code>Hilti2022</code>           \u2013            <p>Sequences with ground truth taken from the Hilti 2022 SLAM Challenge, mostly taken from indoors.</p> </li> <li> <code>MultiCampus</code>           \u2013            <p>Data taken from a variety of campus (KTH, NTU, TUHH) in Asia and Europe at different seasons, at day and night, and with an ATV and handheld platform.</p> </li> <li> <code>NewerCollege2020</code>           \u2013            <p>Dataset taken from outdoor Oxford Campus. Ground truth is generated using ICP matching against a laser scanner.</p> </li> <li> <code>NewerCollege2021</code>           \u2013            <p>Dataset outdoors on oxford campus with a handheld device consisting of an alphasense core and a Ouster lidar.</p> </li> <li> <code>OxfordSpires</code>           \u2013            <p>Dataset taken both indoors and outdoors on the Oxford campus.</p> </li> <li> <code>DatasetNotFound</code>           \u2013            <p>Exception raised when a dataset is not found.</p> </li> <li> <code>SequenceNotFound</code>           \u2013            <p>Exception raised when a sequence is not found.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_data_dir</code>             \u2013              <p>Get the global data directory. This is where downloaded data is stored.</p> </li> <li> <code>set_data_dir</code>             \u2013              <p>Set the global location where datasets are stored. This will be used to store the downloaded data.</p> </li> <li> <code>all_datasets</code>             \u2013              <p>Get all registered datasets.</p> </li> <li> <code>get_dataset</code>             \u2013              <p>Get a registered dataset by name.</p> </li> <li> <code>all_sequences</code>             \u2013              <p>Get all sequences from all registered datasets.</p> </li> <li> <code>get_sequence</code>             \u2013              <p>Get a registered sequence by name.</p> </li> <li> <code>register_dataset</code>             \u2013              <p>Register a dataset.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset","title":"Dataset","text":"<p>               Bases: <code>StrEnum</code></p> <p>The base class for all datasets.</p> <p>This class provides an interface for loading datasets, including loading parameters and iterating over measurements. All datasets are string enums, where each enum member represents a trajectory sequence in the dataset.</p> <p>Methods:</p> <ul> <li> <code>data_iter</code>             \u2013              <p>Provides an iterator over the dataset's measurements.</p> </li> <li> <code>ground_truth_raw</code>             \u2013              <p>Retrieves the raw ground truth trajectory, as represented in the ground truth frame.</p> </li> <li> <code>imu_T_lidar</code>             \u2013              <p>Returns the transformation from IMU to Lidar frame.</p> </li> <li> <code>imu_T_gt</code>             \u2013              <p>Retrieves the transformation from IMU to ground truth frame.</p> </li> <li> <code>imu_params</code>             \u2013              <p>Specifies the parameters of the IMU.</p> </li> <li> <code>lidar_params</code>             \u2013              <p>Specifies the parameters of the Lidar.</p> </li> <li> <code>files</code>             \u2013              <p>Return list of files required to run this dataset.</p> </li> <li> <code>url</code>             \u2013              <p>Webpage with the dataset information.</p> </li> <li> <code>environment</code>             \u2013              <p>Environment where the dataset was collected.</p> </li> <li> <code>vehicle</code>             \u2013              <p>Vehicle used to collect the dataset.</p> </li> <li> <code>quick_len</code>             \u2013              <p>Hardcoded number of lidar scans in the dataset, rather than computing by loading all the data (slow).</p> </li> <li> <code>download</code>             \u2013              <p>Method to download the dataset.</p> </li> <li> <code>dataset_name</code>             \u2013              <p>Name of the dataset, in snake case.</p> </li> <li> <code>is_downloaded</code>             \u2013              <p>Verify if the dataset is downloaded.</p> </li> <li> <code>ground_truth</code>             \u2013              <p>Get the ground truth trajectory in the IMU frame, rather than the ground truth frame as returned in ground_truth_raw.</p> </li> <li> <code>__len__</code>             \u2013              <p>Return the number of lidar scans.</p> </li> <li> <code>__iter__</code>             \u2013              <p>Main interface for iterating over measurements of all types.</p> </li> <li> <code>imu</code>             \u2013              <p>Iterate over just IMU measurements.</p> </li> <li> <code>lidar</code>             \u2013              <p>Iterate over just Lidar measurements.</p> </li> <li> <code>get_one_lidar</code>             \u2013              <p>Get a single Lidar measurement.</p> </li> <li> <code>get_one_imu</code>             \u2013              <p>Get a single IMU measurement.</p> </li> <li> <code>sequences</code>             \u2013              <p>All sequences in the dataset.</p> </li> <li> <code>size_on_disk</code>             \u2013              <p>Shows the size of the dataset on disk, in GB.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>seq_name</code>               (<code>str</code>)           \u2013            <p>Name of the sequence, in snake case.</p> </li> <li> <code>full_name</code>               (<code>str</code>)           \u2013            <p>Full name of the dataset, including the dataset name and sequence name.</p> </li> <li> <code>folder</code>               (<code>Path</code>)           \u2013            <p>The folder in the global dataset directory where this dataset is stored.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>class Dataset(StrEnum):\n    \"\"\"The base class for all datasets.\n\n    This class provides an interface for loading datasets, including loading parameters and iterating over measurements.\n    All datasets are string enums, where each enum member represents a trajectory sequence in the dataset.\n    \"\"\"\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        \"\"\"\n        Provides an iterator over the dataset's measurements.\n\n        Returns:\n            An iterator that yields measurements from the dataset.\n        \"\"\"\n        ...\n\n    # Return the ground truth in the ground truth frame\n    def ground_truth_raw(self) -&gt; Trajectory:\n        \"\"\"\n        Retrieves the raw ground truth trajectory, as represented in the ground truth frame.\n\n        Returns:\n            The raw ground truth trajectory data.\n        \"\"\"\n        ...\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        \"\"\"Returns the transformation from IMU to Lidar frame.\n\n        Returns:\n            Transformation from IMU to Lidar frame.\n        \"\"\"\n        ...\n\n    def imu_T_gt(self) -&gt; SE3:\n        \"\"\"Retrieves the transformation from IMU to ground truth frame.\n\n        Returns:\n            Transformation from IMU to ground truth frame.\n        \"\"\"\n        ...\n\n    def imu_params(self) -&gt; ImuParams:\n        \"\"\"Specifies the parameters of the IMU.\n\n        Returns:\n            Parameters of the IMU.\n        \"\"\"\n        ...\n\n    def lidar_params(self) -&gt; LidarParams:\n        \"\"\"Specifies the parameters of the Lidar.\n\n        Returns:\n            Parameters of the Lidar.\n        \"\"\"\n        ...\n\n    def files(self) -&gt; Sequence[str | Path]:\n        \"\"\"Return list of files required to run this dataset.\n\n        If a returned type is a Path, it will be checked as is. If it is a string, it will be prepended with [folder][evalio.datasets.Dataset.folder].\n\n        Returns:\n            List of files required to run this dataset.\n        \"\"\"\n        ...\n\n    # ------------------------- Optional dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        \"\"\"Webpage with the dataset information.\n\n        Returns:\n            URL of the dataset webpage.\n        \"\"\"\n        return \"-\"\n\n    def environment(self) -&gt; str:\n        \"\"\"Environment where the dataset was collected.\n\n        Returns:\n            Environment where the dataset was collected.\n        \"\"\"\n        return \"-\"\n\n    def vehicle(self) -&gt; str:\n        \"\"\"Vehicle used to collect the dataset.\n\n        Returns:\n            Vehicle used to collect the dataset.\n        \"\"\"\n        return \"-\"\n\n    def quick_len(self) -&gt; Optional[int]:\n        \"\"\"Hardcoded number of lidar scans in the dataset, rather than computing by loading all the data (slow).\n\n        Returns:\n            Number of lidar scans in the dataset. None if not available.\n        \"\"\"\n        return None\n\n    def download(self) -&gt; None:\n        \"\"\"Method to download the dataset.\n\n        Completely optional to implement, although most datasets do.\n\n        Raises:\n            NotImplementedError: If not implemented.\n        \"\"\"\n        raise NotImplementedError(\"Download not implemented\")\n\n    # TODO: This would match better as a \"classproperty\", but not will involve some work\n    @classmethod\n    def dataset_name(cls) -&gt; str:\n        \"\"\"Name of the dataset, in snake case.\n\n        This is the name that will be used when parsing directly from a string. Currently is automatically generated from the class name, but can be overridden.\n\n        Returns:\n            Name of the dataset.\n        \"\"\"\n        return pascal_to_snake(cls.__name__)\n\n    # ------------------------- Helpers that wrap the above ------------------------- #\n    def is_downloaded(self) -&gt; bool:\n        \"\"\"Verify if the dataset is downloaded.\n\n        Returns:\n            True if the dataset is downloaded, False otherwise.\n        \"\"\"\n        self._warn_default_dir()\n        for f in self.files():\n            if isinstance(f, str):\n                if not (self.folder / f).exists():\n                    return False\n            else:\n                if not f.exists():\n                    return False\n\n        return True\n\n    def ground_truth(self) -&gt; Trajectory[GroundTruth]:\n        \"\"\"Get the ground truth trajectory in the **IMU** frame, rather than the ground truth frame as returned in [ground_truth_raw][evalio.datasets.Dataset.ground_truth_raw].\n\n        Returns:\n            The ground truth trajectory in the IMU frame.\n        \"\"\"\n        gt_traj = self.ground_truth_raw()\n        gt_T_imu = self.imu_T_gt().inverse()\n\n        # Convert to IMU frame\n        for i in range(len(gt_traj)):\n            gt_o_T_gt_i = gt_traj.poses[i]\n            gt_traj.poses[i] = gt_o_T_gt_i * gt_T_imu\n\n        gt_traj = cast(Trajectory[GroundTruth], gt_traj)\n        gt_traj.metadata = GroundTruth(sequence=self.full_name)\n\n        return gt_traj\n\n    def _fail_not_downloaded(self):\n        if not self.is_downloaded():\n            # TODO: Make this print with rich?\n            raise ValueError(\n                f\"Data for {self} not found, please use `evalio download {self}` to download\"\n            )\n\n    @classmethod\n    def _warn_default_dir(cls):\n        global _DATA_DIR, _WARNED\n        if not _WARNED and _DATA_DIR == Path(\"./evalio_data\"):\n            print_warning(\n                \"Using default './evalio_data' for base data directory. Override by setting [magenta]EVALIO_DATA[/magenta], [magenta]evalio.set_data_dir(path)[/magenta] in python, or [magenta]-D[/magenta] in the CLI.\"\n            )\n            _WARNED = True\n\n    # ------------------------- Helpers that leverage from the iterator ------------------------- #\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of lidar scans.\n\n        If quick_len is available, it will be used. Otherwise, it will load the entire dataset to get the length.\n\n        Returns:\n            Number of lidar scans.\n        \"\"\"\n        if (length := self.quick_len()) is not None:\n            return length\n\n        self._fail_not_downloaded()\n        return self.data_iter().__len__()\n\n    def __iter__(self) -&gt; Iterator[Measurement]:  # type: ignore\n        \"\"\"Main interface for iterating over measurements of all types.\n\n        Returns:\n            Iterator of all measurements (IMU and Lidar).\n        \"\"\"\n        self._fail_not_downloaded()\n        return self.data_iter().__iter__()\n\n    def imu(self) -&gt; Iterable[ImuMeasurement]:\n        \"\"\"Iterate over just IMU measurements.\n\n        Returns:\n            Iterator of IMU measurements.\n        \"\"\"\n        self._fail_not_downloaded()\n        return self.data_iter().imu_iter()\n\n    def lidar(self) -&gt; Iterable[LidarMeasurement]:\n        \"\"\"Iterate over just Lidar measurements.\n\n        Returns:\n            Iterator of Lidar measurements.\n        \"\"\"\n        self._fail_not_downloaded()\n        return self.data_iter().lidar_iter()\n\n    def get_one_lidar(self, idx: int = 0) -&gt; LidarMeasurement:\n        \"\"\"Get a single Lidar measurement.\n\n        Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.\n\n        Args:\n            idx (int, optional): Index of measurement to get. Defaults to 0.\n\n        Returns:\n            The Lidar measurement at the given index.\n        \"\"\"\n        return next(islice(self.lidar(), idx, idx + 1))\n\n    def get_one_imu(self, idx: int = 0) -&gt; ImuMeasurement:\n        \"\"\"Get a single IMU measurement.\n\n        Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.\n\n        Args:\n            idx (int, optional): Index of measurement to get. Defaults to 0.\n\n        Returns:\n            The IMU measurement at the given index.\n        \"\"\"\n        return next(islice(self.imu(), idx, idx + 1))\n\n    # ------------------------- Misc name helpers ------------------------- #\n    def __str__(self):\n        return self.full_name\n\n    @property\n    def seq_name(self) -&gt; str:\n        \"\"\"Name of the sequence, in snake case.\n\n        Returns:\n            Name of the sequence.\n        \"\"\"\n        return self.value\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Full name of the dataset, including the dataset name and sequence name.\n\n        Example: \"dataset_name/sequence_name\"\n\n        Returns:\n            Full name of the dataset.\n        \"\"\"\n        return f\"{self.dataset_name()}/{self.seq_name}\"\n\n    @classmethod\n    def sequences(cls) -&gt; list[\"Dataset\"]:\n        \"\"\"All sequences in the dataset.\n\n        Returns:\n            List of all sequences in the dataset.\n        \"\"\"\n        return list(cls.__members__.values())\n\n    @property\n    def folder(self) -&gt; Path:\n        \"\"\"The folder in the global dataset directory where this dataset is stored.\n\n        Returns:\n            Path to the dataset folder.\n        \"\"\"\n        global _DATA_DIR\n        return _DATA_DIR / self.full_name\n\n    def size_on_disk(self) -&gt; Optional[float]:\n        \"\"\"Shows the size of the dataset on disk, in GB.\n\n        Returns:\n            Size of the dataset on disk, in GB. None if the dataset is not downloaded.\n        \"\"\"\n\n        if not self.is_downloaded():\n            return None\n        else:\n            return sum(f.stat().st_size for f in self.folder.glob(\"**/*\")) / 1e9\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.seq_name","title":"seq_name  <code>property</code>","text":"<pre><code>seq_name: str\n</code></pre> <p>Name of the sequence, in snake case.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Name of the sequence.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Full name of the dataset, including the dataset name and sequence name.</p> <p>Example: \"dataset_name/sequence_name\"</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Full name of the dataset.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre> <p>The folder in the global dataset directory where this dataset is stored.</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the dataset folder.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.data_iter","title":"data_iter","text":"<pre><code>data_iter() -&gt; DatasetIterator\n</code></pre> <p>Provides an iterator over the dataset's measurements.</p> <p>Returns:</p> <ul> <li> <code>DatasetIterator</code>           \u2013            <p>An iterator that yields measurements from the dataset.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def data_iter(self) -&gt; DatasetIterator:\n    \"\"\"\n    Provides an iterator over the dataset's measurements.\n\n    Returns:\n        An iterator that yields measurements from the dataset.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.ground_truth_raw","title":"ground_truth_raw","text":"<pre><code>ground_truth_raw() -&gt; Trajectory\n</code></pre> <p>Retrieves the raw ground truth trajectory, as represented in the ground truth frame.</p> <p>Returns:</p> <ul> <li> <code>Trajectory</code>           \u2013            <p>The raw ground truth trajectory data.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def ground_truth_raw(self) -&gt; Trajectory:\n    \"\"\"\n    Retrieves the raw ground truth trajectory, as represented in the ground truth frame.\n\n    Returns:\n        The raw ground truth trajectory data.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu_T_lidar","title":"imu_T_lidar","text":"<pre><code>imu_T_lidar() -&gt; SE3\n</code></pre> <p>Returns the transformation from IMU to Lidar frame.</p> <p>Returns:</p> <ul> <li> <code>SE3</code>           \u2013            <p>Transformation from IMU to Lidar frame.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def imu_T_lidar(self) -&gt; SE3:\n    \"\"\"Returns the transformation from IMU to Lidar frame.\n\n    Returns:\n        Transformation from IMU to Lidar frame.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu_T_gt","title":"imu_T_gt","text":"<pre><code>imu_T_gt() -&gt; SE3\n</code></pre> <p>Retrieves the transformation from IMU to ground truth frame.</p> <p>Returns:</p> <ul> <li> <code>SE3</code>           \u2013            <p>Transformation from IMU to ground truth frame.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def imu_T_gt(self) -&gt; SE3:\n    \"\"\"Retrieves the transformation from IMU to ground truth frame.\n\n    Returns:\n        Transformation from IMU to ground truth frame.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu_params","title":"imu_params","text":"<pre><code>imu_params() -&gt; ImuParams\n</code></pre> <p>Specifies the parameters of the IMU.</p> <p>Returns:</p> <ul> <li> <code>ImuParams</code>           \u2013            <p>Parameters of the IMU.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def imu_params(self) -&gt; ImuParams:\n    \"\"\"Specifies the parameters of the IMU.\n\n    Returns:\n        Parameters of the IMU.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.lidar_params","title":"lidar_params","text":"<pre><code>lidar_params() -&gt; LidarParams\n</code></pre> <p>Specifies the parameters of the Lidar.</p> <p>Returns:</p> <ul> <li> <code>LidarParams</code>           \u2013            <p>Parameters of the Lidar.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def lidar_params(self) -&gt; LidarParams:\n    \"\"\"Specifies the parameters of the Lidar.\n\n    Returns:\n        Parameters of the Lidar.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.files","title":"files","text":"<pre><code>files() -&gt; Sequence[str | Path]\n</code></pre> <p>Return list of files required to run this dataset.</p> <p>If a returned type is a Path, it will be checked as is. If it is a string, it will be prepended with folder.</p> <p>Returns:</p> <ul> <li> <code>Sequence[str | Path]</code>           \u2013            <p>List of files required to run this dataset.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def files(self) -&gt; Sequence[str | Path]:\n    \"\"\"Return list of files required to run this dataset.\n\n    If a returned type is a Path, it will be checked as is. If it is a string, it will be prepended with [folder][evalio.datasets.Dataset.folder].\n\n    Returns:\n        List of files required to run this dataset.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.url","title":"url  <code>staticmethod</code>","text":"<pre><code>url() -&gt; str\n</code></pre> <p>Webpage with the dataset information.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>URL of the dataset webpage.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>@staticmethod\ndef url() -&gt; str:\n    \"\"\"Webpage with the dataset information.\n\n    Returns:\n        URL of the dataset webpage.\n    \"\"\"\n    return \"-\"\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.environment","title":"environment","text":"<pre><code>environment() -&gt; str\n</code></pre> <p>Environment where the dataset was collected.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Environment where the dataset was collected.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def environment(self) -&gt; str:\n    \"\"\"Environment where the dataset was collected.\n\n    Returns:\n        Environment where the dataset was collected.\n    \"\"\"\n    return \"-\"\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.vehicle","title":"vehicle","text":"<pre><code>vehicle() -&gt; str\n</code></pre> <p>Vehicle used to collect the dataset.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Vehicle used to collect the dataset.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def vehicle(self) -&gt; str:\n    \"\"\"Vehicle used to collect the dataset.\n\n    Returns:\n        Vehicle used to collect the dataset.\n    \"\"\"\n    return \"-\"\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.quick_len","title":"quick_len","text":"<pre><code>quick_len() -&gt; Optional[int]\n</code></pre> <p>Hardcoded number of lidar scans in the dataset, rather than computing by loading all the data (slow).</p> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>Number of lidar scans in the dataset. None if not available.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def quick_len(self) -&gt; Optional[int]:\n    \"\"\"Hardcoded number of lidar scans in the dataset, rather than computing by loading all the data (slow).\n\n    Returns:\n        Number of lidar scans in the dataset. None if not available.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.download","title":"download","text":"<pre><code>download() -&gt; None\n</code></pre> <p>Method to download the dataset.</p> <p>Completely optional to implement, although most datasets do.</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def download(self) -&gt; None:\n    \"\"\"Method to download the dataset.\n\n    Completely optional to implement, although most datasets do.\n\n    Raises:\n        NotImplementedError: If not implemented.\n    \"\"\"\n    raise NotImplementedError(\"Download not implemented\")\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.dataset_name","title":"dataset_name  <code>classmethod</code>","text":"<pre><code>dataset_name() -&gt; str\n</code></pre> <p>Name of the dataset, in snake case.</p> <p>This is the name that will be used when parsing directly from a string. Currently is automatically generated from the class name, but can be overridden.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Name of the dataset.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>@classmethod\ndef dataset_name(cls) -&gt; str:\n    \"\"\"Name of the dataset, in snake case.\n\n    This is the name that will be used when parsing directly from a string. Currently is automatically generated from the class name, but can be overridden.\n\n    Returns:\n        Name of the dataset.\n    \"\"\"\n    return pascal_to_snake(cls.__name__)\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.is_downloaded","title":"is_downloaded","text":"<pre><code>is_downloaded() -&gt; bool\n</code></pre> <p>Verify if the dataset is downloaded.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the dataset is downloaded, False otherwise.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def is_downloaded(self) -&gt; bool:\n    \"\"\"Verify if the dataset is downloaded.\n\n    Returns:\n        True if the dataset is downloaded, False otherwise.\n    \"\"\"\n    self._warn_default_dir()\n    for f in self.files():\n        if isinstance(f, str):\n            if not (self.folder / f).exists():\n                return False\n        else:\n            if not f.exists():\n                return False\n\n    return True\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.ground_truth","title":"ground_truth","text":"<pre><code>ground_truth() -&gt; Trajectory[GroundTruth]\n</code></pre> <p>Get the ground truth trajectory in the IMU frame, rather than the ground truth frame as returned in ground_truth_raw.</p> <p>Returns:</p> <ul> <li> <code>Trajectory[GroundTruth]</code>           \u2013            <p>The ground truth trajectory in the IMU frame.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def ground_truth(self) -&gt; Trajectory[GroundTruth]:\n    \"\"\"Get the ground truth trajectory in the **IMU** frame, rather than the ground truth frame as returned in [ground_truth_raw][evalio.datasets.Dataset.ground_truth_raw].\n\n    Returns:\n        The ground truth trajectory in the IMU frame.\n    \"\"\"\n    gt_traj = self.ground_truth_raw()\n    gt_T_imu = self.imu_T_gt().inverse()\n\n    # Convert to IMU frame\n    for i in range(len(gt_traj)):\n        gt_o_T_gt_i = gt_traj.poses[i]\n        gt_traj.poses[i] = gt_o_T_gt_i * gt_T_imu\n\n    gt_traj = cast(Trajectory[GroundTruth], gt_traj)\n    gt_traj.metadata = GroundTruth(sequence=self.full_name)\n\n    return gt_traj\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of lidar scans.</p> <p>If quick_len is available, it will be used. Otherwise, it will load the entire dataset to get the length.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of lidar scans.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of lidar scans.\n\n    If quick_len is available, it will be used. Otherwise, it will load the entire dataset to get the length.\n\n    Returns:\n        Number of lidar scans.\n    \"\"\"\n    if (length := self.quick_len()) is not None:\n        return length\n\n    self._fail_not_downloaded()\n    return self.data_iter().__len__()\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Measurement]\n</code></pre> <p>Main interface for iterating over measurements of all types.</p> <p>Returns:</p> <ul> <li> <code>Iterator[Measurement]</code>           \u2013            <p>Iterator of all measurements (IMU and Lidar).</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Measurement]:  # type: ignore\n    \"\"\"Main interface for iterating over measurements of all types.\n\n    Returns:\n        Iterator of all measurements (IMU and Lidar).\n    \"\"\"\n    self._fail_not_downloaded()\n    return self.data_iter().__iter__()\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu","title":"imu","text":"<pre><code>imu() -&gt; Iterable[ImuMeasurement]\n</code></pre> <p>Iterate over just IMU measurements.</p> <p>Returns:</p> <ul> <li> <code>Iterable[ImuMeasurement]</code>           \u2013            <p>Iterator of IMU measurements.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def imu(self) -&gt; Iterable[ImuMeasurement]:\n    \"\"\"Iterate over just IMU measurements.\n\n    Returns:\n        Iterator of IMU measurements.\n    \"\"\"\n    self._fail_not_downloaded()\n    return self.data_iter().imu_iter()\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.lidar","title":"lidar","text":"<pre><code>lidar() -&gt; Iterable[LidarMeasurement]\n</code></pre> <p>Iterate over just Lidar measurements.</p> <p>Returns:</p> <ul> <li> <code>Iterable[LidarMeasurement]</code>           \u2013            <p>Iterator of Lidar measurements.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def lidar(self) -&gt; Iterable[LidarMeasurement]:\n    \"\"\"Iterate over just Lidar measurements.\n\n    Returns:\n        Iterator of Lidar measurements.\n    \"\"\"\n    self._fail_not_downloaded()\n    return self.data_iter().lidar_iter()\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.get_one_lidar","title":"get_one_lidar","text":"<pre><code>get_one_lidar(idx: int = 0) -&gt; LidarMeasurement\n</code></pre> <p>Get a single Lidar measurement.</p> <p>Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.</p> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Index of measurement to get. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LidarMeasurement</code>           \u2013            <p>The Lidar measurement at the given index.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def get_one_lidar(self, idx: int = 0) -&gt; LidarMeasurement:\n    \"\"\"Get a single Lidar measurement.\n\n    Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.\n\n    Args:\n        idx (int, optional): Index of measurement to get. Defaults to 0.\n\n    Returns:\n        The Lidar measurement at the given index.\n    \"\"\"\n    return next(islice(self.lidar(), idx, idx + 1))\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.get_one_imu","title":"get_one_imu","text":"<pre><code>get_one_imu(idx: int = 0) -&gt; ImuMeasurement\n</code></pre> <p>Get a single IMU measurement.</p> <p>Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.</p> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Index of measurement to get. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImuMeasurement</code>           \u2013            <p>The IMU measurement at the given index.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def get_one_imu(self, idx: int = 0) -&gt; ImuMeasurement:\n    \"\"\"Get a single IMU measurement.\n\n    Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.\n\n    Args:\n        idx (int, optional): Index of measurement to get. Defaults to 0.\n\n    Returns:\n        The IMU measurement at the given index.\n    \"\"\"\n    return next(islice(self.imu(), idx, idx + 1))\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.sequences","title":"sequences  <code>classmethod</code>","text":"<pre><code>sequences() -&gt; list[Dataset]\n</code></pre> <p>All sequences in the dataset.</p> <p>Returns:</p> <ul> <li> <code>list[Dataset]</code>           \u2013            <p>List of all sequences in the dataset.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>@classmethod\ndef sequences(cls) -&gt; list[\"Dataset\"]:\n    \"\"\"All sequences in the dataset.\n\n    Returns:\n        List of all sequences in the dataset.\n    \"\"\"\n    return list(cls.__members__.values())\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Dataset.size_on_disk","title":"size_on_disk","text":"<pre><code>size_on_disk() -&gt; Optional[float]\n</code></pre> <p>Shows the size of the dataset on disk, in GB.</p> <p>Returns:</p> <ul> <li> <code>Optional[float]</code>           \u2013            <p>Size of the dataset on disk, in GB. None if the dataset is not downloaded.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def size_on_disk(self) -&gt; Optional[float]:\n    \"\"\"Shows the size of the dataset on disk, in GB.\n\n    Returns:\n        Size of the dataset on disk, in GB. None if the dataset is not downloaded.\n    \"\"\"\n\n    if not self.is_downloaded():\n        return None\n    else:\n        return sum(f.stat().st_size for f in self.folder.glob(\"**/*\")) / 1e9\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator","title":"DatasetIterator","text":"<p>               Bases: <code>Iterable[Measurement]</code></p> <p>This is the base class for iterating over datasets.</p> <p>This class is the main interface used to iterate over the dataset's measurements. It provides an interface for iterating over IMU and Lidar measurements, as well as all measurements interleaved. This allows for standardizing access to loading data, while allowing for loading parameters in Dataset without having to load the data. Generally, will be created by the Dataset.data_iter method.</p> <p>Methods:</p> <ul> <li> <code>imu_iter</code>             \u2013              <p>Main interface for iterating over IMU measurements.</p> </li> <li> <code>lidar_iter</code>             \u2013              <p>Main interface for iterating over Lidar measurements.</p> </li> <li> <code>__iter__</code>             \u2013              <p>Main interface for iterating over all measurements.</p> </li> <li> <code>__len__</code>             \u2013              <p>Number of lidar scans.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>class DatasetIterator(Iterable[Measurement]):\n    \"\"\"This is the base class for iterating over datasets.\n\n    This class is the main interface used to iterate over the dataset's measurements.\n    It provides an interface for iterating over IMU and Lidar measurements, as well as all measurements interleaved.\n    This allows for standardizing access to loading data, while allowing for loading parameters in [Dataset][evalio.datasets.Dataset] without having to load the data.\n    Generally, will be created by the [Dataset.data_iter][evalio.datasets.Dataset.data_iter] method.\n    \"\"\"\n\n    def imu_iter(self) -&gt; Iterator[ImuMeasurement]:\n        \"\"\"Main interface for iterating over IMU measurements.\n\n        Yields:\n            Iterator of IMU measurements.\n        \"\"\"\n        ...\n\n    def lidar_iter(self) -&gt; Iterator[LidarMeasurement]:\n        \"\"\"Main interface for iterating over Lidar measurements.\n\n        Yields:\n            Iterator of Lidar measurements.\n        \"\"\"\n        ...\n\n    def __iter__(self) -&gt; Iterator[Measurement]:\n        \"\"\"Main interface for iterating over all measurements.\n\n        Yields:\n            Iterator of all measurements (IMU and Lidar).\n        \"\"\"\n\n        ...\n\n    # Return the number of lidar scans\n    def __len__(self) -&gt; int:\n        \"\"\"Number of lidar scans.\n\n        Returns:\n            Number of lidar scans.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.imu_iter","title":"imu_iter","text":"<pre><code>imu_iter() -&gt; Iterator[ImuMeasurement]\n</code></pre> <p>Main interface for iterating over IMU measurements.</p> <p>Yields:</p> <ul> <li> <code>ImuMeasurement</code>           \u2013            <p>Iterator of IMU measurements.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def imu_iter(self) -&gt; Iterator[ImuMeasurement]:\n    \"\"\"Main interface for iterating over IMU measurements.\n\n    Yields:\n        Iterator of IMU measurements.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.lidar_iter","title":"lidar_iter","text":"<pre><code>lidar_iter() -&gt; Iterator[LidarMeasurement]\n</code></pre> <p>Main interface for iterating over Lidar measurements.</p> <p>Yields:</p> <ul> <li> <code>LidarMeasurement</code>           \u2013            <p>Iterator of Lidar measurements.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def lidar_iter(self) -&gt; Iterator[LidarMeasurement]:\n    \"\"\"Main interface for iterating over Lidar measurements.\n\n    Yields:\n        Iterator of Lidar measurements.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Measurement]\n</code></pre> <p>Main interface for iterating over all measurements.</p> <p>Yields:</p> <ul> <li> <code>Measurement</code>           \u2013            <p>Iterator of all measurements (IMU and Lidar).</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Measurement]:\n    \"\"\"Main interface for iterating over all measurements.\n\n    Yields:\n        Iterator of all measurements (IMU and Lidar).\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Number of lidar scans.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of lidar scans.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of lidar scans.\n\n    Returns:\n        Number of lidar scans.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.RawDataIter","title":"RawDataIter","text":"<p>               Bases: <code>DatasetIterator</code></p> <p>An iterator for loading from python iterables.</p> <p>Interleaves imu and lidar iterables. Allows for arbitrary data to be loaded and presented in a consistent manner for the base Dataset class. Has identical methods to DatasetIterator.</p> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>python/evalio/datasets/loaders.py</code> <pre><code>class RawDataIter(DatasetIterator):\n    \"\"\"An iterator for loading from python iterables.\n\n    Interleaves imu and lidar iterables. Allows for arbitrary data to be loaded and presented in a consistent manner for the base [Dataset][evalio.datasets.Dataset] class.\n    Has identical methods to [DatasetIterator][evalio.datasets.DatasetIterator].\n    \"\"\"\n\n    T = TypeVar(\"T\", ImuMeasurement, LidarMeasurement)\n\n    def __init__(\n        self,\n        iter_lidar: Iterator[LidarMeasurement],\n        iter_imu: Iterator[ImuMeasurement],\n        num_lidar: int,\n    ):\n        \"\"\"\n        Args:\n            iter_lidar (Iterator[LidarMeasurement]): An iterator over LidarMeasurement\n            iter_imu (Iterator[ImuMeasurement]): An iterator over ImuMeasurement\n            num_lidar (int): The number of lidar measurements\n\n        ``` py\n        from evalio.datasets.loaders import RawDataIter\n        from evalio.types import ImuMeasurement, LidarMeasurement, Stamp\n        import numpy as np\n\n        # Create some fake data\n        imu_iter = (\n            ImuMeasurement(Stamp.from_sec(i), np.zeros(3), np.zeros(3))\n            for i in range(10)\n        )\n        lidar_iter = (LidarMeasurement(Stamp.from_sec(i + 0.1)) for i in range(10))\n\n        # Create the iterator\n        rawdata = RawDataIter(imu_iter, lidar_iter, 10)\n        ```\n        \"\"\"\n        self.iter_lidar = iter_lidar\n        self.iter_imu = iter_imu\n        self.num_lidar = num_lidar\n        # These hold the current values for iteration to compare stamps on what should be returned\n        self.next_lidar = None\n        self.next_imu = None\n\n    def imu_iter(self) -&gt; Iterator[ImuMeasurement]:\n        return self.iter_imu\n\n    def lidar_iter(self) -&gt; Iterator[LidarMeasurement]:\n        return self.iter_lidar\n\n    def __len__(self) -&gt; int:\n        return self.num_lidar\n\n    @staticmethod\n    def _step(iter: Iterator[T]) -&gt; Optional[T]:\n        try:\n            return next(iter)\n        except StopIteration:\n            return None\n\n    def __iter__(self) -&gt; Iterator[Measurement]:\n        self.next_imu = next(self.iter_imu)\n        self.next_lidar = next(self.iter_lidar)\n        return self\n\n    def __next__(self) -&gt; Measurement:\n        # fmt: off\n        match (self.next_imu, self.next_lidar):\n            case (None, None):\n                raise StopIteration\n            case (None, _):\n                to_return, self.next_lidar = self.next_lidar, self._step(self.iter_lidar)\n                return to_return\n            case (_, None):\n                to_return, self.next_imu = self.next_imu, self._step(self.iter_imu)\n                return to_return\n            case (imu, lidar):\n                if imu.stamp &lt; lidar.stamp:\n                    to_return, self.next_imu = self.next_imu, self._step(self.iter_imu)\n                    return to_return\n                else:\n                    to_return, self.next_lidar = self.next_lidar, self._step(self.iter_lidar)\n                    return to_return\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.RawDataIter.__init__","title":"__init__","text":"<pre><code>__init__(\n    iter_lidar: Iterator[LidarMeasurement],\n    iter_imu: Iterator[ImuMeasurement],\n    num_lidar: int,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>iter_lidar</code>               (<code>Iterator[LidarMeasurement]</code>)           \u2013            <p>An iterator over LidarMeasurement</p> </li> <li> <code>iter_imu</code>               (<code>Iterator[ImuMeasurement]</code>)           \u2013            <p>An iterator over ImuMeasurement</p> </li> <li> <code>num_lidar</code>               (<code>int</code>)           \u2013            <p>The number of lidar measurements</p> </li> </ul> <pre><code>from evalio.datasets.loaders import RawDataIter\nfrom evalio.types import ImuMeasurement, LidarMeasurement, Stamp\nimport numpy as np\n\n# Create some fake data\nimu_iter = (\n    ImuMeasurement(Stamp.from_sec(i), np.zeros(3), np.zeros(3))\n    for i in range(10)\n)\nlidar_iter = (LidarMeasurement(Stamp.from_sec(i + 0.1)) for i in range(10))\n\n# Create the iterator\nrawdata = RawDataIter(imu_iter, lidar_iter, 10)\n</code></pre> Source code in <code>python/evalio/datasets/loaders.py</code> <pre><code>def __init__(\n    self,\n    iter_lidar: Iterator[LidarMeasurement],\n    iter_imu: Iterator[ImuMeasurement],\n    num_lidar: int,\n):\n    \"\"\"\n    Args:\n        iter_lidar (Iterator[LidarMeasurement]): An iterator over LidarMeasurement\n        iter_imu (Iterator[ImuMeasurement]): An iterator over ImuMeasurement\n        num_lidar (int): The number of lidar measurements\n\n    ``` py\n    from evalio.datasets.loaders import RawDataIter\n    from evalio.types import ImuMeasurement, LidarMeasurement, Stamp\n    import numpy as np\n\n    # Create some fake data\n    imu_iter = (\n        ImuMeasurement(Stamp.from_sec(i), np.zeros(3), np.zeros(3))\n        for i in range(10)\n    )\n    lidar_iter = (LidarMeasurement(Stamp.from_sec(i + 0.1)) for i in range(10))\n\n    # Create the iterator\n    rawdata = RawDataIter(imu_iter, lidar_iter, 10)\n    ```\n    \"\"\"\n    self.iter_lidar = iter_lidar\n    self.iter_imu = iter_imu\n    self.num_lidar = num_lidar\n    # These hold the current values for iteration to compare stamps on what should be returned\n    self.next_lidar = None\n    self.next_imu = None\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.RosbagIter","title":"RosbagIter","text":"<p>               Bases: <code>DatasetIterator</code></p> <p>An iterator for loading from rosbag files.</p> <p>This is a wrapper around the rosbags library, with some niceties for converting ros PointCloud2 messages to a standardized format. Has identical methods to DatasetIterator.</p> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>python/evalio/datasets/loaders.py</code> <pre><code>class RosbagIter(DatasetIterator):\n    \"\"\"An iterator for loading from rosbag files.\n\n    This is a wrapper around the rosbags library, with some niceties for converting ros PointCloud2 messages to a standardized format.\n    Has identical methods to [DatasetIterator][evalio.datasets.DatasetIterator].\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        lidar_topic: str,\n        imu_topic: str,\n        lidar_params: LidarParams,\n        type_store: Optional[Stores] = None,\n        # Reduce compute by telling the iterator how to format the pointcloud\n        lidar_format: Optional[LidarFormatParams] = None,\n        custom_col_func: Optional[Callable[[LidarMeasurement], None]] = None,\n    ):\n        \"\"\"\n        Args:\n            path (Path): Location of rosbag file(s) or dir(s). If a directory is passed containing multiple bags (ros1 or ros2), all will be loaded.\n            lidar_topic (str): Name of lidar topic.\n            imu_topic (str): Name of imu topic.\n            lidar_params (LidarParams): Lidar parameters, can be gotten from [lidar_params][evalio.datasets.Dataset.lidar_params].\n            type_store (Optional[Stores], optional): Additional type store to be loaded into rosbags. Defaults to None.\n            lidar_format (Optional[LidarFormatParams], optional): Various parameters for how lidar data is stored. If not specified, most will try to be inferred. We strongly recommend setting this to ensure data is standardized properly. Defaults to None.\n            custom_col_func (Optional[Callable[[LidarMeasurement], None]], optional): Function to put the point cloud in row major format. Will generally not be needed, except for strange default orderings. Defaults to None.\n\n        Raises:\n            FileNotFoundError: If the path is a directory and no .bag files are found.\n            ValueError: If the lidar or imu topic is not found in the bag file.\n        \"\"\"\n        self.lidar_topic = lidar_topic\n        self.imu_topic = imu_topic\n        self.lidar_params = lidar_params\n        if lidar_format is None:\n            self.lidar_format = LidarFormatParams()\n        else:\n            self.lidar_format = lidar_format\n        self.custom_col_func = custom_col_func\n\n        # Find all bags (may be either ros1 .bag files or ros2 bag/ dirs)\n        if path.is_file():\n            # Provide path is a ros1 .bag file\n            self.path = [path]\n        else:\n\n            def is_ros2_bag(d: Path) -&gt; bool:\n                return bool(list(d.glob(\"*.mcap\")) + list(d.glob(\"*.db3\")))\n\n            # Path provided is a directory may be ros2 bag/ dir or contain multiple bags\n            ros1_bag_file_list = [p for p in path.glob(\"*.bag\")]\n            ros2_bag_dir_list = [d for d in path.glob(\"*/\") if is_ros2_bag(d)]\n\n            if ros1_bag_file_list:  # path contains ros1 .bag files\n                self.path = ros1_bag_file_list\n            elif ros2_bag_dir_list:  # path contains ros2 bag/ directories\n                self.path = ros2_bag_dir_list\n            elif is_ros2_bag(path):  # path is a ros2 bag/ (contains mcap or db3 file)\n                self.path = [path]\n            else:\n                raise ValueError(\n                    f\"Invalid rosbag path: {path}\\nExpected path to be one of:\\na) ros1 .bag \\nb) ros2 bag/ dir or \\nc) directory multiple a or b\"\n                )\n\n        # Open the bag file\n        self.reader = AnyReader(self.path)\n        self.reader.open()\n\n        # force load passed in type store\n        # there is a default_typestore parameter in AnyReader, but it won't be used if one of bags has msgdefs\n        # this works around that, but may be unstable\n        # https://gitlab.com/ternaris/rosbags/-/blob/master/src/rosbags/highlevel/anyreader.py?ref_type=heads#L125-140\n        if type_store is not None:\n            self.reader.typestore.register(get_typestore(type_store).fielddefs)\n\n        self.connections_lidar = [\n            x for x in self.reader.connections if x.topic == self.lidar_topic\n        ]\n        self.connections_imu = [\n            x for x in self.reader.connections if x.topic == self.imu_topic\n        ]\n\n        if len(self.connections_imu) == 0 or len(self.connections_lidar) == 0:\n            table = Table(title=\"Rosbag Connections\", highlight=True, box=box.ROUNDED)\n            table.add_column(\"Topic\", justify=\"right\")\n            table.add_column(\"MsgType\", justify=\"left\")\n            for c in self.reader.connections:\n                table.add_row(c.topic, c.msgtype)\n            Console().print(table)\n\n            if len(self.connections_imu) == 0:\n                raise ValueError(f\"Could not find topic {self.imu_topic}\")\n            if len(self.connections_lidar) == 0:\n                raise ValueError(f\"Could not find topic {self.lidar_topic}\")\n\n        self.lidar_count = sum(\n            [x.msgcount for x in self.connections_lidar if x.topic == self.lidar_topic]\n        )\n\n    def __len__(self):\n        return self.lidar_count\n\n    # ------------------------- Iterators ------------------------- #\n    def __iter__(self):\n        iterator = self.reader.messages(\n            connections=self.connections_lidar + self.connections_imu\n        )\n\n        for connection, _timestamp, rawdata in iterator:\n            msg = self.reader.deserialize(rawdata, connection.msgtype)\n            if connection.msgtype == \"sensor_msgs/msg/PointCloud2\":\n                yield self._lidar_conversion(msg)\n            elif connection.msgtype == \"sensor_msgs/msg/Imu\":\n                yield self._imu_conversion(msg)\n            else:\n                raise ValueError(f\"Unknown message type {connection.msgtype}\")\n\n    def imu_iter(self) -&gt; Iterator[ImuMeasurement]:\n        iterator = self.reader.messages(connections=self.connections_imu)\n\n        for connection, _timestamp, rawdata in iterator:\n            msg = self.reader.deserialize(rawdata, connection.msgtype)\n            yield self._imu_conversion(msg)\n\n    def lidar_iter(self) -&gt; Iterator[LidarMeasurement]:\n        iterator = self.reader.messages(connections=self.connections_lidar)\n\n        for connection, _timestamp, rawdata in iterator:\n            msg = self.reader.deserialize(rawdata, connection.msgtype)\n            yield self._lidar_conversion(msg)\n\n    # ------------------------- Convertors ------------------------- #\n    def _imu_conversion(self, msg: Any) -&gt; ImuMeasurement:\n        acc = msg.linear_acceleration\n        acc = np.array([acc.x, acc.y, acc.z])\n        gyro = msg.angular_velocity\n        gyro = np.array([gyro.x, gyro.y, gyro.z])\n\n        stamp = Stamp(sec=msg.header.stamp.sec, nsec=msg.header.stamp.nanosec)\n        return ImuMeasurement(stamp, gyro, acc)\n\n    def _lidar_conversion(self, msg: Any) -&gt; LidarMeasurement:\n        # ------------------------- Convert to our type ------------------------- #\n        fields: list[Field] = []\n        for f in msg.fields:\n            fields.append(\n                Field(name=f.name, datatype=DataType(f.datatype), offset=f.offset)\n            )\n\n        stamp = Stamp(sec=msg.header.stamp.sec, nsec=msg.header.stamp.nanosec)\n\n        # Adjust the stamp to the start of the scan\n        # Do this early so we can use the stamp for the rest of the conversion\n        match self.lidar_format.stamp:\n            case LidarStamp.Start:\n                pass\n            case LidarStamp.End:\n                stamp = stamp - self.lidar_params.delta_time()\n\n        cloud = PointCloudMetadata(\n            stamp=stamp,\n            height=msg.height,\n            width=msg.width,\n            row_step=msg.row_step,\n            point_step=msg.point_step,\n            is_bigendian=msg.is_bigendian,\n            is_dense=msg.is_dense,\n        )\n        scan: LidarMeasurement = pc2_to_evalio(cloud, fields, bytes(msg.data))  # type:ignore\n\n        # ------------------------- Handle formatting properly ------------------------- #\n        # For the ones that have been guessed, use heuristics to figure out format\n        # Will only be ran on the first cloud, afterwords it will be set\n        # row major\n        if self.lidar_format.major == LidarMajor.Guess:\n            if scan.points[0].row == scan.points[1].row:\n                self.lidar_format.major = LidarMajor.Row\n            else:\n                self.lidar_format.major = LidarMajor.Column\n        # density\n        if self.lidar_format.density == LidarDensity.Guess:\n            if (\n                len(scan.points)\n                == self.lidar_params.num_rows * self.lidar_params.num_columns\n            ):\n                self.lidar_format.density = LidarDensity.AllPoints\n            else:\n                self.lidar_format.density = LidarDensity.OnlyValidPoints\n        # point stamp\n        if self.lidar_format.point_stamp == LidarPointStamp.Guess:\n            # Leave a little fudge room just in case\n            # 2000ns = 0.002ms\n            min_time = min(scan.points, key=lambda x: x.t).t\n            if min_time &lt; Duration.from_nsec(-2000):\n                self.lidar_format.point_stamp = LidarPointStamp.End\n            else:\n                self.lidar_format.point_stamp = LidarPointStamp.Start\n\n        if (\n            self.lidar_format.major == LidarMajor.Row\n            and self.lidar_format.density == LidarDensity.OnlyValidPoints\n        ):\n            print_warning(\n                \"Loading row major scan with only valid points. Can't identify where missing points should go, putting at end of scanline\"\n            )\n\n        # Begin standardizing the pointcloud\n\n        # Make point stamps relative to the start of the scan\n        match self.lidar_format.point_stamp:\n            case LidarPointStamp.Start:\n                pass\n            case LidarPointStamp.End:\n                shift_point_stamps(scan, self.lidar_params.delta_time())\n\n        # Add column indices\n        if self.custom_col_func is not None:\n            self.custom_col_func(scan)\n        else:\n            match self.lidar_format.major:\n                case LidarMajor.Row:\n                    fill_col_row_major(scan)\n                case LidarMajor.Column:\n                    fill_col_col_major(scan)\n\n        # Reorder the points into row major with invalid points in the correct spots\n        if (\n            self.lidar_format.major == LidarMajor.Row\n            and self.lidar_format.density == LidarDensity.AllPoints\n        ):\n            pass\n        else:\n            reorder_points(\n                scan, self.lidar_params.num_rows, self.lidar_params.num_columns\n            )\n\n        return scan\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.RosbagIter.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    lidar_topic: str,\n    imu_topic: str,\n    lidar_params: LidarParams,\n    type_store: Optional[Stores] = None,\n    lidar_format: Optional[LidarFormatParams] = None,\n    custom_col_func: Optional[\n        Callable[[LidarMeasurement], None]\n    ] = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of rosbag file(s) or dir(s). If a directory is passed containing multiple bags (ros1 or ros2), all will be loaded.</p> </li> <li> <code>lidar_topic</code>               (<code>str</code>)           \u2013            <p>Name of lidar topic.</p> </li> <li> <code>imu_topic</code>               (<code>str</code>)           \u2013            <p>Name of imu topic.</p> </li> <li> <code>lidar_params</code>               (<code>LidarParams</code>)           \u2013            <p>Lidar parameters, can be gotten from lidar_params.</p> </li> <li> <code>type_store</code>               (<code>Optional[Stores]</code>, default:                   <code>None</code> )           \u2013            <p>Additional type store to be loaded into rosbags. Defaults to None.</p> </li> <li> <code>lidar_format</code>               (<code>Optional[LidarFormatParams]</code>, default:                   <code>None</code> )           \u2013            <p>Various parameters for how lidar data is stored. If not specified, most will try to be inferred. We strongly recommend setting this to ensure data is standardized properly. Defaults to None.</p> </li> <li> <code>custom_col_func</code>               (<code>Optional[Callable[[LidarMeasurement], None]]</code>, default:                   <code>None</code> )           \u2013            <p>Function to put the point cloud in row major format. Will generally not be needed, except for strange default orderings. Defaults to None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the path is a directory and no .bag files are found.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the lidar or imu topic is not found in the bag file.</p> </li> </ul> Source code in <code>python/evalio/datasets/loaders.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    lidar_topic: str,\n    imu_topic: str,\n    lidar_params: LidarParams,\n    type_store: Optional[Stores] = None,\n    # Reduce compute by telling the iterator how to format the pointcloud\n    lidar_format: Optional[LidarFormatParams] = None,\n    custom_col_func: Optional[Callable[[LidarMeasurement], None]] = None,\n):\n    \"\"\"\n    Args:\n        path (Path): Location of rosbag file(s) or dir(s). If a directory is passed containing multiple bags (ros1 or ros2), all will be loaded.\n        lidar_topic (str): Name of lidar topic.\n        imu_topic (str): Name of imu topic.\n        lidar_params (LidarParams): Lidar parameters, can be gotten from [lidar_params][evalio.datasets.Dataset.lidar_params].\n        type_store (Optional[Stores], optional): Additional type store to be loaded into rosbags. Defaults to None.\n        lidar_format (Optional[LidarFormatParams], optional): Various parameters for how lidar data is stored. If not specified, most will try to be inferred. We strongly recommend setting this to ensure data is standardized properly. Defaults to None.\n        custom_col_func (Optional[Callable[[LidarMeasurement], None]], optional): Function to put the point cloud in row major format. Will generally not be needed, except for strange default orderings. Defaults to None.\n\n    Raises:\n        FileNotFoundError: If the path is a directory and no .bag files are found.\n        ValueError: If the lidar or imu topic is not found in the bag file.\n    \"\"\"\n    self.lidar_topic = lidar_topic\n    self.imu_topic = imu_topic\n    self.lidar_params = lidar_params\n    if lidar_format is None:\n        self.lidar_format = LidarFormatParams()\n    else:\n        self.lidar_format = lidar_format\n    self.custom_col_func = custom_col_func\n\n    # Find all bags (may be either ros1 .bag files or ros2 bag/ dirs)\n    if path.is_file():\n        # Provide path is a ros1 .bag file\n        self.path = [path]\n    else:\n\n        def is_ros2_bag(d: Path) -&gt; bool:\n            return bool(list(d.glob(\"*.mcap\")) + list(d.glob(\"*.db3\")))\n\n        # Path provided is a directory may be ros2 bag/ dir or contain multiple bags\n        ros1_bag_file_list = [p for p in path.glob(\"*.bag\")]\n        ros2_bag_dir_list = [d for d in path.glob(\"*/\") if is_ros2_bag(d)]\n\n        if ros1_bag_file_list:  # path contains ros1 .bag files\n            self.path = ros1_bag_file_list\n        elif ros2_bag_dir_list:  # path contains ros2 bag/ directories\n            self.path = ros2_bag_dir_list\n        elif is_ros2_bag(path):  # path is a ros2 bag/ (contains mcap or db3 file)\n            self.path = [path]\n        else:\n            raise ValueError(\n                f\"Invalid rosbag path: {path}\\nExpected path to be one of:\\na) ros1 .bag \\nb) ros2 bag/ dir or \\nc) directory multiple a or b\"\n            )\n\n    # Open the bag file\n    self.reader = AnyReader(self.path)\n    self.reader.open()\n\n    # force load passed in type store\n    # there is a default_typestore parameter in AnyReader, but it won't be used if one of bags has msgdefs\n    # this works around that, but may be unstable\n    # https://gitlab.com/ternaris/rosbags/-/blob/master/src/rosbags/highlevel/anyreader.py?ref_type=heads#L125-140\n    if type_store is not None:\n        self.reader.typestore.register(get_typestore(type_store).fielddefs)\n\n    self.connections_lidar = [\n        x for x in self.reader.connections if x.topic == self.lidar_topic\n    ]\n    self.connections_imu = [\n        x for x in self.reader.connections if x.topic == self.imu_topic\n    ]\n\n    if len(self.connections_imu) == 0 or len(self.connections_lidar) == 0:\n        table = Table(title=\"Rosbag Connections\", highlight=True, box=box.ROUNDED)\n        table.add_column(\"Topic\", justify=\"right\")\n        table.add_column(\"MsgType\", justify=\"left\")\n        for c in self.reader.connections:\n            table.add_row(c.topic, c.msgtype)\n        Console().print(table)\n\n        if len(self.connections_imu) == 0:\n            raise ValueError(f\"Could not find topic {self.imu_topic}\")\n        if len(self.connections_lidar) == 0:\n            raise ValueError(f\"Could not find topic {self.lidar_topic}\")\n\n    self.lidar_count = sum(\n        [x.msgcount for x in self.connections_lidar if x.topic == self.lidar_topic]\n    )\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.BotanicGarden","title":"BotanicGarden","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken from a botanical garden, specifically for testing unstructured environments. Ground truth is gathered using a survey grade lidar.</p> <p>Note, there is no automatic downloader for this dataset due to being uploaded on onedrive. Data can be downloaded manually and placed in the correct folder in <code>EVALIO_DATA</code>.</p> <p>Additionally, we only include the public datasets here; more are potentially available upon request.</p> Source code in <code>python/evalio/datasets/botanic_garden.py</code> <pre><code>class BotanicGarden(Dataset):\n    \"\"\"Dataset taken from a botanical garden, specifically for testing unstructured environments. Ground truth is gathered using a survey grade lidar.\n\n    Note, there is no automatic downloader for this dataset due to being uploaded on onedrive. Data can be downloaded manually and placed in the correct folder in `EVALIO_DATA`.\n\n    Additionally, we only include the public datasets here; more are potentially available upon request.\n    \"\"\"\n\n    b1005_00 = auto()\n    b1005_01 = auto()\n    b1005_07 = auto()\n    b1006_01 = auto()\n    b1008_03 = auto()\n    b1018_00 = auto()\n    b1018_13 = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        return RosbagIter(\n            self.folder / f\"{self.seq_name[1:]}.bag\",\n            \"/velodyne_points\",\n            \"/imu/data\",\n            self.lidar_params(),\n            lidar_format=LidarFormatParams(\n                stamp=LidarStamp.End,\n                point_stamp=LidarPointStamp.End,\n                major=LidarMajor.Column,\n                density=LidarDensity.OnlyValidPoints,\n            ),\n            custom_col_func=fill_col_split_row_velodyne,\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        if self.seq_name == \"b1008_03\":\n            filename = f\"{self.seq_name[1:]}_gt_output.txt\"\n        else:\n            filename = f\"{self.seq_name[1:]}_GT_output.txt\"\n\n        return Trajectory.from_csv(\n            self.folder / filename,\n            [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n            delimiter=\" \",\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        # https://github.com/robot-pesg/BotanicGarden/blob/main/calib/extrinsics/calib_chain.yaml\n        return SE3.fromMat(\n            np.array(\n                [\n                    [\n                        0.999678872580465,\n                        0.0252865664429322,\n                        0.00150422292234868,\n                        0.0584867781527745,\n                    ],\n                    [\n                        -0.0252723438960774,\n                        0.999649431893338,\n                        -0.0078025434141585,\n                        0.00840419966766332,\n                    ],\n                    [\n                        -0.00170103929405540,\n                        0.00776298237926191,\n                        0.99996789371916,\n                        0.168915521980526,\n                    ],\n                    [0.0, 0.0, 0.0, 1.0],\n                ]\n            )\n        )\n\n    def imu_T_gt(self) -&gt; SE3:\n        # I believe ground truth is in the lidar frame\n        # https://github.com/robot-pesg/BotanicGarden/tree/main?tab=readme-ov-file#evaluation\n        return self.imu_T_lidar()\n\n    def imu_params(self) -&gt; ImuParams:\n        # Xsens Mti-680G\n        # https://github.com/robot-pesg/BotanicGarden/blob/main/calib/imu_intrinsics/xsens_imu_param.yaml\n        return ImuParams(\n            gyro=0.0002,\n            accel=0.0005,\n            gyro_bias=0.0004,\n            accel_bias=0.0002,\n            bias_init=1e-8,\n            integration=1e-8,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"Xsens\",\n            model=\"MTi-680G\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=16,\n            num_columns=1825,\n            min_range=0.1,\n            max_range=100.0,\n            brand=\"Velodyne\",\n            model=\"VLP-16\",\n        )\n\n    def files(self) -&gt; Sequence[str | Path]:\n        out = [f\"{self.seq_name[1:]}.bag\", f\"{self.seq_name[1:]}_GT_output.txt\"]\n        if self.seq_name == \"b1008_03\":\n            out[1] = f\"{self.seq_name[1:]}_gt_output.txt\"\n\n        return out\n\n    # ------------------------- misc info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://github.com/robot-pesg/BotanicGarden\"\n\n    def environment(self) -&gt; str:\n        return \"Botanic Garden\"\n\n    def vehicle(self) -&gt; str:\n        return \"ATV\"\n\n    def quick_len(self) -&gt; Optional[int]:\n        return {\n            \"b1005_00\": 5790,\n            \"b1005_01\": 4746,\n            \"b1005_07\": 5474,\n            \"b1006_01\": 7445,\n            \"b1008_03\": 6320,\n            \"b1018_00\": 1466,\n            \"b1018_13\": 2071,\n        }[self.seq_name]\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.CUMulti","title":"CUMulti","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset collected by a ground robot (AgileX - Hunter) on the University of Colorado Boulder Campus.</p> Source code in <code>python/evalio/datasets/cumulti.py</code> <pre><code>class CUMulti(Dataset):\n    \"\"\"\n    Dataset collected by a ground robot (AgileX - Hunter) on the University of Colorado Boulder Campus.\n    \"\"\"\n\n    kittredge_loop_robot1 = auto()\n    kittredge_loop_robot2 = auto()\n    kittredge_loop_robot3 = auto()\n    kittredge_loop_robot4 = auto()\n    main_campus_robot1 = auto()\n    main_campus_robot2 = auto()\n    main_campus_robot3 = auto()\n    main_campus_robot4 = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        lidar_format = LidarFormatParams(\n            stamp=LidarStamp.Start,\n            point_stamp=LidarPointStamp.Start,\n            major=LidarMajor.Row,\n            density=LidarDensity.AllPoints,\n        )\n\n        robot_name = self.seq_name.split(\"_\")[-1]\n        return RosbagIter(\n            self.folder,\n            f\"{robot_name}/ouster/points\",\n            f\"{robot_name}/imu/data\",\n            self.lidar_params(),\n            lidar_format=lidar_format,\n            type_store=Stores.ROS2_FOXY,\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        # Sequence Naming information\n        components = self.seq_name.split(\"_\")\n        robot_name = components[-1]\n        loc_name = \"_\".join(components[:2])\n        gt_file = self.folder / f\"{loc_name}_{robot_name}_ref.csv\"\n\n        # Load the Trajectory which provides solutions in the UTM frame\n        traj_utm = Trajectory.from_csv(\n            gt_file, [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"]\n        )\n\n        # Subtract out the initial position to get a local frame reference\n        init_position = traj_utm.poses[0].trans\n        return Trajectory(\n            poses=[SE3(p.rot, p.trans - init_position) for p in traj_utm.poses],\n            stamps=traj_utm.stamps,\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        # Supplied by CU-Multi Authors\n        return SE3.fromMat(\n            np.array(\n                [\n                    [-1.0, 0.0, 0.0, -0.058038],\n                    [0.0, -1.0, 0.0, 0.015573],\n                    [0.0, 0.0, 1.0, 0.049603],\n                    [0.0, 0.0, 0.0, 1.000000],\n                ]\n            )\n        )\n\n    def imu_T_gt(self) -&gt; SE3:\n        # Groundtruth provided in the IMU Frame\n        return SE3.identity()\n\n    def imu_params(self) -&gt; ImuParams:\n        # https://www.mouser.com/datasheet/2/1083/3dmgq7_gnssins_ds_0-1900596.pdf\n        return ImuParams(\n            gyro=4.363323129985824e-05,  # From 0.15 Deg / sqrt(hr)\n            accel=1.962e-4,  # From 20 micro-gravity / sqrt(Hz)\n            gyro_bias=1e-6,  # TODO (dan)\n            accel_bias=1e-6,  # TODO (dan)\n            bias_init=1e-8,\n            integration=1e-8,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"MicroStrain\",\n            model=\"3DM-GQ7\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        # Ouster OS 64 Rev 7\n        return LidarParams(\n            rate=20,\n            num_rows=64,\n            num_columns=1024,\n            min_range=1.0,\n            max_range=200.0,\n            brand=\"Ouster\",\n            model=\"OS-64 (Rev 7)\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://arpg.github.io/cumulti/\"\n\n    @classmethod\n    def dataset_name(cls) -&gt; str:\n        return \"cumulti\"\n\n    def environment(self) -&gt; str:\n        return \"CU Boulder Campus\"\n\n    def vehicle(self) -&gt; str:\n        return \"ATV\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; list[str | Path]:\n        components = self.seq_name.split(\"_\")\n        robot_name = components[-1]\n        loc_name = \"_\".join(components[:2])\n\n        return [\n            self.folder / f\"{robot_name}_{loc_name}_imu_gps\",  # IMU Bag\n            self.folder / f\"{robot_name}_{loc_name}_lidar\",  # LIDAR Bag\n            self.folder / f\"{loc_name}_{robot_name}_ref.csv\",  # Reference Solution\n        ]\n\n    def download(self):\n        # Sequence Naming information\n        components = self.seq_name.split(\"_\")\n        robot_name = components[-1]\n        loc_name = \"_\".join(components[:2])\n\n        # File Download URLS\n        globus_url = r\"https://g-ad45ee.3d2bab.75bc.data.globus.org\"\n        seq_url_base_path = (\n            f\"{globus_url}/{loc_name}/{robot_name}/{robot_name}_{loc_name}\"\n        )\n        lidar_url = f\"{seq_url_base_path}_lidar.zip\"\n        imu_url = f\"{seq_url_base_path}_imu_gps.zip\"\n\n        # Download destination zip files\n        lidar_zip_file = self.folder / f\"{robot_name}_{loc_name}_lidar.zip\"\n        imu_zip_file = self.folder / f\"{robot_name}_{loc_name}_imu_gps.zip\"\n\n        # Download all of the data\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        for zip_file, url in [(lidar_zip_file, lidar_url), (imu_zip_file, imu_url)]:\n            if not zip_file.is_file():\n                print(url)\n                _urlretrieve(url, zip_file)\n            else:\n                print(\"Archive already exists. Skipping Download.\")\n\n            # Extract from the zip only what we dont already have\n            print(\"Extracting data...\")\n            _extract_noreplace(zip_file, self.folder)\n\n        # Download the groundtruth\n        gt_url = f\"{globus_url}/{loc_name}/{robot_name}/{loc_name}_{robot_name}/\"\n        gt_file = self.folder / f\"{loc_name}_{robot_name}_ref.csv\"\n        print(gt_url)\n        if not gt_file.is_file():\n            _urlretrieve(gt_url, gt_file)\n        else:\n            print(\"Groundtruth already exists. Skipping Download.\")\n\n        # If we have extracted everything we need then remove the zip directory\n        if self.is_downloaded():\n            print(\"All data downloaded. Removing zip files...\")\n            for zip_file in [lidar_zip_file, imu_zip_file]:\n                os.remove(zip_file)\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.EnWide","title":"EnWide","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken in purposely degenerate locations such as a field, intersections, tunnels, and runways. All data comes directly from the Ouster unit.</p> <p>Note, this dataset does not have ground truth orientation, only ground truth positional values taken from a Leica MS60 Prism.</p> Source code in <code>python/evalio/datasets/enwide.py</code> <pre><code>class EnWide(Dataset):\n    \"\"\"Dataset taken in purposely degenerate locations such as a field, intersections, tunnels, and runways. All data comes directly from the Ouster unit.\n\n    Note, this dataset does not have ground truth orientation, only ground truth positional values taken from a Leica MS60 Prism.\n    \"\"\"\n\n    field_d = auto()\n    field_s = auto()\n    intersection_d = auto()\n    intersection_s = auto()\n    katzensee_d = auto()\n    katzensee_s = auto()\n    runway_d = auto()\n    runway_s = auto()\n    tunnel_d = auto()\n    tunnel_s = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        return RosbagIter(\n            self.folder,\n            \"/ouster/points\",\n            \"/ouster/imu\",\n            self.lidar_params(),\n            lidar_format=LidarFormatParams(\n                stamp=LidarStamp.Start,\n                point_stamp=LidarPointStamp.Start,\n                major=LidarMajor.Row,\n                density=LidarDensity.AllPoints,\n            ),\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        return Trajectory.from_csv(\n            self.folder / f\"gt-{self.seq_name}.csv\",\n            [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n            delimiter=\" \",\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        scale = 100\n        imu_T_sensor = SE3(\n            SO3(qx=0.0, qy=0.0, qz=0.0, qw=1.0),\n            np.array([6.253 / scale, -11.775 / scale, 7.645 / scale]),\n        )\n        lidar_T_sensor = SE3(\n            SO3(qx=0.0, qy=0.0, qz=1.0, qw=0.0),\n            np.array([0.0, 0.0, 0.3617 / scale]),\n        )\n        # TODO: Hardcode this later on\n        return imu_T_sensor * lidar_T_sensor.inverse()\n\n    def imu_T_gt(self) -&gt; SE3:\n        # TODO: Needs to be inverted?\n        return SE3(\n            SO3(qx=0.0, qy=0.0, qz=0.0, qw=1.0),\n            np.array([-0.006253, 0.011775, 0.10825]),\n        )\n\n    def imu_params(self) -&gt; ImuParams:\n        # TODO: Verify these values\n        return ImuParams(\n            gyro=0.000261799,\n            accel=0.000230,\n            gyro_bias=0.0000261799,\n            accel_bias=0.0000230,\n            bias_init=1e-7,\n            integration=1e-7,\n            gravity=np.array([0, 0, 9.81]),\n            brand=\"TDK\",\n            model=\"IAM-20680HT\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=128,\n            num_columns=1024,\n            min_range=0.0,\n            max_range=100.0,\n            brand=\"Ouster\",\n            model=\"OS0-128\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @classmethod\n    def dataset_name(cls) -&gt; str:\n        return \"enwide\"\n\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://projects.asl.ethz.ch/datasets/enwide\"\n\n    def environment(self) -&gt; str:\n        if \"tunnel\" in self.seq_name:\n            return \"Tunnel\"\n        elif \"runway\" in self.seq_name or \"intersection\" in self.seq_name:\n            return \"Planar Road\"\n        else:\n            return \"Field\"\n\n    def vehicle(self) -&gt; str:\n        return \"Handheld\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        return {\n            \"intersection_s\": [\n                \"2023-08-09-16-19-09-intersection_s.bag\",\n                \"gt-intersection_s.csv\",\n            ],\n            \"runway_s\": [\"2023-08-09-18-44-24-runway_s.bag\", \"gt-runway_s.csv\"],\n            \"katzensee_s\": [\n                \"2023-08-21-10-20-22-katzensee_s.bag\",\n                \"gt-katzensee_s.csv\",\n            ],\n            \"runway_d\": [\"2023-08-09-18-52-05-runway_d.bag\", \"gt-runway_d.csv\"],\n            \"tunnel_d\": [\"2023-08-08-17-50-31-tunnel_d.bag\", \"gt-tunnel_d.csv\"],\n            \"field_d\": [\"2023-08-09-19-25-45-field_d.bag\", \"gt-field_d.csv\"],\n            \"katzensee_d\": [\n                \"2023-08-21-10-29-20-katzensee_d.bag\",\n                \"gt-katzensee_d.csv\",\n            ],\n            \"tunnel_s\": [\"2023-08-08-17-12-37-tunnel_s.bag\", \"gt-tunnel_s.csv\"],\n            \"intersection_d\": [\n                \"2023-08-09-17-58-11-intersection_d.bag\",\n                \"gt-intersection_d.csv\",\n            ],\n            \"field_s\": [\"2023-08-09-19-05-05-field_s.bag\", \"gt-field_s.csv\"],\n        }[self.seq_name]\n\n    def download(self):\n        bag_file, gt_file = cast(list[str], self.files())\n\n        url = f\"http://robotics.ethz.ch/~asl-datasets/2024_ICRA_ENWIDE/{self.seq_name}/\"\n\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        if not (self.folder / gt_file).exists():\n            _urlretrieve(url + gt_file, self.folder / gt_file)\n        if not (self.folder / bag_file).exists():\n            _urlretrieve(url + bag_file, self.folder / bag_file)\n\n    def quick_len(self) -&gt; Optional[int]:\n        return {\n            \"field_d\": 1477,\n            \"field_s\": 1671,\n            \"intersection_d\": 1828,\n            \"intersection_s\": 1997,\n            \"katzensee_d\": 858,\n            \"katzensee_s\": 1620,\n            \"runway_d\": 1902,\n            \"runway_s\": 2238,\n            \"tunnel_d\": 1189,\n            \"tunnel_s\": 2380,\n        }[self.seq_name]\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.HeLiPR","title":"HeLiPR","text":"<p>               Bases: <code>Dataset</code></p> <p>Self-driving car dataset taken in urban environments. Ground truth is generated using filtering of an RTK-GNSS system.</p> <p>The vehicle had multiple lidar sensors mounted; we utilize the high resolution Ouster at the top of the vehicle.</p> Source code in <code>python/evalio/datasets/helipr.py</code> <pre><code>class HeLiPR(Dataset):\n    \"\"\"Self-driving car dataset taken in urban environments. Ground truth is generated using filtering of an RTK-GNSS system.\n\n    The vehicle had multiple lidar sensors mounted; we utilize the high resolution Ouster at the top of the vehicle.\n    \"\"\"\n\n    # Had to remove a couple of them due to not having imu data\n    # kaist_04 = auto()\n    kaist_05 = auto()\n    kaist_06 = auto()\n    # dcc_04 = auto()\n    dcc_05 = auto()\n    dcc_06 = auto()\n    # riverside_04 = auto()\n    riverside_05 = auto()\n    riverside_06 = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        imu_file = self.folder / \"xsens_imu.csv\"\n\n        # Load in all IMU data\n        imu_stamps = np.loadtxt(imu_file, usecols=0, dtype=np.int64, delimiter=\",\")\n        imu_stamps = [Stamp.from_nsec(x) for x in imu_stamps]\n        imu_data = np.loadtxt(imu_file, usecols=(11, 12, 13, 14, 15, 16), delimiter=\",\")\n        assert len(imu_stamps) == len(imu_data)\n        imu_data = [\n            ImuMeasurement(stamp, gyro, acc)\n            for stamp, gyro, acc in zip(imu_stamps, imu_data[:, 3:], imu_data[:, :3])\n        ]\n\n        # setup all the lidar data\n        lidar_path = self.folder / \"Ouster\"\n        lidar_files = sorted(list(lidar_path.glob(\"*\")))\n        lidar_stamps = [Stamp.from_nsec(int(x.stem)) for x in lidar_files]\n        lidar_params = self.lidar_params()\n\n        def lidar_iter():\n            for stamp, file in zip(lidar_stamps, lidar_files):\n                mm = helipr_bin_to_evalio(str(file), stamp, lidar_params)\n                yield mm\n\n        return RawDataIter(\n            lidar_iter(),\n            imu_data.__iter__(),\n            len(lidar_stamps),\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        return Trajectory.from_csv(\n            self.folder / \"Ouster_gt.txt\",\n            [\"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n            delimiter=\" \",\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        return SE3(\n            SO3.fromMat(\n                np.array(\n                    [\n                        [0.999715495593027, 0.0223448061210468, -0.00834490926264448],\n                        [-0.0224514077723064, 0.999664614804883, -0.0129070599303583],\n                        [0.00805370475188661, 0.0130907427756056, 0.999881878170293],\n                    ]\n                )\n            ),\n            np.array([-0.41696532, -0.00301141, 0.2996]),\n        )\n\n    def imu_T_gt(self) -&gt; SE3:\n        # GT is in the Ouster frame\n        return self.imu_T_lidar()\n\n    def imu_params(self) -&gt; ImuParams:\n        # Xsens MTi-300\n        # https://www.xsens.com/hubfs/Downloads/Leaflets/MTi-300.pdf\n        return ImuParams(\n            gyro=0.000174532925199,\n            accel=0.00014715,\n            gyro_bias=0.000174532925199,\n            accel_bias=0.00014715,\n            bias_init=1e-8,\n            integration=1e-8,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"Xsens\",\n            model=\"MTi-300\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=128,\n            # TODO: This seems wrong... but it's what I'm getting out of the data\n            num_columns=1025,\n            min_range=1.0,\n            max_range=200.0,\n            brand=\"Ouster\",\n            model=\"OS2-128\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://sites.google.com/view/heliprdataset/\"\n\n    @classmethod\n    def dataset_name(cls) -&gt; str:\n        return \"helipr\"\n\n    def environment(self) -&gt; str:\n        return \"Urban Driving\"\n\n    def vehicle(self) -&gt; str:\n        return \"Car\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        return [\"Ouster\", \"Ouster_gt.txt\", \"xsens_imu.csv\"]\n\n    def download(self):\n        id_gt = {\n            # \"kaist_04\": \"\",\n            \"kaist_05\": \"17S4649polOCfN0IOBCCxQ85UrdXf1jhF\",\n            \"kaist_06\": \"1GzU4gaQKL1XPtM5t4HWw2r6EvKJOWJV_\",\n            # \"dcc_04\": \"1ZG3muCWwrZrVhtOsSTUMBWdUhieBZnZy\",\n            \"dcc_05\": \"1_GrcOKatx6F0DqglW0L9vk4ENBVFs0ZV\",\n            \"dcc_06\": \"1Bxbl3T3OGrtn8Gh8BfeV8KJjwkgRtBMv\",\n            # \"riverside_04\": \"\",\n            \"riverside_05\": \"1IWj2bI7D5mPZWoh_09x0nyaM2Uf36VJM\",\n            \"riverside_06\": \"1z7i2kxQV7edKmBtJ0jTjQKlShbc7MTeJ\",\n        }[self.seq_name]\n\n        id_imu = {\n            # \"kaist_04\": \"\",\n            \"kaist_05\": \"1R0Z7Z9BAhqOSNsD1ft6vqenH644rxXk9\",\n            \"kaist_06\": \"1X-KiLi26PpJpTbZ3xupBq8I74OdXlSYU\",\n            # \"dcc_04\": \"1u5eZK1sP_Jr3XasZ7PFKFGryVLuTUpGp\",\n            \"dcc_05\": \"1X3_BJsVyaQZ7yL5t0stqr7j-G1K1sq5R\",\n            \"dcc_06\": \"1WqxElIxpXR1uXTIRTow2mZgPFooy2BBt\",\n            # \"riverside_04\": \"\",\n            \"riverside_05\": \"1mqiOrq9gJLtrZn6QZdEts4yM2rGk_xfY\",\n            \"riverside_06\": \"11EvRS44Eny6uwaT0RyfYRCxwvOPzSN4X\",\n        }[self.seq_name]\n\n        id_lidar = {\n            # \"kaist_04\": \"\",\n            \"kaist_05\": \"1FM5L17x12Lh3byp9m4h8njB-4RCP4HeZ\",\n            \"kaist_06\": \"1FgNG22gYkOTaWN5mtaXmR2RHbFYJ5ufo\",\n            # \"dcc_04\": \"1WcUkHU-kuH_g7GCSHJDrpkuJu_xm5Wfx\",\n            \"dcc_05\": \"1YqCnquttT6WXcYyHnq4pzhgEGoEjvY4p\",\n            \"dcc_06\": \"1tThqQ706gUuoV29g2l1c2vjEHbOfvKsa\",\n            # \"riverside_04\": \"\",\n            \"riverside_05\": \"1v1ZdYkNwlxXuFCpTug80pNdFfc5ZTWWG\",\n            \"riverside_06\": \"1-ll0t8goMGb0Qb86nvkerC4quJS3mzPU\",\n        }[self.seq_name]\n\n        import gdown\n\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        folder_trail = f\"{self.folder}{os.sep}\"\n        gdown.download(id=id_gt, output=folder_trail, resume=True)\n        gdown.download(id=id_imu, output=folder_trail, resume=True)\n\n        if not (self.folder / \"Ouster\").exists():\n            gdown.download(id=id_lidar, output=folder_trail, resume=True)\n            # extract the lidar data\n            print(\"Extracting lidar data...\")\n            tar_file = self.folder / \"Ouster.tar.gz\"\n            with tarfile.open(str(tar_file)) as tar:\n                tar.extractall(path=self.folder)\n            print(\"Removing tar file...\")\n            tar_file.unlink()\n\n    def quick_len(self) -&gt; Optional[int]:\n        return {\n            \"kaist_05\": 12477,\n            \"kaist_06\": 12152,\n            \"dcc_05\": 10810,\n            \"dcc_06\": 10742,\n            \"riverside_05\": 8551,\n            \"riverside_06\": 11948,\n        }[self.seq_name]\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.Hilti2022","title":"Hilti2022","text":"<p>               Bases: <code>Dataset</code></p> <p>Sequences with ground truth taken from the Hilti 2022 SLAM Challenge, mostly taken from indoors.</p> Source code in <code>python/evalio/datasets/hilti_2022.py</code> <pre><code>class Hilti2022(Dataset):\n    \"\"\"Sequences with ground truth taken from the Hilti 2022 SLAM Challenge, mostly taken from indoors.\"\"\"\n\n    construction_upper_level_1 = auto()\n    construction_upper_level_2 = auto()\n    construction_upper_level_3 = auto()\n    basement_2 = auto()\n    attic_to_upper_gallery_2 = auto()\n    corridor_lower_gallery_2 = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        bag, _ = self.files()\n        return RosbagIter(\n            self.folder / bag,\n            \"/hesai/pandar\",\n            \"/alphasense/imu\",\n            self.lidar_params(),\n            lidar_format=LidarFormatParams(\n                stamp=LidarStamp.Start,\n                point_stamp=LidarPointStamp.Start,\n                major=LidarMajor.Column,\n                density=LidarDensity.OnlyValidPoints,\n            ),\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        _, gt = self.files()\n        return Trajectory.from_csv(\n            self.folder / gt,\n            [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n            delimiter=\" \",\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        return SE3(\n            SO3(qx=0.7071068, qy=-0.7071068, qz=0.0, qw=0.0),\n            np.array([-0.001, -0.00855, 0.055]),\n        )\n\n    def imu_T_gt(self) -&gt; SE3:\n        return SE3.identity()\n\n    def imu_params(self) -&gt; ImuParams:\n        # From their kalibur config (in pdf)\n        # https://tp-public-facing.s3.eu-north-1.amazonaws.com/Challenges/2022/2022322_calibration_files.zip\n        # https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmi085-ds001.pdf\n        return ImuParams(\n            gyro=0.00019,\n            accel=0.00132435,\n            gyro_bias=0.000266,\n            accel_bias=0.0043,\n            bias_init=1e-8,\n            integration=1e-8,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"Bosch\",\n            model=\"BMI085\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=32,\n            num_columns=2000,\n            # Increase this a smidge to remove vehicle from scan\n            min_range=0.5,\n            max_range=120.0,\n            brand=\"Hesai\",\n            model=\"PandarXT-32\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://hilti-challenge.com/dataset-2022.html\"\n\n    def environment(self) -&gt; str:\n        return \"Indoor\"\n\n    def vehicle(self) -&gt; str:\n        return \"Handheld\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        filename = {\n            \"construction_upper_level_1\": \"exp04_construction_upper_level\",\n            \"construction_upper_level_2\": \"exp05_construction_upper_level_2\",\n            \"construction_upper_level_3\": \"exp06_construction_upper_level_3\",\n            \"basement_2\": \"exp14_basement_2\",\n            \"attic_to_upper_gallery_2\": \"exp16_attic_to_upper_gallery_2\",\n            \"corridor_lower_gallery_2\": \"exp18_corridor_lower_gallery_2\",\n        }[self.seq_name]\n\n        bag_file = f\"{filename}.bag\"\n        gt_file = f\"{filename}_imu.txt\"\n\n        # Extra space in these ones for some reason\n        if \"construction\" in self.seq_name:\n            gt_file = \"exp_\" + gt_file[3:]\n\n        return [bag_file, gt_file]\n\n    def download(self):\n        bag_file, gt_file = cast(list[str], self.files())\n\n        url = \"https://tp-public-facing.s3.eu-north-1.amazonaws.com/Challenges/2022/\"\n\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        if not (self.folder / gt_file).exists():\n            print(f\"Downloading {gt_file}\")\n            _urlretrieve(url + gt_file, self.folder / gt_file)\n        if not (self.folder / bag_file).exists():\n            print(f\"Downloading {bag_file}\")\n            _urlretrieve(url + bag_file, self.folder / bag_file)\n\n    def quick_len(self) -&gt; Optional[int]:\n        return {\n            \"construction_upper_level_1\": 1258,\n            \"construction_upper_level_2\": 1248,\n            \"construction_upper_level_3\": 1508,\n            \"basement_2\": 740,\n            \"attic_to_upper_gallery_2\": 2003,\n            \"corridor_lower_gallery_2\": 1094,\n        }[self.seq_name]\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.MultiCampus","title":"MultiCampus","text":"<p>               Bases: <code>Dataset</code></p> <p>Data taken from a variety of campus (KTH, NTU, TUHH) in Asia and Europe at different seasons, at day and night, and with an ATV and handheld platform.</p> <p>Ground truth was measured using a continuous optimization of lidar scans matched against a laser scanner map.</p> Source code in <code>python/evalio/datasets/multi_campus.py</code> <pre><code>class MultiCampus(Dataset):\n    \"\"\"Data taken from a variety of campus (KTH, NTU, TUHH) in Asia and Europe at different seasons, at day and night, and with an ATV and handheld platform.\n\n    Ground truth was measured using a continuous optimization of lidar scans matched against a laser scanner map.\n    \"\"\"\n\n    ntu_day_01 = auto()\n    ntu_day_02 = auto()\n    ntu_day_10 = auto()\n    ntu_night_04 = auto()\n    ntu_night_08 = auto()\n    ntu_night_13 = auto()\n    kth_day_06 = auto()\n    kth_day_09 = auto()\n    kth_day_10 = auto()\n    kth_night_01 = auto()\n    kth_night_04 = auto()\n    kth_night_05 = auto()\n    tuhh_day_02 = auto()\n    tuhh_day_03 = auto()\n    tuhh_day_04 = auto()\n    tuhh_night_07 = auto()\n    tuhh_night_08 = auto()\n    tuhh_night_09 = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        lidar_format = LidarFormatParams(\n            stamp=LidarStamp.End,\n            point_stamp=LidarPointStamp.Start,\n            major=LidarMajor.Row,\n            density=LidarDensity.AllPoints,\n        )\n\n        # The NTU sequences use the ATV platform and a VectorNav vn100 IMU\n        if \"ntu\" in self.seq_name:\n            return RosbagIter(\n                self.folder,\n                \"/os_cloud_node/points\",\n                \"/vn100/imu\",\n                self.lidar_params(),\n                lidar_format=lidar_format,\n            )\n        # The KTH and TUHH sequences use the hand-held platform and a VectorNav vn200 IMU\n        elif \"kth\" in self.seq_name or \"tuhh\" in self.seq_name:\n            return RosbagIter(\n                self.folder,\n                \"/os_cloud_node/points\",\n                \"/vn200/imu\",\n                self.lidar_params(),\n                lidar_format=lidar_format,\n            )\n        else:\n            raise ValueError(f\"Unknown sequence: {self.seq_name}\")\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        return Trajectory.from_csv(\n            self.folder / \"pose_inW.csv\",\n            [\"num\", \"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n            skip_lines=1,\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        # The NTU sequences use the ATV platform\n        # Taken from calib file at: https://mcdviral.github.io/Download.html#calibration\n        if \"ntu\" in self.seq_name:\n            return SE3.fromMat(\n                np.array(\n                    [\n                        [\n                            0.9999346552051229,\n                            0.003477624535771754,\n                            -0.010889970036688295,\n                            -0.060649229060416594,\n                        ],\n                        [\n                            0.003587143302461965,\n                            -0.9999430279821171,\n                            0.010053516443599904,\n                            -0.012837544242408117,\n                        ],\n                        [\n                            -0.010854387257665576,\n                            -0.01009192338171122,\n                            -0.999890161647627,\n                            -0.020492606896077407,\n                        ],\n                        [0.0, 0.0, 0.0, 1.0],\n                    ]\n                )\n            )\n        # The KTH and TUHH sequences use the hand-held platform\n        # Taken from calib file at: https://mcdviral.github.io/Download.html#calibration\n        elif \"kth\" in self.seq_name or \"tuhh\" in self.seq_name:\n            return SE3.fromMat(\n                np.array(\n                    [\n                        [\n                            0.9999135040741837,\n                            -0.011166365511073898,\n                            -0.006949579221822984,\n                            -0.04894521120494695,\n                        ],\n                        [\n                            -0.011356389542502144,\n                            -0.9995453006865824,\n                            -0.02793249526856565,\n                            -0.03126929060348084,\n                        ],\n                        [\n                            -0.006634514801117132,\n                            0.02800900135032654,\n                            -0.999585653686922,\n                            -0.01755515794222565,\n                        ],\n                        [0.0, 0.0, 0.0, 1.0],\n                    ]\n                )\n            )\n        else:\n            raise ValueError(f\"Unknown sequence: {self.seq_name}\")\n\n    def imu_T_gt(self) -&gt; SE3:\n        return SE3.identity()\n\n    def imu_params(self) -&gt; ImuParams:\n        # The NTU sequences use the ATV platform and a VectorNav vn100 IMU\n        # The KTH and TUHH sequences use the hand-held platform and VectorNav vn200 IMU\n        # Both the vn100 and vn200 have the same IMU specifications\n        if \"ntu\" in self.seq_name:\n            model = \"VN-100\"\n        else:\n            model = \"VN-200\"\n\n        return ImuParams(\n            gyro=0.000061087,  # VectorNav Datasheet\n            accel=0.00137,  # VectorNav Datasheet\n            gyro_bias=0.000061087,\n            accel_bias=0.000137,\n            bias_init=1e-7,\n            integration=1e-7,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"VectorNav\",\n            model=model,\n        )\n        # Note- Current estimates for imu bias should be pessimistic estimates\n\n    def lidar_params(self) -&gt; LidarParams:\n        # The NTU sequences use the ATV platform and an Ouster OS1 - 128\n        if \"ntu\" in self.seq_name:\n            return LidarParams(\n                num_rows=128,\n                num_columns=1024,\n                min_range=0.1,\n                max_range=120.0,\n                brand=\"Ouster\",\n                model=\"OS1-128\",\n            )\n        # The KTH and TUHH sequences use the hand-held platform and an Ouster OS1 - 64\n        elif \"kth\" in self.seq_name or \"tuhh\" in self.seq_name:\n            return LidarParams(\n                num_rows=64,\n                num_columns=1024,\n                min_range=0.1,\n                max_range=120.0,\n                brand=\"Ouster\",\n                model=\"OS1-64\",\n            )\n        else:\n            raise ValueError(f\"Unknown sequence: {self.seq_name}\")\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://mcdviral.github.io/\"\n\n    def environment(self) -&gt; str:\n        if \"ntu\" in self.seq_name:\n            return \"NTU Campus\"\n        elif \"kth\" in self.seq_name:\n            return \"KTH Campus\"\n        elif \"tuhh\" in self.seq_name:\n            return \"TUHH Campus\"\n        else:\n            raise ValueError(f\"Unknown sequence: {self.seq_name}\")\n\n    def vehicle(self) -&gt; str:\n        if \"ntu\" in self.seq_name:\n            return \"ATV\"\n        elif \"kth\" in self.seq_name or \"tuhh\" in self.seq_name:\n            return \"Handheld\"\n        else:\n            raise ValueError(f\"Unknown sequence: {self.seq_name}\")\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        if \"ntu\" in self.seq_name:\n            beams = 128\n            imu = \"vn100\"\n        else:\n            beams = 64\n            imu = \"vn200\"\n\n        return [\n            f\"{self.seq_name}_{imu}.bag\",\n            f\"{self.seq_name}_os1_{beams}.bag\",\n            \"pose_inW.csv\",\n        ]\n\n    def download(self):\n        ouster_url = {\n            \"ntu_day_01\": \"127Rk2jX4I95CEWK1AOZRD9AQRxRVlWjY\",\n            \"ntu_day_02\": \"1jDS84WvHCfM_L73EptXKp-BKPIPKoE0Z\",\n            \"ntu_day_10\": \"1p18Fa5SXbVcCa9BJb_Ed8Fk_NRcahkCF\",\n            \"ntu_night_04\": \"1k9olfETU3f3iq_9QenzEfjTpD56bOtaV\",\n            \"ntu_night_08\": \"1BbtBDwT3sLCHCOFfZWeVVWbG72mWq8x8\",\n            \"ntu_night_13\": \"17Fn_HRVwSEzQqXwkw0J3NnqxekUMjnYI\",\n            \"kth_day_06\": \"1DHpRSoY5ysK1h2nRwks_6Sz-QZqERiXH\",\n            \"kth_day_09\": \"1mhMpwr3NDYfUWL0dVAh_kCTTTLFen31C\",\n            \"kth_day_10\": \"1NbOHfVaCZkXPz28VwLrWLfITXYn25odh\",\n            \"kth_night_01\": \"1mbLMoTPdhUI9u-ZOYFQJOYgrcQJb3rvN\",\n            \"kth_night_04\": \"1SRMbAu1UyA4lJB4hZdmY-0mic-paGkKF\",\n            \"kth_night_05\": \"1m8DYu6y5BkolXkKqC9E8Lm77TpzpyeNR\",\n            \"tuhh_day_02\": \"1LErPETriJjLWhMBE5jvfpxoFujn0Z3cp\",\n            \"tuhh_day_03\": \"1zTU8dnYNn1WRBGY-YkzqEiofH11vryTu\",\n            \"tuhh_day_04\": \"1IFzZoEyqjboOwntyiPHTUxGcBndE2e9S\",\n            \"tuhh_night_07\": \"1y1GJkaofleWVU8ZoUByGkmXkq2lwm-k-\",\n            \"tuhh_night_08\": \"16t33lVBzbSxrtt0vFt-ztWAxiciONWTX\",\n            \"tuhh_night_09\": \"1_FsTTQe-NKvQ-1shlYNeG0uWqngA2XzC\",\n        }[self.seq_name]\n\n        imu_url = {\n            \"ntu_day_01\": \"1bBKRlzwG4v7K4mBmLAQzfwp_O6yOR0Ld\",\n            \"ntu_day_02\": \"1FHsJ1Hosn_j4m5KivJrdtECdFEj3Is0G\",\n            \"ntu_day_10\": \"14IydATXlqbJ0333iNY7H-bFDBBBYF-nC\",\n            \"ntu_night_04\": \"1dLvaCBmac-05QtPy-ZsiU6L5gY35Z_ii\",\n            \"ntu_night_08\": \"1oTUfLaQO9sUjesg6Bn3xbSZt3XgQqVRo\",\n            \"ntu_night_13\": \"1lru1JVyjfzM_QmctEzMtgD6ps8ib5xYs\",\n            \"kth_day_06\": \"1cf_dmcFAX9-5zxB8WcFVc3MaVNczEMqn\",\n            \"kth_day_09\": \"16j2Ud99lrgkNtIlPQ_OV6caqZZc-bHA-\",\n            \"kth_day_10\": \"13qyhDyrj6doa7s0cdbtF1e_Bh-erFMUv\",\n            \"kth_night_01\": \"1RMfF_DYxUkP6ImwCK039-qJpzbGKw_m7\",\n            \"kth_night_04\": \"10KIUpaJIID293P3um8OfWWiiQ1NArj2o\",\n            \"kth_night_05\": \"1_LvH-KVfBOW4ltSo8ERLEHWRb31OoAgW\",\n            \"tuhh_day_02\": \"1N3l-HskmBkta4OQVAneqnJhU29-6IeK8\",\n            \"tuhh_day_03\": \"12SJQrHjFKNUMeoNuXNh7l0gd1w--B5Vl\",\n            \"tuhh_day_04\": \"1EToB3VXrxmoyPtdL1bnlFgG-fcegAIOt\",\n            \"tuhh_night_07\": \"1Ngy1_UXOfhjhwr-BEpG6Rsh1gi1rrMho\",\n            \"tuhh_night_08\": \"1bDjyQLINKWBVOg_7Q1n1mooUfM3VifOu\",\n            \"tuhh_night_09\": \"1jVQTmFX2pnYNULU5CjbOVa6hp_7zQoez\",\n        }[self.seq_name]\n\n        gt_url = {\n            \"ntu_day_01\": \"1Pdj4_0SRES4v9WiyCVp8dYMcRvE8X3iH\",\n            \"ntu_day_02\": \"1fB-AJx6jRwEWhJ0jVLlWkc38PpKCMTNy\",\n            \"ntu_day_10\": \"11DKcJWgMFjuJlvp3Ez6bFpwtTvq42JBY\",\n            \"ntu_night_04\": \"1mF-fd-NRMOpx_2jhuJeiOnxKTGYLQFsx\",\n            \"ntu_night_08\": \"1vTnLttDiUdLr2mSxKyKmixFENwGWAEZU\",\n            \"ntu_night_13\": \"15eHWp4sfJk4inD5u3EoFjDRxWJQ6e4Dd\",\n            \"kth_day_06\": \"1ilY5Krkp9E4TtFS6WD2jrhvbIqWlxk5Z\",\n            \"kth_day_09\": \"1OBfXm4GS52vWGn8cAKe_FHng91GQqg7w\",\n            \"kth_day_10\": \"11cdWjQ5TXHD6cDBpTsMZbeKbBeDmKeLf\",\n            \"kth_night_01\": \"1zued8z-H5Qav3W2f1Gz6YU_JnzmRdedc\",\n            \"kth_night_04\": \"1G6qigMKh0aUZpbwRD0a3BdB_KI0vH0cZ\",\n            \"kth_night_05\": \"1HfSMwGyzAndgO66H2mpxT3IG_SZnCExC\",\n            \"tuhh_day_02\": \"1PXKc0wglgSxMBxqTGOFPQvJ4abeYHmFa\",\n            \"tuhh_day_03\": \"1W53_HhhNlyf8Xc185Sd171k7RXFXln0n\",\n            \"tuhh_day_04\": \"1yZJdd3EekbzoZkIH4-b7lfRa3IFSpFiO\",\n            \"tuhh_night_07\": \"1QDQflr2OLCNJZ1dNUWfULICf70VhV0bt\",\n            \"tuhh_night_08\": \"1bF-uj8gw7HkBXzvWXwtDNS-BBbEtuKrb\",\n            \"tuhh_night_09\": \"1xr5dTBydbjIhE42hNdELklruuhxgYkld\",\n        }[self.seq_name]\n\n        import gdown\n\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        folder = f\"{self.folder}{os.sep}\"\n        gdown.download(id=gt_url, output=folder, resume=True)\n        gdown.download(id=ouster_url, output=folder, resume=True)\n        gdown.download(id=imu_url, output=folder, resume=True)\n\n    def quick_len(self) -&gt; Optional[int]:\n        return {\n            \"ntu_day_01\": 6024,\n            \"ntu_day_02\": 2288,\n            \"ntu_day_10\": 3248,\n            \"ntu_night_04\": 2966,\n            \"ntu_night_08\": 4668,\n            \"ntu_night_13\": 2338,\n            \"kth_day_06\": 8911,\n            \"kth_day_09\": 7670,\n            \"kth_day_10\": 6155,\n            \"kth_night_01\": 9690,\n            \"kth_night_04\": 7465,\n            \"kth_night_05\": 6653,\n            \"tuhh_day_02\": 5004,\n            \"tuhh_day_03\": 8395,\n            \"tuhh_day_04\": 1879,\n            \"tuhh_night_07\": 4446,\n            \"tuhh_night_08\": 7091,\n            \"tuhh_night_09\": 1849,\n        }[self.seq_name]\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.NewerCollege2020","title":"NewerCollege2020","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken from outdoor Oxford Campus. Ground truth is generated using ICP matching against a laser scanner.</p> <p>Note, there have been some reports that the laser scanner and data were collected months apart, which may have caused some inaccuracies in the ground truth data.</p> <p>There are two IMUs on the handheld device, but the realsense IMU is not time-synced with the lidar data. Therefore, we utilize the Ouster IMU data instead.</p> Source code in <code>python/evalio/datasets/newer_college_2020.py</code> <pre><code>class NewerCollege2020(Dataset):\n    \"\"\"Dataset taken from outdoor Oxford Campus. Ground truth is generated using ICP matching against a laser scanner.\n\n    Note, there have been some reports that the laser scanner and data were collected months apart, which may have caused some inaccuracies in the ground truth data.\n\n    There are two IMUs on the handheld device, but the realsense IMU is not time-synced with the lidar data. Therefore, we utilize the Ouster IMU data instead.\n    \"\"\"\n\n    short_experiment = auto()\n    long_experiment = auto()\n    quad_with_dynamics = auto()\n    dynamic_spinning = auto()\n    parkland_mound = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        # Use Ouster IMU as lidar IMU since the realsense IMU is not time-synced\n        return RosbagIter(\n            self.folder,\n            \"/os1_cloud_node/points\",\n            \"/os1_cloud_node/imu\",\n            self.lidar_params(),\n            lidar_format=LidarFormatParams(\n                stamp=LidarStamp.Start,\n                point_stamp=LidarPointStamp.Start,\n                major=LidarMajor.Column,\n                density=LidarDensity.AllPoints,\n            ),\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        # For some reason bag parkland mound is different\n        if self.seq_name == \"parkland_mound\":\n            return Trajectory.from_csv(\n                self.folder / \"registered_poses.csv\",\n                [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n                delimiter=\" \",\n            )\n\n        return Trajectory.from_csv(\n            self.folder / \"registered_poses.csv\",\n            [\"sec\", \"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        return SE3(\n            SO3(qx=0.0, qy=0.0, qz=1.0, qw=0.0),\n            np.array(\n                [0.006252999883145094, -0.011775000020861626, 0.007644999772310257]\n            ),\n        )\n\n    def imu_T_gt(self) -&gt; SE3:\n        return SE3(\n            SO3(qx=0.0, qy=0.0, qz=0.38268, qw=0.92388),\n            np.array([0.035643, 0.089026, -0.021653]),\n        )\n\n    def imu_params(self) -&gt; ImuParams:\n        return ImuParams(\n            gyro=0.000261799,\n            accel=0.000230,\n            gyro_bias=0.0000261799,\n            accel_bias=0.0000230,\n            bias_init=1e-7,\n            integration=1e-7,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"TDK\",\n            model=\"ICM-20948\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=64,\n            num_columns=1024,\n            min_range=0.1,\n            max_range=120.0,\n            brand=\"Ouster\",\n            model=\"OS1-64\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://ori-drs.github.io/newer-college-dataset/stereo-cam/\"\n\n    def environment(self) -&gt; str:\n        return \"Oxford Campus\"\n\n    def vehicle(self) -&gt; str:\n        return \"Handheld\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        return {\n            \"dynamic_spinning\": [\n                \"rooster_2020-07-10-09-23-18_0.bag\",\n            ],\n            \"short_experiment\": [\n                \"rooster_2020-03-10-10-36-30_0.bag\",\n                \"rooster_2020-03-10-10-39-18_1.bag\",\n                \"rooster_2020-03-10-10-42-05_2.bag\",\n                \"rooster_2020-03-10-10-44-52_3.bag\",\n                \"rooster_2020-03-10-10-47-39_4.bag\",\n                \"rooster_2020-03-10-10-50-26_5.bag\",\n                \"rooster_2020-03-10-10-53-13_6.bag\",\n                \"rooster_2020-03-10-10-56-00_7.bag\",\n                \"rooster_2020-03-10-10-58-47_8.bag\",\n                \"rooster_2020-03-10-11-01-34_9.bag\",\n            ],\n            \"long_experiment\": [\n                \"rooster_2020-03-10-11-36-51_0.bag\",\n                \"rooster_2020-03-10-11-39-38_1.bag\",\n                \"rooster_2020-03-10-11-42-25_2.bag\",\n                \"rooster_2020-03-10-11-45-12_3.bag\",\n                \"rooster_2020-03-10-11-47-59_4.bag\",\n                \"rooster_2020-03-10-11-50-46_5.bag\",\n                \"rooster_2020-03-10-11-53-33_6.bag\",\n                \"rooster_2020-03-10-11-56-20_7.bag\",\n                \"rooster_2020-03-10-11-59-07_8.bag\",\n                \"rooster_2020-03-10-12-01-54_9.bag\",\n                \"rooster_2020-03-10-12-04-41_10.bag\",\n                \"rooster_2020-03-10-12-07-28_11.bag\",\n                \"rooster_2020-03-10-12-10-15_12.bag\",\n                \"rooster_2020-03-10-12-13-02_13.bag\",\n                \"rooster_2020-03-10-12-15-49_14.bag\",\n                \"rooster_2020-03-10-12-18-36_15.bag\",\n            ],\n            \"quad_with_dynamics\": [\n                \"rooster_2020-07-10-09-13-52_0.bag\",\n                \"rooster_2020-07-10-09-16-39_1.bag\",\n                \"rooster_2020-07-10-09-19-26_2.bag\",\n            ],\n            \"parkland_mound\": [\n                \"rooster_2020-07-10-09-31-24_0.bag\",\n                \"rooster_2020-07-10-09-34-11_1.bag\",\n                \"rooster_2020-07-10-09-36-58_2.bag\",\n            ],\n        }[self.seq_name] + [\"registered_poses.csv\"]\n\n    def download(self):\n        folder_id = {\n            \"short_experiment\": \"1WWtyU6bv4-JKwe-XuSeKEEEBhbgoFHRG\",\n            \"long_experiment\": \"1pg3jzNF59YJX_lqVf4dcYI99TyBHcJX_\",\n            \"quad_with_dynamics\": \"1ScfmWiRQ_nGy3Xj5VqRSpzkEJl5BHPQv\",\n            \"dynamic_spinning\": \"1x1f_WfkQIf5AtdRhnWblhkPLur5_5ck0\",\n            \"parkland_mound\": \"1PAywZT8T9TbKy_XJEgWXJkFvr5C6M1pS\",\n        }[self.seq_name]\n\n        gt_url = {\n            \"short_experiment\": \"11VWvHxjitd4ijARD4dJ3WjFuZ_QbInVy\",\n            \"long_experiment\": \"1fT1_MhFkCn_RWzLTzo4i-sjoKa_TbIUW\",\n            \"quad_with_dynamics\": \"1Cc7fiYUCtNL8qnvA0x-m4uQvRWQLdrWO\",\n            \"dynamic_spinning\": \"16lLgl2iqVs5qSz-N3OZv9bZWBbvAXyP3\",\n            \"parkland_mound\": \"1CMcmw9pAT1Mm-Zh-nS87i015CO-xFHwl\",\n        }[self.seq_name]\n\n        import gdown\n\n        print(f\"Downloading to {self.folder}...\")\n\n        self.folder.mkdir(parents=True, exist_ok=True)\n        gdown.download(id=gt_url, output=f\"{self.folder}{os.sep}\", resume=True)\n        gdown.download_folder(id=folder_id, output=str(self.folder), resume=True)\n\n    def quick_len(self) -&gt; Optional[int]:\n        # TODO: Missing some values here\n        return {\n            \"short_experiment\": 15302,\n            \"long_experiment\": 26560,\n        }.get(self.seq_name)\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.NewerCollege2021","title":"NewerCollege2021","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset outdoors on oxford campus with a handheld device consisting of an alphasense core and a Ouster lidar. Ground truth is captured ICP matching against a laser scanner map.</p> <p>Note there are two IMUs present; we utilize the Ouster IMU (ICM-20948)) instead of the alphasense one (Bosch BMI085). We expect the Ouster IMU to have more accurate extrinsics and the specs between the two IMUs are fairly similar.</p> Source code in <code>python/evalio/datasets/newer_college_2021.py</code> <pre><code>class NewerCollege2021(Dataset):\n    \"\"\"Dataset outdoors on oxford campus with a handheld device consisting of an alphasense core and a Ouster lidar.\n    Ground truth is captured ICP matching against a laser scanner map.\n\n    Note there are two IMUs present; we utilize the Ouster IMU (ICM-20948)) instead of the alphasense one (Bosch BMI085).\n    We expect the Ouster IMU to have more accurate extrinsics and the specs between the two IMUs are fairly similar.\n    \"\"\"\n\n    quad_easy = auto()\n    quad_medium = auto()\n    quad_hard = auto()\n    stairs = auto()\n    cloister = auto()\n    park = auto()\n    maths_easy = auto()\n    maths_medium = auto()\n    maths_hard = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        return RosbagIter(\n            self.folder,\n            \"/os_cloud_node/points\",\n            \"/os_cloud_node/imu\",\n            self.lidar_params(),\n            lidar_format=LidarFormatParams(\n                stamp=LidarStamp.Start,\n                point_stamp=LidarPointStamp.Start,\n                major=LidarMajor.Row,\n                density=LidarDensity.AllPoints,\n            ),\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        gt_file = self.files()[-1]\n        return Trajectory.from_csv(\n            self.folder / gt_file,\n            [\"sec\", \"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n        )\n\n    # ------------------------- For loading params ------------------------- #\n    def imu_T_lidar(self) -&gt; SE3:\n        return SE3(\n            SO3(qx=0.0032925, qy=-0.004627, qz=-0.0024302, qw=0.99998),\n            np.array([0.013801, -0.012207, -0.01514]),\n        )\n\n    def imu_T_gt(self) -&gt; SE3:\n        return SE3(\n            SO3(qx=0.0032925, qy=-0.004627, qz=-0.0024302, qw=0.99998),\n            np.array([0.013642, -0.011607, -0.10583]),\n        )\n\n    def imu_params(self) -&gt; ImuParams:\n        # ICM-20948\n        # https://invensense.tdk.com/wp-content/uploads/2024/03/DS-000189-ICM-20948-v1.6.pdf\n        return ImuParams(\n            gyro=0.000261799387799,\n            accel=0.0022563,\n            gyro_bias=0.0000261799387799,\n            accel_bias=0.00022563,\n            bias_init=1e-8,\n            integration=1e-8,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"TDK\",\n            model=\"ICM-20948\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=128,\n            num_columns=1024,\n            min_range=0.1,\n            max_range=50.0,\n            brand=\"Ouster\",\n            model=\"OS1-128\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://ori-drs.github.io/newer-college-dataset/multi-cam/\"\n\n    def environment(self) -&gt; str:\n        return \"Oxford Campus\"\n\n    def vehicle(self) -&gt; str:\n        return \"Handheld\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        # parse ground truth file\n        if \"maths\" in self.seq_name:\n            difficulty = self.seq_name.split(\"_\")[1]\n            gt_file = f\"gt_state_{difficulty}.csv\"\n        else:\n            name = self.seq_name.replace(\"_\", \"-\")\n            gt_file = f\"gt-nc-{name}.csv\"\n\n        return {\n            \"cloister\": [\n                \"2021-12-02-10-15-59_0-cloister.bag\",\n                \"2021-12-02-10-19-05_1-cloister.bag\",\n            ],\n            \"maths_medium\": [\n                \"2021-04-07-13-55-18-math-medium.bag\",\n            ],\n            \"quad_medium\": [\n                \"2021-07-01-11-31-35_0-quad-medium.bag\",\n            ],\n            \"maths_hard\": [\n                \"2021-04-07-13-58-54_0-math-hard.bag\",\n                \"2021-04-07-14-02-18_1-math-hard.bag\",\n            ],\n            \"quad_hard\": [\n                \"2021-07-01-11-35-14_0-quad-hard.bag\",\n            ],\n            \"quad_easy\": [\n                \"2021-07-01-10-37-38-quad-easy.bag\",\n            ],\n            \"park\": [\n                \"2021-11-30-17-09-49_0-park.bag\",\n                \"2021-11-30-17-13-13_1-park.bag\",\n                \"2021-11-30-17-16-38_2-park.bag\",\n                \"2021-11-30-17-20-07_3-park.bag\",\n                \"2021-11-30-17-23-25_4-park.bag\",\n                \"2021-11-30-17-26-36_5-park.bag\",\n                \"2021-11-30-17-30-06_6-park.bag\",\n                \"2021-11-30-17-33-19_7-park.bag\",\n            ],\n            \"maths_easy\": [\n                \"2021-04-07-13-49-03_0-math-easy.bag\",\n                \"2021-04-07-13-52-31_1-math-easy.bag\",\n            ],\n            \"stairs\": [\n                \"2021-07-01-10-40-50_0-stairs.bag\",\n            ],\n        }[self.seq_name] + [gt_file]\n\n    def download(self):\n        bag_ids = {\n            \"quad_easy\": [\"1hF2h83E1THbFAvs7wpR6ORmrscIHxKMo\"],\n            \"quad_medium\": [\"11bZfJce1MCM4G9YUTCyUifM715N7FSbO\"],\n            \"quad_hard\": [\"1ss6KPSTZ4CRS7uHAMgqnd4GQ6tKEEiZD\"],\n            \"stairs\": [\"1ql0C8el5PJs6O0x4xouqaW9n2RZy53q9\"],\n            \"cloister\": [\n                \"1zzX_ZrMkVOtpSoD2jQg6Gdrtv8-UjYbF\",\n                \"1QNFQSb81gG1_jX338vO7RQkScKGT_hf1\",\n            ],\n            \"park\": [\n                \"1KZo-gPVQTMJ4hRaiaqV3hfuVNaONScDp\",\n                \"1eGVPwFSaG0M2M7Lci6IBjKQrEf1uqtVn\",\n                \"1nhuoH0OcLbovbXkq3eW6whk6TIKk2SEu\",\n                \"1pXBE1iD9iivFFliFFNs7uvWi1zjo1S0s\",\n                \"1_eZ5i2CGL7fNHeowRd1P_sllX1nxGwGL\",\n                \"1wMCZVbB7eaSuz6u3ObSTdGbgbRFyRQ7m\",\n                \"10o1oR7guReYKiVk3nBiPrFWp1MnERTiH\",\n                \"1VpLV_WUJqr770NBjF-O-DrXb5dhXRWyM\",\n            ],\n            \"maths_easy\": [\n                \"1wRnRSni9bcBRauJEJ80sxHIaJaonrC3C\",\n                \"1ORkYwGpQNvD48WRXICDDecbweg8MxYA8\",\n            ],\n            \"maths_medium\": [\"1IOq2e8Nfx79YFauBHCgdBSW9Ur5710GD\"],\n            \"maths_hard\": [\n                \"1qD147UWPo30B9lK3gABggCOxSAU6Pop2\",\n                \"1_Mps_pCeUz3ZOc53lj6Hy_zDeJfPAqy8\",\n            ],\n        }[self.seq_name]\n\n        gt_ids = {\n            \"quad_easy\": \"1BdQiOhb_NW7VqjNtbbRAjI0JH56uKFI-\",\n            \"quad_medium\": \"18aHhzTcVzXsppmk2WpiZnJhzOfREUwYP\",\n            \"quad_hard\": \"1KMAG65pH8PsHUld-hTkFK4-SIIBqT5yP\",\n            \"stairs\": \"17q_NYxn1SLBmUq20jgljO8HSlFF9LjDs\",\n            \"cloister\": \"15I8qquSPWlySuY5_4ZBa_wL4UC7c-rQ7\",\n            \"park\": \"1AkJ7lm5x2WdS3aGhKwe1PnUn6w0rbUjf\",\n            \"maths_easy\": \"1dq1PqMODQBb4Hkn82h2Txgf5ZygS5udp\",\n            \"maths_medium\": \"1H1U3aXv2AJQ_dexTnjaHIfzYfx8xVXpS\",\n            \"maths_hard\": \"1Rb2TBKP7ISC2XzDGU68ix5lFjEB6jXeX\",\n        }[self.seq_name]\n\n        import gdown\n\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        gdown.download(id=gt_ids, output=f\"{self.folder}{os.sep}\", resume=True)\n        for bid in bag_ids:\n            gdown.download(id=bid, output=f\"{self.folder}{os.sep}\", resume=True)\n\n    def quick_len(self) -&gt; Optional[int]:\n        return {\n            \"quad_easy\": 1991,\n            \"quad_medium\": 1910,\n            \"quad_hard\": 1880,\n            \"stairs\": 1190,\n            \"cloister\": 2788,\n            \"park\": 15722,\n            \"maths_easy\": 2160,\n            \"maths_medium\": 1770,\n            \"maths_hard\": 2440,\n        }[self.seq_name]\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.OxfordSpires","title":"OxfordSpires","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken both indoors and outdoors on the Oxford campus.</p> <p>Note, we skip over a number of trajectories due to missing ground truth data.</p> <p>Additionally, some of the ground truth has poses within a few milliseconds of each other - we skip over any ground truth values within 10 milliseconds of each other.</p> Source code in <code>python/evalio/datasets/oxford_spires.py</code> <pre><code>class OxfordSpires(Dataset):\n    \"\"\"Dataset taken both indoors and outdoors on the Oxford campus.\n\n    Note, we skip over a number of trajectories due to [missing ground truth data](https://docs.google.com/document/d/1RS9QSOP4rC7BWoCD6EYUCm9uV_oMkfa3b61krn9OLG8/edit?tab=t.0).\n\n    Additionally, some of the ground truth has poses within a few milliseconds of each other - we skip over any ground truth values within 10 milliseconds of each other.\n    \"\"\"\n\n    blenheim_palace_01 = auto()\n    blenheim_palace_02 = auto()\n    blenheim_palace_05 = auto()\n    bodleian_library_02 = auto()\n    christ_church_01 = auto()\n    christ_church_02 = auto()\n    christ_church_03 = auto()\n    christ_church_05 = auto()\n    keble_college_02 = auto()\n    keble_college_03 = auto()\n    keble_college_04 = auto()\n    observatory_quarter_01 = auto()\n    observatory_quarter_02 = auto()\n\n    # ------------------------- For loading data ------------------------- #\n    def data_iter(self) -&gt; DatasetIterator:\n        return RosbagIter(\n            self.folder,\n            \"/hesai/pandar\",\n            \"/alphasense_driver_ros/imu\",\n            self.lidar_params(),\n            lidar_format=LidarFormatParams(\n                stamp=LidarStamp.Start,\n                point_stamp=LidarPointStamp.Start,\n                major=LidarMajor.Column,\n                density=LidarDensity.OnlyValidPoints,\n            ),\n        )\n\n    def ground_truth_raw(self) -&gt; Trajectory:\n        # Some of these are within a few milliseconds of each other\n        # skip over ones that are too close\n        traj = Trajectory.from_csv(\n            self.folder / \"gt-tum.txt\",\n            [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n            delimiter=\" \",\n        )\n\n        poses: list[SE3] = []\n        stamps: list[Stamp] = []\n        for i in range(1, len(traj)):\n            if traj.stamps[i] - traj.stamps[i - 1] &gt; Duration.from_sec(1e-2):\n                poses.append(traj.poses[i])\n                stamps.append(traj.stamps[i])\n\n        return Trajectory(metadata=traj.metadata, stamps=stamps, poses=poses)\n\n    # ------------------------- For loading params ------------------------- #\n    def cam_T_lidar(self) -&gt; SE3:\n        r = SO3(\n            qx=0.5023769275907106,\n            qy=0.49990425097844265,\n            qz=-0.49648618825384844,\n            qw=0.5012131556048427,\n        )\n        t = np.array([0.003242860366163889, -0.07368532755947366, -0.05485800045216396])\n        return SE3(r, t)\n\n    def cam_T_imu(self) -&gt; SE3:\n        r = SO3(\n            qx=-0.003150684959962717,\n            qy=0.7095105504964175,\n            qz=-0.7046875827967661,\n            qw=0.0005124164367280889,\n        )\n        t = np.array(\n            [-0.005000230026155717, -0.0031440163748744266, -0.07336562959794378]\n        )\n        return SE3(r, t)\n\n    def imu_T_lidar(self) -&gt; SE3:\n        return self.cam_T_imu().inverse() * self.cam_T_lidar()\n\n    def imu_T_gt(self) -&gt; SE3:\n        # Ground truth was found in the lidar frame, but is reported in the \"base frame\"\n        # We go back to the lidar frame (as this transform should be what they used as well)\n        # then use calibration to go to imu frame\n        # https://github.com/ori-drs/oxford_spires_dataset/blob/main/config/sensor.yaml\n        gt_T_lidar = SE3(\n            SO3(qx=0.0, qy=0.0, qz=1.0, qw=0.0), np.array([0.0, 0.0, 0.124])\n        )\n        return self.imu_T_lidar() * gt_T_lidar.inverse()\n\n    def imu_params(self) -&gt; ImuParams:\n        # Same one as hilti\n        # From their kalibur config (in pdf)\n        # https://tp-public-facing.s3.eu-north-1.amazonaws.com/Challenges/2022/2022322_calibration_files.zip\n        # https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmi085-ds001.pdf\n        return ImuParams(\n            gyro=0.00019,\n            accel=0.00132435,\n            gyro_bias=0.000266,\n            accel_bias=0.0043,\n            bias_init=1e-8,\n            integration=1e-8,\n            gravity=np.array([0, 0, -9.81]),\n            brand=\"Bosch\",\n            model=\"BMI085\",\n        )\n\n    def lidar_params(self) -&gt; LidarParams:\n        return LidarParams(\n            num_rows=64,\n            num_columns=1200,\n            min_range=1.0,\n            max_range=60.0,\n            brand=\"Hesai\",\n            model=\"QT-64\",\n        )\n\n    # ------------------------- dataset info ------------------------- #\n    @staticmethod\n    def url() -&gt; str:\n        return \"https://dynamic.robots.ox.ac.uk/datasets/oxford-spires/\"\n\n    def environment(self) -&gt; str:\n        if \"observatory\" in self.seq_name or \"bodleian\" in self.seq_name:\n            return \"Oxford Campus\"\n        else:\n            return \"Indoor &amp; Oxford Campus\"\n\n    def vehicle(self) -&gt; str:\n        return \"Backpack\"\n\n    # ------------------------- For downloading ------------------------- #\n    def files(self) -&gt; Sequence[str | Path]:\n        return {\n            \"christ_church_02\": [\n                \"1710754066_2024-03-18-09-27-47_0\",\n                \"1710754066_2024-03-18-09-36-49_1\",\n                \"gt-tum.txt\",\n            ],\n            \"blenheim_palace_01\": [\n                \"1710406700_2024-03-14-08-58-21_0_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"christ_church_05\": [\n                \"1710926317_2024-03-20-09-18-38_0_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"keble_college_03\": [\n                \"1710256011_2024-03-12-15-06-52_0_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"christ_church_01\": [\n                \"1710752531_2024-03-18-09-02-12_0\",\n                \"1710752531_2024-03-18-09-11-55_1\",\n                \"gt-tum.txt\",\n            ],\n            \"bodleian_library_02\": [\n                \"1716183690_2024-05-20-06-41-31_0_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"blenheim_palace_02\": [\n                \"1710407340_2024-03-14-09-09-01_0_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"keble_college_04\": [\n                \"1710256650_2024-03-12-15-17-31_0\",\n                \"1710256650_2024-03-12-15-26-05_1\",\n                \"gt-tum.txt\",\n            ],\n            \"observatory_quarter_01\": [\n                \"1710338090_2024-03-13-13-54-51_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"christ_church_03\": [\n                \"1710755015_2024-03-18-09-43-36_0_blurred_filtered.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"blenheim_palace_05\": [\n                \"1710410169_2024-03-14-09-56-09_0_blurred_filtered.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"observatory_quarter_02\": [\n                \"1710338490_2024-03-13-14-01-30_blurred_filtered.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n            \"keble_college_02\": [\n                \"1710255615_2024-03-12-15-00-16_0_blurred_filtered_compressed.db3\",\n                \"gt-tum.txt\",\n                \"metadata.yaml\",\n            ],\n        }[self.seq_name]\n\n    def download(self):\n        folder_id = {\n            \"blenheim_palace_01\": \"1sQZhbdWZqyR0fLStesW2sJYuvIW9xyCD\",\n            \"blenheim_palace_02\": \"1vaU7pn0cxbrBbJk1XKr9hOeeF7Zv00K9\",\n            \"blenheim_palace_05\": \"1CZpiSX84g4391D-87E6AMlZI4ky1TG7p\",\n            \"bodleian_library_02\": \"1koKUZrZ3dPazy2qwguPeFqla04V7-opp\",\n            # This one is split into two... figure out how to handle\n            \"christ_church_01\": \"1yd9jl1o4AEacKaYXCHV-AzV-FZTfRm6r\",\n            # This one is split into two... figure out how to handle\n            \"christ_church_02\": \"1f41VoG6mMAvpLxKciqGLhtOuj5iUK_3r\",\n            \"christ_church_03\": \"14YTkMnxEWnE-iyrk30iu0I39QG-smREF\",\n            \"christ_church_05\": \"1EDyyuFJ-KnLUv-S5IFv7OInNwPEFSHwl\",\n            \"keble_college_02\": \"1qAocPo1_h8B2u-LdQoD2td49RJlD-1IW\",\n            \"keble_college_03\": \"1u-QIvxQvjRXtt0k3vXYdB59XZQ61Khj9\",\n            # This one is split into two... figure out how to handle\n            \"keble_college_04\": \"1VJB8oIAoVVIhGCnbXKYz_uHfiNkwn9_i\",\n            \"observatory_quarter_01\": \"1Wys3blrdfPVn-EFsXn_a0_0ngvzgSiFb\",\n            \"observatory_quarter_02\": \"109uXFhqzYhn2bHv_37aQF7xPrJhOOu-_\",\n        }[self.seq_name]\n\n        gt_url = {\n            \"blenheim_palace_01\": \"16et7vJhZ15yOCNYYU-i8HVOXemJM3puz\",\n            \"blenheim_palace_02\": \"191MBEJuABCbb14LJhnJuvq4_ULqqbeQU\",\n            \"blenheim_palace_05\": \"1jWYpiX4eUz1By1XN1g22ktzb-BCMyE7q\",\n            \"bodleian_library_02\": \"1_EP7H_uO0XNhIKaFXB4nro8ymhpWB2qg\",\n            \"christ_church_01\": \"1qXlfhf_0Jr6daeM3v9qmmhC-5yEI6TB5\",\n            \"christ_church_02\": \"19vyhMivn4I1u-ZkLlIpoa7Nc3sdWNOU1\",\n            \"christ_church_03\": \"13LbReIW7mJd6jMVBI6IcSRPWvpG6WP9c\",\n            \"christ_church_05\": \"1Nxbjmwudu2b02Z2zWkJYO1I9rDPLe2Uf\",\n            \"keble_college_02\": \"1hgNbsqIx8L0vM4rnPSX155sxxiIsDnJC\",\n            \"keble_college_03\": \"1ybkRnb-wu4VMEqa37RUAHbUv2i-4UluB\",\n            \"keble_college_04\": \"1iaGvgpDN-3CrwPPZzQjwAveXQOyQnAU4\",\n            \"observatory_quarter_01\": \"1IOqvzepLesYecizYJh6JU0lJZu2WeW68\",\n            \"observatory_quarter_02\": \"1iPQQD2zijlCf8a6J8YW5QBlVE2KsYRdZ\",\n        }[self.seq_name]\n\n        import gdown\n\n        print(f\"Downloading to {self.folder}...\")\n        self.folder.mkdir(parents=True, exist_ok=True)\n        gdown.download(id=gt_url, output=f\"{self.folder}{os.sep}\", resume=True)\n        gdown.download_folder(id=folder_id, output=str(self.folder), resume=True)\n\n    def quick_len(self) -&gt; Optional[int]:\n        # TODO: Missing some of the sequences here, need to figure out multi-folder mcap files\n        return {\n            \"blenheim_palace_01\": 4052,\n            \"blenheim_palace_02\": 3674,\n            \"blenheim_palace_05\": 3401,\n            \"bodleian_library_02\": 5007,\n            \"christ_church_03\": 3123,\n            \"christ_church_05\": 8007,\n            \"keble_college_02\": 3007,\n            \"keble_college_03\": 2867,\n            \"observatory_quarter_01\": 2894,\n            \"observatory_quarter_02\": 2755,\n        }.get(self.seq_name)\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.DatasetNotFound","title":"DatasetNotFound","text":"<p>               Bases: <code>CustomException</code></p> <p>Exception raised when a dataset is not found.</p> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>class DatasetNotFound(CustomException):\n    \"\"\"Exception raised when a dataset is not found.\"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(f\"Dataset '{name}' not found\")\n        self.name = name\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.SequenceNotFound","title":"SequenceNotFound","text":"<p>               Bases: <code>CustomException</code></p> <p>Exception raised when a sequence is not found.</p> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>class SequenceNotFound(CustomException):\n    \"\"\"Exception raised when a sequence is not found.\"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(f\"Sequence '{name}' not found\")\n        self.name = name\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.get_data_dir","title":"get_data_dir","text":"<pre><code>get_data_dir() -&gt; Path\n</code></pre> <p>Get the global data directory. This is where downloaded data is stored.</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Directory where datasets are stored.</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def get_data_dir() -&gt; Path:\n    \"\"\"Get the global data directory. This is where downloaded data is stored.\n\n    Returns:\n        Directory where datasets are stored.\n    \"\"\"\n    global _DATA_DIR\n    return _DATA_DIR\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.set_data_dir","title":"set_data_dir","text":"<pre><code>set_data_dir(directory: Path)\n</code></pre> <p>Set the global location where datasets are stored. This will be used to store the downloaded data.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path</code>)           \u2013            <p>Directory</p> </li> </ul> Source code in <code>python/evalio/datasets/base.py</code> <pre><code>def set_data_dir(directory: Path):\n    \"\"\"Set the global location where datasets are stored. This will be used to store the downloaded data.\n\n    Args:\n        directory (Path): Directory\n    \"\"\"\n    global _DATA_DIR, _WARNED\n    _DATA_DIR = directory\n    _WARNED = True\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.all_datasets","title":"all_datasets","text":"<pre><code>all_datasets() -&gt; dict[str, type[Dataset]]\n</code></pre> <p>Get all registered datasets.</p> <p>Returns:</p> <ul> <li> <code>dict[str, type[Dataset]]</code>           \u2013            <p>A dictionary mapping dataset names to their classes.</p> </li> </ul> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>def all_datasets() -&gt; dict[str, type[Dataset]]:\n    \"\"\"Get all registered datasets.\n\n    Returns:\n        A dictionary mapping dataset names to their classes.\n    \"\"\"\n    global _DATASETS\n    return {d.dataset_name(): d for d in _DATASETS}\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.get_dataset","title":"get_dataset","text":"<pre><code>get_dataset(name: str) -&gt; type[Dataset] | DatasetNotFound\n</code></pre> <p>Get a registered dataset by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the dataset to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Dataset] | DatasetNotFound</code>           \u2013            <p>The dataset class if found, or a DatasetNotFound error.</p> </li> </ul> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>def get_dataset(name: str) -&gt; type[Dataset] | DatasetNotFound:\n    \"\"\"Get a registered dataset by name.\n\n    Args:\n        name (str): The name of the dataset to retrieve.\n\n    Returns:\n        The dataset class if found, or a DatasetNotFound error.\n    \"\"\"\n    return all_datasets().get(name, DatasetNotFound(name))\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.all_sequences","title":"all_sequences","text":"<pre><code>all_sequences() -&gt; dict[str, Dataset]\n</code></pre> <p>Get all sequences from all registered datasets.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Dataset]</code>           \u2013            <p>A dictionary mapping sequence names to their dataset classes.</p> </li> </ul> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>def all_sequences() -&gt; dict[str, Dataset]:\n    \"\"\"Get all sequences from all registered datasets.\n\n    Returns:\n        A dictionary mapping sequence names to their dataset classes.\n    \"\"\"\n    return {\n        seq.full_name: seq for d in all_datasets().values() for seq in d.sequences()\n    }\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.get_sequence","title":"get_sequence","text":"<pre><code>get_sequence(name: str) -&gt; Dataset | SequenceNotFound\n</code></pre> <p>Get a registered sequence by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the sequence to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dataset | SequenceNotFound</code>           \u2013            <p>The dataset object if found, or a SequenceNotFound error.</p> </li> </ul> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>def get_sequence(name: str) -&gt; Dataset | SequenceNotFound:\n    \"\"\"Get a registered sequence by name.\n\n    Args:\n        name (str): The name of the sequence to retrieve.\n\n    Returns:\n        The dataset object if found, or a SequenceNotFound error.\n    \"\"\"\n    return all_sequences().get(name, SequenceNotFound(name))\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.register_dataset","title":"register_dataset","text":"<pre><code>register_dataset(\n    dataset: Optional[type[Dataset]] = None,\n    module: Optional[ModuleType | str] = None,\n) -&gt; int | ImportError\n</code></pre> <p>Register a dataset.</p> <p>Parameters:</p> <ul> <li> <code>dataset</code>               (<code>Optional[type[Dataset]]</code>, default:                   <code>None</code> )           \u2013            <p>The dataset class to register. Defaults to None.</p> </li> <li> <code>module</code>               (<code>Optional[ModuleType | str]</code>, default:                   <code>None</code> )           \u2013            <p>The module containing datasets to register. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | ImportError</code>           \u2013            <p>The number of datasets registered or an ImportError.</p> </li> </ul> Source code in <code>python/evalio/datasets/parser.py</code> <pre><code>def register_dataset(\n    dataset: Optional[type[Dataset]] = None,\n    module: Optional[ModuleType | str] = None,\n) -&gt; int | ImportError:\n    \"\"\"Register a dataset.\n\n    Args:\n        dataset (Optional[type[Dataset]], optional): The dataset class to register. Defaults to None.\n        module (Optional[ModuleType  |  str], optional): The module containing datasets to register. Defaults to None.\n\n    Returns:\n        The number of datasets registered or an ImportError.\n    \"\"\"\n    global _DATASETS\n\n    total = 0\n    if module is not None:\n        if isinstance(module, str):\n            try:\n                module = importlib.import_module(module)\n            except ImportError as e:\n                return e\n\n        new_ds = _search_module(module)\n        _DATASETS.update(new_ds)\n        total += len(new_ds)\n\n    if dataset is not None and _is_dataset(dataset):\n        _DATASETS.add(dataset)\n        total += 1\n\n    return total\n</code></pre>"},{"location":"ref/pipelines/","title":"evalio.pipelines","text":"<p>For more information about the pipelines included in evalio, see the included pipelines section.</p> <p>Classes:</p> <ul> <li> <code>Pipeline</code>           \u2013            <p>Base class for all pipelines. This class defines the interface for interacting with pipelines, and is intended to be subclassed by specific implementations.</p> </li> <li> <code>CTICP</code>           \u2013            <p>CT-ICP LiDAR-only pipeline performs continuous-time ICP over a small window of scans to perform more accurate dewarping performance. This is the version based on the 2022-ICRA paper.</p> </li> <li> <code>KissICP</code>           \u2013            <p>KissICP LiDAR-only pipeline for point cloud registration. KissICP is designed to be simple and easy to use, while still providing good performance with minimal parameter tuning required across datasets.</p> </li> <li> <code>GenZICP</code>           \u2013            <p>Genz-ICP LiDAR-only pipeline is an extension of KissICP that additionally estimates normals in the local submap voxel map for increased robustness. It also includes a novel weighting scheme for weighting point-to-plane and point-to-point correspondences.</p> </li> <li> <code>LOAM</code>           \u2013            <p>Lidar Odometry and Mapping (LOAM) pipeline. LOAM is a baseline lidar-only odometry method that pioneered feature-based ICP. Our implementation permits both scan-to-scan or scan-to-map matching.</p> </li> <li> <code>LioSAM</code>           \u2013            <p>Lidar-Inertial Smoothing and Mapping (LioSAM) pipeline. LioSAM is an extension of LOAM (=&gt; uses planar and edge features) that additionally utilizes an IMU for initializing ICP steps and for dewarping points</p> </li> <li> <code>MadICP</code>           \u2013            <p>MAD-ICP LiDAR-only pipeline is an extension of KissICP that utilizes a novel kd-tree representation that implicitly computes normals to perform point-to-plane registration.</p> </li> <li> <code>PipelineNotFound</code>           \u2013            <p>Raised when a pipeline is not found in the registry.</p> </li> <li> <code>UnusedPipelineParam</code>           \u2013            <p>Raised when a parameter is not used in the pipeline.</p> </li> <li> <code>InvalidPipelineParamType</code>           \u2013            <p>Raised when a parameter has an invalid type.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>all_pipelines</code>             \u2013              <p>Get all registered pipelines.</p> </li> <li> <code>get_pipeline</code>             \u2013              <p>Get a pipeline class by its name.</p> </li> <li> <code>register_pipeline</code>             \u2013              <p>Add a pipeline or a module containing pipelines to the registry.</p> </li> <li> <code>validate_params</code>             \u2013              <p>Validate the parameters for a given pipeline.</p> </li> </ul>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline","title":"Pipeline","text":"<p>Base class for all pipelines. This class defines the interface for interacting with pipelines, and is intended to be subclassed by specific implementations.</p> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Construct a new pipeline.</p> </li> <li> <code>add_imu</code>             \u2013              <p>Register an IMU measurement.</p> </li> <li> <code>add_lidar</code>             \u2013              <p>Register a LiDAR measurement.</p> </li> <li> <code>default_params</code>             \u2013              <p>Default parameters for the pipeline.</p> </li> <li> <code>initialize</code>             \u2013              <p>Initialize the pipeline. Must be called after constructing the object and before setting parameters.</p> </li> <li> <code>map</code>             \u2013              <p>Map of the environment.</p> </li> <li> <code>name</code>             \u2013              <p>Name of the pipeline.</p> </li> <li> <code>pose</code>             \u2013              <p>Most recent pose estimate.</p> </li> <li> <code>set_imu_T_lidar</code>             \u2013              <p>Set the transformation from IMU to LiDAR frame.</p> </li> <li> <code>set_imu_params</code>             \u2013              <p>Set IMU parameters for the pipeline.</p> </li> <li> <code>set_lidar_params</code>             \u2013              <p>Set LiDAR parameters for the pipeline.</p> </li> <li> <code>set_params</code>             \u2013              <p>Set parameters for the pipeline. This will override any default parameters.</p> </li> <li> <code>url</code>             \u2013              <p>URL for more information about the pipeline.</p> </li> <li> <code>version</code>             \u2013              <p>Version of the pipeline.</p> </li> </ul> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class Pipeline:\n    \"\"\"\n    Base class for all pipelines. This class defines the interface for interacting with pipelines, and is intended to be subclassed by specific implementations.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Construct a new pipeline.\"\"\"\n\n    @staticmethod\n    def name() -&gt; str:\n        \"\"\"Name of the pipeline.\"\"\"\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]:\n        \"\"\"Default parameters for the pipeline.\"\"\"\n\n    @staticmethod\n    def url() -&gt; str:\n        \"\"\"URL for more information about the pipeline.\"\"\"\n\n    @staticmethod\n    def version() -&gt; str:\n        \"\"\"Version of the pipeline.\"\"\"\n\n    def pose(self) -&gt; evalio._cpp.types.SE3:\n        \"\"\"Most recent pose estimate.\"\"\"\n\n    def map(self) -&gt; dict[str, list[evalio._cpp.types.Point]]:\n        \"\"\"Map of the environment.\"\"\"\n\n    def initialize(self) -&gt; None:\n        \"\"\"\n        Initialize the pipeline. Must be called after constructing the object and before setting parameters.\n        \"\"\"\n\n    def add_imu(self, mm: evalio._cpp.types.ImuMeasurement) -&gt; None:\n        \"\"\"Register an IMU measurement.\"\"\"\n\n    def add_lidar(self, mm: evalio._cpp.types.LidarMeasurement) -&gt; dict[str, list[evalio._cpp.types.Point]]:\n        \"\"\"Register a LiDAR measurement.\"\"\"\n\n    def set_params(self, params: Mapping[str, bool | int | float | str]) -&gt; dict[str, bool | int | float | str]:\n        \"\"\"\n        Set parameters for the pipeline. This will override any default parameters.\n        \"\"\"\n\n    def set_imu_params(self, params: evalio._cpp.types.ImuParams) -&gt; None:\n        \"\"\"Set IMU parameters for the pipeline.\"\"\"\n\n    def set_lidar_params(self, params: evalio._cpp.types.LidarParams) -&gt; None:\n        \"\"\"Set LiDAR parameters for the pipeline.\"\"\"\n\n    def set_imu_T_lidar(self, T: evalio._cpp.types.SE3) -&gt; None:\n        \"\"\"Set the transformation from IMU to LiDAR frame.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Construct a new pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Construct a new pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.add_imu","title":"add_imu","text":"<pre><code>add_imu(mm: ImuMeasurement) -&gt; None\n</code></pre> <p>Register an IMU measurement.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def add_imu(self, mm: evalio._cpp.types.ImuMeasurement) -&gt; None:\n    \"\"\"Register an IMU measurement.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.add_lidar","title":"add_lidar","text":"<pre><code>add_lidar(mm: LidarMeasurement) -&gt; dict[str, list[Point]]\n</code></pre> <p>Register a LiDAR measurement.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def add_lidar(self, mm: evalio._cpp.types.LidarMeasurement) -&gt; dict[str, list[evalio._cpp.types.Point]]:\n    \"\"\"Register a LiDAR measurement.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.default_params","title":"default_params  <code>staticmethod</code>","text":"<pre><code>default_params() -&gt; dict[str, bool | int | float | str]\n</code></pre> <p>Default parameters for the pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>@staticmethod\ndef default_params() -&gt; dict[str, bool | int | float | str]:\n    \"\"\"Default parameters for the pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; None\n</code></pre> <p>Initialize the pipeline. Must be called after constructing the object and before setting parameters.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the pipeline. Must be called after constructing the object and before setting parameters.\n    \"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.map","title":"map","text":"<pre><code>map() -&gt; dict[str, list[Point]]\n</code></pre> <p>Map of the environment.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def map(self) -&gt; dict[str, list[evalio._cpp.types.Point]]:\n    \"\"\"Map of the environment.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.name","title":"name  <code>staticmethod</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Name of the pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>@staticmethod\ndef name() -&gt; str:\n    \"\"\"Name of the pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.pose","title":"pose","text":"<pre><code>pose() -&gt; SE3\n</code></pre> <p>Most recent pose estimate.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def pose(self) -&gt; evalio._cpp.types.SE3:\n    \"\"\"Most recent pose estimate.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_imu_T_lidar","title":"set_imu_T_lidar","text":"<pre><code>set_imu_T_lidar(T: SE3) -&gt; None\n</code></pre> <p>Set the transformation from IMU to LiDAR frame.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def set_imu_T_lidar(self, T: evalio._cpp.types.SE3) -&gt; None:\n    \"\"\"Set the transformation from IMU to LiDAR frame.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_imu_params","title":"set_imu_params","text":"<pre><code>set_imu_params(params: ImuParams) -&gt; None\n</code></pre> <p>Set IMU parameters for the pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def set_imu_params(self, params: evalio._cpp.types.ImuParams) -&gt; None:\n    \"\"\"Set IMU parameters for the pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_lidar_params","title":"set_lidar_params","text":"<pre><code>set_lidar_params(params: LidarParams) -&gt; None\n</code></pre> <p>Set LiDAR parameters for the pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def set_lidar_params(self, params: evalio._cpp.types.LidarParams) -&gt; None:\n    \"\"\"Set LiDAR parameters for the pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_params","title":"set_params","text":"<pre><code>set_params(\n    params: Mapping[str, bool | int | float | str],\n) -&gt; dict[str, bool | int | float | str]\n</code></pre> <p>Set parameters for the pipeline. This will override any default parameters.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>def set_params(self, params: Mapping[str, bool | int | float | str]) -&gt; dict[str, bool | int | float | str]:\n    \"\"\"\n    Set parameters for the pipeline. This will override any default parameters.\n    \"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.url","title":"url  <code>staticmethod</code>","text":"<pre><code>url() -&gt; str\n</code></pre> <p>URL for more information about the pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>@staticmethod\ndef url() -&gt; str:\n    \"\"\"URL for more information about the pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Version of the pipeline.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>@staticmethod\ndef version() -&gt; str:\n    \"\"\"Version of the pipeline.\"\"\"\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.CTICP","title":"CTICP","text":"<p>               Bases: <code>Pipeline</code></p> <p>CT-ICP LiDAR-only pipeline performs continuous-time ICP over a small window of scans to perform more accurate dewarping performance. This is the version based on the 2022-ICRA paper.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class CTICP(Pipeline):\n    \"\"\"\n    CT-ICP LiDAR-only pipeline performs continuous-time ICP over a small window of scans to perform more accurate dewarping performance. This is the version based on the 2022-ICRA paper.\n    \"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    @staticmethod\n    def name() -&gt; str: ...\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    @staticmethod\n    def version() -&gt; str: ...\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.KissICP","title":"KissICP","text":"<p>               Bases: <code>Pipeline</code></p> <p>KissICP LiDAR-only pipeline for point cloud registration. KissICP is designed to be simple and easy to use, while still providing good performance with minimal parameter tuning required across datasets.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class KissICP(Pipeline):\n    \"\"\"\n    KissICP LiDAR-only pipeline for point cloud registration. KissICP is designed to be simple and easy to use, while still providing good performance with minimal parameter tuning required across datasets.\n    \"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    @staticmethod\n    def name() -&gt; str: ...\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    @staticmethod\n    def version() -&gt; str: ...\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.GenZICP","title":"GenZICP","text":"<p>               Bases: <code>Pipeline</code></p> <p>Genz-ICP LiDAR-only pipeline is an extension of KissICP that additionally estimates normals in the local submap voxel map for increased robustness. It also includes a novel weighting scheme for weighting point-to-plane and point-to-point correspondences.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class GenZICP(Pipeline):\n    \"\"\"\n    Genz-ICP LiDAR-only pipeline is an extension of KissICP that additionally estimates normals in the local submap voxel map for increased robustness. It also includes a novel weighting scheme for weighting point-to-plane and point-to-point correspondences.\n    \"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    @staticmethod\n    def name() -&gt; str: ...\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    @staticmethod\n    def version() -&gt; str: ...\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.LOAM","title":"LOAM","text":"<p>               Bases: <code>Pipeline</code></p> <p>Lidar Odometry and Mapping (LOAM) pipeline. LOAM is a baseline lidar-only odometry method that pioneered feature-based ICP. Our implementation permits both scan-to-scan or scan-to-map matching.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class LOAM(Pipeline):\n    \"\"\"\n    Lidar Odometry and Mapping (LOAM) pipeline. LOAM is a baseline lidar-only odometry method that pioneered feature-based ICP. Our implementation permits both scan-to-scan or scan-to-map matching.\n    \"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    @staticmethod\n    def name() -&gt; str: ...\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    @staticmethod\n    def version() -&gt; str: ...\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.LioSAM","title":"LioSAM","text":"<p>               Bases: <code>Pipeline</code></p> <p>Lidar-Inertial Smoothing and Mapping (LioSAM) pipeline. LioSAM is an extension of LOAM (=&gt; uses planar and edge features) that additionally utilizes an IMU for initializing ICP steps and for dewarping points</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class LioSAM(Pipeline):\n    \"\"\"\n    Lidar-Inertial Smoothing and Mapping (LioSAM) pipeline. LioSAM is an extension of LOAM (=&gt; uses planar and edge features) that additionally utilizes an IMU for initializing ICP steps and for dewarping points\n    \"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    @staticmethod\n    def name() -&gt; str: ...\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    @staticmethod\n    def version() -&gt; str: ...\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.MadICP","title":"MadICP","text":"<p>               Bases: <code>Pipeline</code></p> <p>MAD-ICP LiDAR-only pipeline is an extension of KissICP that utilizes a novel kd-tree representation that implicitly computes normals to perform point-to-plane registration.</p> Source code in <code>python/evalio/_cpp/pipelines.pyi</code> <pre><code>class MadICP(Pipeline):\n    \"\"\"\n    MAD-ICP LiDAR-only pipeline is an extension of KissICP that utilizes a novel kd-tree representation that implicitly computes normals to perform point-to-plane registration.\n    \"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    @staticmethod\n    def name() -&gt; str: ...\n\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    @staticmethod\n    def version() -&gt; str: ...\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.PipelineNotFound","title":"PipelineNotFound","text":"<p>               Bases: <code>CustomException</code></p> <p>Raised when a pipeline is not found in the registry.</p> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>class PipelineNotFound(CustomException):\n    \"\"\"Raised when a pipeline is not found in the registry.\"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(f\"Pipeline '{name}' not found\")\n        self.name = name\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.UnusedPipelineParam","title":"UnusedPipelineParam","text":"<p>               Bases: <code>CustomException</code></p> <p>Raised when a parameter is not used in the pipeline.</p> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>class UnusedPipelineParam(CustomException):\n    \"\"\"Raised when a parameter is not used in the pipeline.\"\"\"\n\n    def __init__(self, param: str, pipeline: str):\n        super().__init__(f\"Parameter '{param}' is not used in pipeline '{pipeline}'\")\n        self.param = param\n        self.pipeline = pipeline\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.InvalidPipelineParamType","title":"InvalidPipelineParamType","text":"<p>               Bases: <code>CustomException</code></p> <p>Raised when a parameter has an invalid type.</p> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>class InvalidPipelineParamType(CustomException):\n    \"\"\"Raised when a parameter has an invalid type.\"\"\"\n\n    def __init__(self, param: str, expected_type: type, actual_type: type):\n        super().__init__(\n            f\"Parameter '{param}' has invalid type. Expected '{expected_type.__name__}', got '{actual_type.__name__}'\"\n        )\n        self.param = param\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.all_pipelines","title":"all_pipelines","text":"<pre><code>all_pipelines() -&gt; dict[str, type[Pipeline]]\n</code></pre> <p>Get all registered pipelines.</p> <p>Returns:</p> <ul> <li> <code>dict[str, type[Pipeline]]</code>           \u2013            <p>A dictionary mapping pipeline names to their classes.</p> </li> </ul> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>def all_pipelines() -&gt; dict[str, type[Pipeline]]:\n    \"\"\"Get all registered pipelines.\n\n    Returns:\n        A dictionary mapping pipeline names to their classes.\n    \"\"\"\n    global _PIPELINES\n    return {p.name(): p for p in _PIPELINES}\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.get_pipeline","title":"get_pipeline","text":"<pre><code>get_pipeline(\n    name: str,\n) -&gt; type[Pipeline] | PipelineNotFound\n</code></pre> <p>Get a pipeline class by its name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the pipeline.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type[Pipeline] | PipelineNotFound</code>           \u2013            <p>The pipeline class if found, otherwise a PipelineNotFound error.</p> </li> </ul> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>def get_pipeline(name: str) -&gt; type[Pipeline] | PipelineNotFound:\n    \"\"\"Get a pipeline class by its name.\n\n    Args:\n        name (str): The name of the pipeline.\n\n    Returns:\n        The pipeline class if found, otherwise a PipelineNotFound error.\n    \"\"\"\n    return all_pipelines().get(name, PipelineNotFound(name))\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.register_pipeline","title":"register_pipeline","text":"<pre><code>register_pipeline(\n    pipeline: Optional[type[Pipeline]] = None,\n    module: Optional[ModuleType | str] = None,\n) -&gt; int | ImportError\n</code></pre> <p>Add a pipeline or a module containing pipelines to the registry.</p> <p>Parameters:</p> <ul> <li> <code>pipeline</code>               (<code>Optional[type[Pipeline]]</code>, default:                   <code>None</code> )           \u2013            <p>A specific pipeline class to add. Defaults to None.</p> </li> <li> <code>module</code>               (<code>Optional[ModuleType | str]</code>, default:                   <code>None</code> )           \u2013            <p>The module to search for pipelines. Defaults to None.</p> </li> </ul> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>def register_pipeline(\n    pipeline: Optional[type[Pipeline]] = None,\n    module: Optional[ModuleType | str] = None,\n) -&gt; int | ImportError:\n    \"\"\"Add a pipeline or a module containing pipelines to the registry.\n\n    Args:\n        pipeline (Optional[type[Pipeline]], optional): A specific pipeline class to add. Defaults to None.\n        module (Optional[ModuleType  |  str], optional): The module to search for pipelines. Defaults to None.\n    \"\"\"\n    global _PIPELINES\n\n    total = 0\n    if module is not None:\n        if isinstance(module, str):\n            try:\n                module = importlib.import_module(module)\n            except ImportError as e:\n                return e\n\n        new_pipes = _search_module(module)\n        _PIPELINES.update(new_pipes)\n        total += len(new_pipes)\n\n    if pipeline is not None and _is_pipe(pipeline):\n        _PIPELINES.add(pipeline)\n        total += 1\n\n    return total\n</code></pre>"},{"location":"ref/pipelines/#evalio.pipelines.validate_params","title":"validate_params","text":"<pre><code>validate_params(\n    pipe: type[Pipeline], params: dict[str, Param]\n) -&gt; None | InvalidPipelineParamType | UnusedPipelineParam\n</code></pre> <p>Validate the parameters for a given pipeline.</p> <p>Parameters:</p> <ul> <li> <code>pipe</code>               (<code>type[Pipeline]</code>)           \u2013            <p>The pipeline class.</p> </li> <li> <code>params</code>               (<code>dict[str, Param]</code>)           \u2013            <p>The parameters to validate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | InvalidPipelineParamType | UnusedPipelineParam</code>           \u2013            <p>An error if validation fails, otherwise None.</p> </li> </ul> Source code in <code>python/evalio/pipelines/parser.py</code> <pre><code>def validate_params(\n    pipe: type[Pipeline],\n    params: dict[str, Param],\n) -&gt; None | InvalidPipelineParamType | UnusedPipelineParam:\n    \"\"\"Validate the parameters for a given pipeline.\n\n    Args:\n        pipe (type[Pipeline]): The pipeline class.\n        params (dict[str, Param]): The parameters to validate.\n\n    Returns:\n        An error if validation fails, otherwise None.\n    \"\"\"\n    default_params = pipe.default_params()\n    for p in params:\n        if p not in default_params:\n            return UnusedPipelineParam(p, pipe.name())\n\n        expected_type = type(default_params[p])\n        actual_type = type(params[p])\n        if actual_type != expected_type:\n            return InvalidPipelineParamType(p, expected_type, actual_type)\n\n    return None\n</code></pre>"},{"location":"ref/rerun/","title":"evalio.rerun","text":"<p>Functions:</p> <ul> <li> <code>convert</code>             \u2013              <p>Convert a variety of objects to rerun types.</p> </li> </ul>"},{"location":"ref/rerun/#evalio.rerun.convert","title":"convert","text":"<pre><code>convert(\n    obj: LidarMeasurement,\n    color: Optional[\n        Literal[\"z\", \"intensity\"]\n        | tuple[int, int, int]\n        | tuple[float, float, float]\n    ] = None,\n    radii: Optional[float] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: list[Point],\n    color: Optional[\n        Literal[\"z\", \"intensity\"]\n        | tuple[int, int, int]\n        | tuple[float, float, float]\n    ] = None,\n    radii: Optional[float] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: NDArray[float64],\n    color: Optional[Literal[\"z\"] | NDArray[float64]] = None,\n    radii: Optional[float] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: list[SE3],\n    color: Optional[\n        tuple[int, int, int] | tuple[float, float, float]\n    ] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: Trajectory[M],\n    color: Optional[\n        tuple[int, int, int] | tuple[float, float, float]\n    ] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(obj: SE3) -&gt; Transform3D\n</code></pre> <pre><code>convert(\n    obj: Any,\n    color: Optional[Any] = None,\n    radii: Optional[float] = None,\n) -&gt; Transform3D | Points3D\n</code></pre> <p>Convert a variety of objects to rerun types.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>object</code>)           \u2013            <p>Object to convert. Can be a LidarMeasurement, list of Points, numpy array, SE3, or Trajectory.</p> </li> <li> <code>color</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Optional color to set. See overloads for additional literal options. Defaults to None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the color pass is invalid.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the object is not an implemented type for conversion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Transform3D | Points3D</code>           \u2013            <p>Rerun type.</p> </li> </ul> Source code in <code>python/evalio/rerun.py</code> <pre><code>def convert(\n    obj: Any,\n    color: Optional[Any] = None,\n    radii: Optional[float] = None,\n) -&gt; rr.Transform3D | rr.Points3D:\n    \"\"\"Convert a variety of objects to rerun types.\n\n    Args:\n        obj (object): Object to convert. Can be a LidarMeasurement, list of Points, numpy array, SE3, or Trajectory.\n        color (Optional[Any], optional): Optional color to set. See overloads for additional literal options. Defaults to None.\n\n    Raises:\n        ValueError: If the color pass is invalid.\n        ValueError: If the object is not an implemented type for conversion.\n\n    Returns:\n        Rerun type.\n    \"\"\"\n    # If we have an empty list, assume it's a point cloud with no points\n    if isinstance(obj, list) and len(obj) == 0:  # type: ignore\n        return rr.Points3D(np.zeros((0, 3)), colors=color, radii=radii)\n\n    # Handle point clouds\n    if isinstance(obj, LidarMeasurement):\n        color_parsed = None\n        if isinstance(color, tuple):\n            color = cast(tuple[int, int, int], color)\n            color_parsed = np.asarray(color)\n        elif color == \"intensity\":\n            max_intensity = max([p.intensity for p in obj.points])\n            color_parsed = np.zeros((len(obj.points), 3))\n            for i, point in enumerate(obj.points):\n                val = point.intensity / max_intensity\n                color_parsed[i] = [1.0 - val, val, 0]\n        elif color == \"z\":\n            zs = [p.z for p in obj.points]\n            min_z, max_z = min(zs), max(zs)\n            color_parsed = np.zeros((len(obj.points), 3))\n            for i, point in enumerate(obj.points):\n                val = (point.z - min_z) / (max_z - min_z)\n                color_parsed[i] = [1.0 - val, val, 0]\n        elif color is not None:\n            raise ValueError(f\"Unknown color type {color}\")\n\n        return convert(\n            np.asarray(obj.to_vec_positions()), color=color_parsed, radii=radii\n        )\n\n    elif isinstance(obj, list) and isinstance(obj[0], Point):\n        obj = cast(list[Point], obj)\n        return convert(\n            LidarMeasurement(Stamp.from_sec(0), obj), color=color, radii=radii\n        )\n\n    elif isinstance(obj, np.ndarray) and len(obj.shape) == 2 and obj.shape[1] == 3:  # type: ignore\n        obj = cast(NDArray[np.float64], obj)\n        if isinstance(color, str) and color == \"z\":\n            zs = obj[:, 2]\n            min_z, max_z = min(zs), max(zs)\n            color = np.zeros_like(obj)\n            color = cast(NDArray[np.float64], color)\n\n            val = (zs - min_z) / (max_z - min_z)\n            color[:, 0] = 1.0 - val\n            color[:, 1] = val\n\n        return rr.Points3D(obj, colors=color, radii=radii)\n\n    # Handle poses\n    elif isinstance(obj, SE3):\n        return rr.Transform3D(\n            rotation=rr.datatypes.Quaternion(\n                xyzw=[\n                    obj.rot.qx,\n                    obj.rot.qy,\n                    obj.rot.qz,\n                    obj.rot.qw,\n                ]\n            ),\n            translation=obj.trans,\n        )\n    elif isinstance(obj, Trajectory):\n        return convert(obj.poses, color=color)\n    elif isinstance(obj, list) and isinstance(obj[0], SE3):\n        obj = cast(list[SE3], obj)\n        points = np.zeros((len(obj), 3))\n        for i, pose in enumerate(obj):\n            points[i] = pose.trans\n        return rr.Points3D(points, colors=color)\n\n    else:\n        raise ValueError(f\"Cannot convert {type(obj)} to rerun type\")  # type: ignore\n</code></pre>"},{"location":"ref/stats/","title":"evalio.stats","text":"<p>Classes:</p> <ul> <li> <code>Error</code>           \u2013            <p>Dataclass to hold the error between two trajectories.</p> </li> <li> <code>Metric</code>           \u2013            <p>Simple dataclass to hold the resulting metrics. Likely output from Error.</p> </li> <li> <code>MetricKind</code>           \u2013            <p>Simple enum to define the metric to use for summarizing the error. Used in Error.</p> </li> <li> <code>WindowMeters</code>           \u2013            <p>Dataclass to hold the parameters for a distance-based window.</p> </li> <li> <code>WindowSeconds</code>           \u2013            <p>Dataclass to hold the parameters for a time-based window.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>align</code>             \u2013              <p>Align the trajectories both spatially and temporally.</p> </li> <li> <code>align_poses</code>             \u2013              <p>Align the trajectory in place to another trajectory. Operates in place.</p> </li> <li> <code>align_stamps</code>             \u2013              <p>Select the closest poses in traj1 and traj2. Operates in place.</p> </li> <li> <code>ate</code>             \u2013              <p>Compute the Absolute Trajectory Error (ATE) between two trajectories.</p> </li> <li> <code>rte</code>             \u2013              <p>Compute the Relative Trajectory Error (RTE) between two trajectories.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>WindowKind</code>           \u2013            <p>Type alias for either a WindowMeters or a WindowSeconds.</p> </li> </ul>"},{"location":"ref/stats/#evalio.stats.WindowKind","title":"WindowKind  <code>module-attribute</code>","text":"<pre><code>WindowKind = WindowMeters | WindowSeconds\n</code></pre> <p>Type alias for either a WindowMeters or a WindowSeconds.</p>"},{"location":"ref/stats/#evalio.stats.Error","title":"Error  <code>dataclass</code>","text":"<p>Dataclass to hold the error between two trajectories. Generally output from computing ate or rte.</p> <p>Contains a (n,) arrays of translation and rotation errors.</p> <p>Methods:</p> <ul> <li> <code>mean</code>             \u2013              <p>Compute the mean of the errors.</p> </li> <li> <code>median</code>             \u2013              <p>Compute the median of the errors.</p> </li> <li> <code>sse</code>             \u2013              <p>Compute the sqrt of sum of squared errors.</p> </li> <li> <code>summarize</code>             \u2013              <p>How to summarize the vector of errors.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>rot</code>               (<code>NDArray[float64]</code>)           \u2013            <p>rotation error, shape (n,), in degrees</p> </li> <li> <code>trans</code>               (<code>NDArray[float64]</code>)           \u2013            <p>translation error, shape (n,), in meters</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>@dataclass(kw_only=True)\nclass Error:\n    \"\"\"\n    Dataclass to hold the error between two trajectories.\n    Generally output from computing [ate][evalio.stats.ate] or [rte][evalio.stats.rte].\n\n    Contains a (n,) arrays of translation and rotation errors.\n    \"\"\"\n\n    # Shape: (n,)\n    trans: NDArray[np.float64]\n    \"\"\"translation error, shape (n,), in meters\"\"\"\n    rot: NDArray[np.float64]\n    \"\"\"rotation error, shape (n,), in degrees\"\"\"\n\n    def summarize(self, metric: MetricKind) -&gt; Metric:\n        \"\"\"How to summarize the vector of errors.\n\n        Args:\n            metric (MetricKind): The metric to use for summarizing the error,\n                either mean, median, or sse.\n\n        Returns:\n            The summarized error\n        \"\"\"\n        match metric:\n            case MetricKind.mean:\n                return self.mean()\n            case MetricKind.median:\n                return self.median()\n            case MetricKind.sse:\n                return self.sse()\n\n    def mean(self) -&gt; Metric:\n        \"\"\"Compute the mean of the errors.\"\"\"\n        return Metric(rot=self.rot.mean(), trans=self.trans.mean())\n\n    def sse(self) -&gt; Metric:\n        \"\"\"Compute the sqrt of sum of squared errors.\"\"\"\n        length = len(self.rot)\n        return Metric(\n            rot=float(np.sqrt(self.rot @ self.rot / length)),\n            trans=float(np.sqrt(self.trans @ self.trans / length)),\n        )\n\n    def median(self) -&gt; Metric:\n        \"\"\"Compute the median of the errors.\"\"\"\n        return Metric(\n            rot=cast(float, np.median(self.rot)),\n            trans=cast(float, np.median(self.trans)),\n        )\n</code></pre>"},{"location":"ref/stats/#evalio.stats.Error.rot","title":"rot  <code>instance-attribute</code>","text":"<pre><code>rot: NDArray[float64]\n</code></pre> <p>rotation error, shape (n,), in degrees</p>"},{"location":"ref/stats/#evalio.stats.Error.trans","title":"trans  <code>instance-attribute</code>","text":"<pre><code>trans: NDArray[float64]\n</code></pre> <p>translation error, shape (n,), in meters</p>"},{"location":"ref/stats/#evalio.stats.Error.mean","title":"mean","text":"<pre><code>mean() -&gt; Metric\n</code></pre> <p>Compute the mean of the errors.</p> Source code in <code>python/evalio/stats.py</code> <pre><code>def mean(self) -&gt; Metric:\n    \"\"\"Compute the mean of the errors.\"\"\"\n    return Metric(rot=self.rot.mean(), trans=self.trans.mean())\n</code></pre>"},{"location":"ref/stats/#evalio.stats.Error.median","title":"median","text":"<pre><code>median() -&gt; Metric\n</code></pre> <p>Compute the median of the errors.</p> Source code in <code>python/evalio/stats.py</code> <pre><code>def median(self) -&gt; Metric:\n    \"\"\"Compute the median of the errors.\"\"\"\n    return Metric(\n        rot=cast(float, np.median(self.rot)),\n        trans=cast(float, np.median(self.trans)),\n    )\n</code></pre>"},{"location":"ref/stats/#evalio.stats.Error.sse","title":"sse","text":"<pre><code>sse() -&gt; Metric\n</code></pre> <p>Compute the sqrt of sum of squared errors.</p> Source code in <code>python/evalio/stats.py</code> <pre><code>def sse(self) -&gt; Metric:\n    \"\"\"Compute the sqrt of sum of squared errors.\"\"\"\n    length = len(self.rot)\n    return Metric(\n        rot=float(np.sqrt(self.rot @ self.rot / length)),\n        trans=float(np.sqrt(self.trans @ self.trans / length)),\n    )\n</code></pre>"},{"location":"ref/stats/#evalio.stats.Error.summarize","title":"summarize","text":"<pre><code>summarize(metric: MetricKind) -&gt; Metric\n</code></pre> <p>How to summarize the vector of errors.</p> <p>Parameters:</p> <ul> <li> <code>metric</code>               (<code>MetricKind</code>)           \u2013            <p>The metric to use for summarizing the error, either mean, median, or sse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Metric</code>           \u2013            <p>The summarized error</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>def summarize(self, metric: MetricKind) -&gt; Metric:\n    \"\"\"How to summarize the vector of errors.\n\n    Args:\n        metric (MetricKind): The metric to use for summarizing the error,\n            either mean, median, or sse.\n\n    Returns:\n        The summarized error\n    \"\"\"\n    match metric:\n        case MetricKind.mean:\n            return self.mean()\n        case MetricKind.median:\n            return self.median()\n        case MetricKind.sse:\n            return self.sse()\n</code></pre>"},{"location":"ref/stats/#evalio.stats.Metric","title":"Metric  <code>dataclass</code>","text":"<p>Simple dataclass to hold the resulting metrics. Likely output from Error.</p> <p>Attributes:</p> <ul> <li> <code>rot</code>               (<code>float</code>)           \u2013            <p>rotation error in degrees</p> </li> <li> <code>trans</code>               (<code>float</code>)           \u2013            <p>translation error in meters</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>@dataclass(kw_only=True)\nclass Metric:\n    \"\"\"Simple dataclass to hold the resulting metrics. Likely output from [Error][evalio.stats.Error].\"\"\"\n\n    trans: float\n    \"\"\"translation error in meters\"\"\"\n    rot: float\n    \"\"\"rotation error in degrees\"\"\"\n</code></pre>"},{"location":"ref/stats/#evalio.stats.Metric.rot","title":"rot  <code>instance-attribute</code>","text":"<pre><code>rot: float\n</code></pre> <p>rotation error in degrees</p>"},{"location":"ref/stats/#evalio.stats.Metric.trans","title":"trans  <code>instance-attribute</code>","text":"<pre><code>trans: float\n</code></pre> <p>translation error in meters</p>"},{"location":"ref/stats/#evalio.stats.MetricKind","title":"MetricKind","text":"<p>               Bases: <code>StrEnum</code></p> <p>Simple enum to define the metric to use for summarizing the error. Used in Error.</p> <p>Attributes:</p> <ul> <li> <code>mean</code>           \u2013            <p>Mean</p> </li> <li> <code>median</code>           \u2013            <p>Median</p> </li> <li> <code>sse</code>           \u2013            <p>Sqrt of Sum of squared errors</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>class MetricKind(StrEnum):\n    \"\"\"Simple enum to define the metric to use for summarizing the error. Used in [Error][evalio.stats.Error.summarize].\"\"\"\n\n    mean = auto()\n    \"\"\"Mean\"\"\"\n    median = auto()\n    \"\"\"Median\"\"\"\n    sse = auto()\n    \"\"\"Sqrt of Sum of squared errors\"\"\"\n</code></pre>"},{"location":"ref/stats/#evalio.stats.MetricKind.mean","title":"mean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mean = auto()\n</code></pre> <p>Mean</p>"},{"location":"ref/stats/#evalio.stats.MetricKind.median","title":"median  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>median = auto()\n</code></pre> <p>Median</p>"},{"location":"ref/stats/#evalio.stats.MetricKind.sse","title":"sse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sse = auto()\n</code></pre> <p>Sqrt of Sum of squared errors</p>"},{"location":"ref/stats/#evalio.stats.WindowMeters","title":"WindowMeters  <code>dataclass</code>","text":"<p>Dataclass to hold the parameters for a distance-based window.</p> <p>Methods:</p> <ul> <li> <code>name</code>             \u2013              <p>Get a string representation of the window.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Distance in meters</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>@dataclass\nclass WindowMeters:\n    \"\"\"Dataclass to hold the parameters for a distance-based window.\"\"\"\n\n    value: float\n    \"\"\"Distance in meters\"\"\"\n\n    def name(self) -&gt; str:\n        \"\"\"Get a string representation of the window.\"\"\"\n        return f\"{self.value:.1f}m\"\n</code></pre>"},{"location":"ref/stats/#evalio.stats.WindowMeters.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: float\n</code></pre> <p>Distance in meters</p>"},{"location":"ref/stats/#evalio.stats.WindowMeters.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get a string representation of the window.</p> Source code in <code>python/evalio/stats.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"Get a string representation of the window.\"\"\"\n    return f\"{self.value:.1f}m\"\n</code></pre>"},{"location":"ref/stats/#evalio.stats.WindowSeconds","title":"WindowSeconds  <code>dataclass</code>","text":"<p>Dataclass to hold the parameters for a time-based window.</p> <p>Methods:</p> <ul> <li> <code>name</code>             \u2013              <p>Get a string representation of the window.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Duration of the window in seconds</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>@dataclass\nclass WindowSeconds:\n    \"\"\"Dataclass to hold the parameters for a time-based window.\"\"\"\n\n    value: float\n    \"\"\"Duration of the window in seconds\"\"\"\n\n    def name(self) -&gt; str:\n        \"\"\"Get a string representation of the window.\"\"\"\n        return f\"{self.value}s\"\n</code></pre>"},{"location":"ref/stats/#evalio.stats.WindowSeconds.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: float\n</code></pre> <p>Duration of the window in seconds</p>"},{"location":"ref/stats/#evalio.stats.WindowSeconds.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get a string representation of the window.</p> Source code in <code>python/evalio/stats.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"Get a string representation of the window.\"\"\"\n    return f\"{self.value}s\"\n</code></pre>"},{"location":"ref/stats/#evalio.stats.align","title":"align","text":"<pre><code>align(\n    traj: Trajectory[M1],\n    gt: Trajectory[M2],\n    in_place: bool = False,\n) -&gt; tuple[Trajectory[M1], Trajectory[M2]]\n</code></pre> <p>Align the trajectories both spatially and temporally.</p> <p>The resulting trajectories will be have the same origin as the second (\"gt\") trajectory. See align_poses and align_stamps for more details.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>One of the trajectories to align.</p> </li> <li> <code>gt</code>               (<code>Trajectory</code>)           \u2013            <p>The other trajectory to align to.</p> </li> <li> <code>in_place</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, the original trajectory will be modified. Defaults to False.</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>def align(\n    traj: ty.Trajectory[M1], gt: ty.Trajectory[M2], in_place: bool = False\n) -&gt; tuple[ty.Trajectory[M1], ty.Trajectory[M2]]:\n    \"\"\"Align the trajectories both spatially and temporally.\n\n    The resulting trajectories will be have the same origin as the second (\"gt\") trajectory.\n    See [align_poses][evalio.stats.align_poses] and [align_stamps][evalio.stats.align_stamps] for more details.\n\n    Args:\n        traj (Trajectory): One of the trajectories to align.\n        gt (Trajectory): The other trajectory to align to.\n        in_place (bool, optional): If true, the original trajectory will be modified. Defaults to False.\n    \"\"\"\n    if not in_place:\n        traj = deepcopy(traj)\n        gt = deepcopy(gt)\n\n    align_stamps(traj, gt)\n    align_poses(traj, gt)\n\n    return traj, gt\n</code></pre>"},{"location":"ref/stats/#evalio.stats.align_poses","title":"align_poses","text":"<pre><code>align_poses(traj: Trajectory[M1], other: Trajectory[M2])\n</code></pre> <p>Align the trajectory in place to another trajectory. Operates in place.</p> <p>This results in the current trajectory having an identical first pose to the other trajectory. Assumes the first pose of both trajectories have the same stamp.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory that will be modified</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory to align to.</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>def align_poses(traj: ty.Trajectory[M1], other: ty.Trajectory[M2]):\n    \"\"\"Align the trajectory in place to another trajectory. Operates in place.\n\n    This results in the current trajectory having an identical first pose to the other trajectory.\n    Assumes the first pose of both trajectories have the same stamp.\n\n    Args:\n        traj (Trajectory): The trajectory that will be modified\n        other (Trajectory): The trajectory to align to.\n    \"\"\"\n    this = traj.poses[0]\n    oth = other.poses[0]\n    delta = oth * this.inverse()\n\n    for i in range(len(traj.poses)):\n        traj.poses[i] = delta * traj.poses[i]\n</code></pre>"},{"location":"ref/stats/#evalio.stats.align_stamps","title":"align_stamps","text":"<pre><code>align_stamps(traj1: Trajectory[M1], traj2: Trajectory[M2])\n</code></pre> <p>Select the closest poses in traj1 and traj2. Operates in place.</p> <p>Does this by finding the higher frame rate trajectory and subsampling it to the closest poses of the other one. Additionally it checks the beginning of the trajectories to make sure they start at about the same stamp.</p> <p>Parameters:</p> <ul> <li> <code>traj1</code>               (<code>Trajectory</code>)           \u2013            <p>One trajectory</p> </li> <li> <code>traj2</code>               (<code>Trajectory</code>)           \u2013            <p>Other trajectory</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>def align_stamps(traj1: ty.Trajectory[M1], traj2: ty.Trajectory[M2]):\n    \"\"\"Select the closest poses in traj1 and traj2. Operates in place.\n\n    Does this by finding the higher frame rate trajectory and subsampling it to the closest poses of the other one.\n    Additionally it checks the beginning of the trajectories to make sure they start at about the same stamp.\n\n    Args:\n        traj1 (Trajectory): One trajectory\n        traj2 (Trajectory): Other trajectory\n    \"\"\"\n    # Check if we need to skip poses in traj1\n    first_pose_idx = 0\n    while traj1.stamps[first_pose_idx] &lt; traj2.stamps[0]:\n        first_pose_idx += 1\n    if not closest(\n        traj2.stamps[0],\n        traj1.stamps[first_pose_idx - 1],\n        traj1.stamps[first_pose_idx],\n    ):\n        first_pose_idx -= 1\n    traj1.stamps = traj1.stamps[first_pose_idx:]\n    traj1.poses = traj1.poses[first_pose_idx:]\n\n    # Check if we need to skip poses in traj2\n    first_pose_idx = 0\n    while traj2.stamps[first_pose_idx] &lt; traj1.stamps[0]:\n        first_pose_idx += 1\n    if not closest(\n        traj1.stamps[0],\n        traj2.stamps[first_pose_idx - 1],\n        traj2.stamps[first_pose_idx],\n    ):\n        first_pose_idx -= 1\n    traj2.stamps = traj2.stamps[first_pose_idx:]\n    traj2.poses = traj2.poses[first_pose_idx:]\n\n    # Find the one that is at a higher frame rate\n    # Leaves us with traj1 being the one with the higher frame rate\n    swapped = False\n    traj_1_dt = (traj1.stamps[-1] - traj1.stamps[0]).to_sec() / len(traj1.stamps)\n    traj_2_dt = (traj2.stamps[-1] - traj2.stamps[0]).to_sec() / len(traj2.stamps)\n    if traj_1_dt &gt; traj_2_dt:\n        traj1, traj2 = traj2, traj1  # type: ignore\n        swapped = True\n\n    # cache this value\n    len_traj1 = len(traj1)\n\n    # Align the two trajectories by subsampling keeping traj1 stamps\n    traj1_idx = 0\n    traj1_stamps: list[ty.Stamp] = []\n    traj1_poses: list[ty.SE3] = []\n    for i, stamp in enumerate(traj2.stamps):\n        while traj1_idx &lt; len_traj1 - 1 and traj1.stamps[traj1_idx] &lt; stamp:\n            traj1_idx += 1\n\n        # go back one if we overshot\n        if not closest(stamp, traj1.stamps[traj1_idx - 1], traj1.stamps[traj1_idx]):\n            traj1_idx -= 1\n\n        traj1_stamps.append(traj1.stamps[traj1_idx])\n        traj1_poses.append(traj1.poses[traj1_idx])\n\n        if traj1_idx &gt;= len_traj1 - 1:\n            traj2.stamps = traj2.stamps[: i + 1]\n            traj2.poses = traj2.poses[: i + 1]\n            break\n\n    traj1.stamps = traj1_stamps\n    traj1.poses = traj1_poses\n\n    if swapped:\n        traj1, traj2 = traj2, traj1  # type: ignore\n</code></pre>"},{"location":"ref/stats/#evalio.stats.ate","title":"ate","text":"<pre><code>ate(traj: Trajectory[M1], gt: Trajectory[M2]) -&gt; Error\n</code></pre> <p>Compute the Absolute Trajectory Error (ATE) between two trajectories.</p> <p>Will check if the two trajectories are aligned and if not, will align them. Will not modify the original trajectories.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>One of the trajectories</p> </li> <li> <code>gt</code>               (<code>Trajectory</code>)           \u2013            <p>The other trajectory</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Error</code>           \u2013            <p>The computed error</p> </li> </ul> Source code in <code>python/evalio/stats.py</code> <pre><code>def ate(traj: ty.Trajectory[M1], gt: ty.Trajectory[M2]) -&gt; Error:\n    \"\"\"Compute the Absolute Trajectory Error (ATE) between two trajectories.\n\n    Will check if the two trajectories are aligned and if not, will align them.\n    Will not modify the original trajectories.\n\n    Args:\n        traj (Trajectory): One of the trajectories\n        gt (Trajectory): The other trajectory\n\n    Returns:\n        The computed error\n    \"\"\"\n    if not _check_aligned(traj, gt):\n        traj, gt = align(traj, gt)\n\n    # Compute the ATE\n    return _compute_metric(gt.poses, traj.poses)\n</code></pre>"},{"location":"ref/stats/#evalio.stats.rte","title":"rte","text":"<pre><code>rte(\n    traj: Trajectory[M1],\n    gt: Trajectory[M2],\n    window: WindowKind = WindowMeters(30),\n) -&gt; Error\n</code></pre> <p>Compute the Relative Trajectory Error (RTE) between two trajectories.</p> <p>Will check if the two trajectories are aligned and if not, will align them. Will not modify the original trajectories.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>One of the trajectories</p> </li> <li> <code>gt</code>               (<code>Trajectory</code>)           \u2013            <p>The other trajectory</p> </li> <li> <code>window</code>               (<code>WindowKind</code>, default:                   <code>WindowMeters(30)</code> )           \u2013            <p>The window to use for computing the RTE. Either a WindowMeters or a WindowSeconds. Defaults to WindowMeters(30), which is a 30 meter window.</p> </li> </ul> <p>Returns:     The computed error</p> Source code in <code>python/evalio/stats.py</code> <pre><code>def rte(\n    traj: ty.Trajectory[M1],\n    gt: ty.Trajectory[M2],\n    window: WindowKind = WindowMeters(30),\n) -&gt; Error:\n    \"\"\"Compute the Relative Trajectory Error (RTE) between two trajectories.\n\n    Will check if the two trajectories are aligned and if not, will align them.\n    Will not modify the original trajectories.\n\n    Args:\n        traj (Trajectory): One of the trajectories\n        gt (Trajectory): The other trajectory\n        window (WindowKind, optional): The window to use for computing the RTE.\n            Either a [WindowMeters][evalio.stats.WindowMeters] or a [WindowSeconds][evalio.stats.WindowSeconds].\n            Defaults to WindowMeters(30), which is a 30 meter window.\n    Returns:\n        The computed error\n    \"\"\"\n    if not _check_aligned(traj, gt):\n        traj, gt = align(traj, gt)\n\n    if window.value &lt;= 0:\n        raise ValueError(\"Window size must be positive\")\n\n    window_deltas_poses: list[ty.SE3] = []\n    window_deltas_gts: list[ty.SE3] = []\n\n    # cache this value\n    len_gt = len(gt)\n\n    if isinstance(window, WindowSeconds):\n        # Find our pairs for computation\n        end_idx = 1\n        duration = ty.Duration.from_sec(window.value)\n\n        for i in range(len_gt):\n            while end_idx &lt; len_gt and gt.stamps[end_idx] - gt.stamps[i] &lt; duration:\n                end_idx += 1\n\n            if end_idx &gt;= len_gt:\n                break\n\n            window_deltas_poses.append(traj.poses[i].inverse() * traj.poses[end_idx])\n            window_deltas_gts.append(gt.poses[i].inverse() * gt.poses[end_idx])\n\n\n    elif isinstance(window, WindowMeters):\n        # Compute deltas for all of ground truth poses\n        dist = np.zeros(len_gt)\n        for i in range(1, len_gt):\n            dist[i] = ty.SE3.distance(gt.poses[i], gt.poses[i - 1])\n\n        cum_dist = np.cumsum(dist)\n        end_idx = 1\n        end_idx_prev = 0\n\n        # Find our pairs for computation\n        for i in range(len_gt):\n            while end_idx &lt; len_gt and cum_dist[end_idx] - cum_dist[i] &lt; window.value:\n                end_idx += 1\n\n            if end_idx &gt;= len_gt:\n                break\n            elif end_idx == end_idx_prev:\n                continue\n\n            window_deltas_poses.append(traj.poses[i].inverse() * traj.poses[end_idx])\n            window_deltas_gts.append(gt.poses[i].inverse() * gt.poses[end_idx])\n\n            end_idx_prev = end_idx\n\n    if len(window_deltas_poses) == 0:\n        if isinstance(traj.metadata, ty.Experiment):\n            print_warning(\n                f\"No {window} windows found for '{traj.metadata.name}' on '{traj.metadata.sequence}'\"\n            )\n        else:\n            print_warning(f\"No {window} windows found\")\n        return Error(rot=np.array([np.nan]), trans=np.array([np.nan]))\n\n    # Compute the RTE\n    return _compute_metric(window_deltas_gts, window_deltas_poses)\n</code></pre>"},{"location":"ref/types/","title":"evalio.types","text":"<p>Classes:</p> <ul> <li> <code>Duration</code>           \u2013            <p>Duration class for representing a positive or negative delta time. </p> </li> <li> <code>Experiment</code>           \u2013            <p>An experiment is a single run of a pipeline on a dataset.</p> </li> <li> <code>ExperimentStatus</code>           \u2013            <p>Status of the experiment.</p> </li> <li> <code>FailedMetadataParse</code>           \u2013            <p>Exception raised when metadata parsing fails.</p> </li> <li> <code>GroundTruth</code>           \u2013            <p>Metadata for ground truth trajectories.</p> </li> <li> <code>ImuMeasurement</code>           \u2013            <p>ImuMeasurement is a simple structure for storing an IMU measurement.</p> </li> <li> <code>ImuParams</code>           \u2013            <p>ImuParams is a structure for storing the parameters of an IMU</p> </li> <li> <code>LidarMeasurement</code>           \u2013            <p>LidarMeasurement is a structure for storing a point cloud measurement, with a timestamp and a vector of points.</p> </li> <li> <code>LidarParams</code>           \u2013            <p>LidarParams is a structure for storing the parameters of a lidar sensor.</p> </li> <li> <code>Metadata</code>           \u2013            <p>Base class for metadata associated with a trajectory.</p> </li> <li> <code>Point</code>           \u2013            <p>Point is the general point structure in evalio, with common point cloud attributes included.</p> </li> <li> <code>SE3</code>           \u2013            <p>SE3 class for representing a 3D rigid body transformation using a quaternion and a translation vector.</p> </li> <li> <code>SO3</code>           \u2013            <p>SO3 class for representing a 3D rotation using a quaternion.</p> </li> <li> <code>Stamp</code>           \u2013            <p>Stamp class for representing an absolute point in time.</p> </li> <li> <code>Trajectory</code>           \u2013            <p>A trajectory of poses with associated timestamps and metadata.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Param</code>           \u2013            <p>A parameter value for a pipeline, can be a bool, int, float, or str.</p> </li> </ul>"},{"location":"ref/types/#evalio.types.Param","title":"Param  <code>module-attribute</code>","text":"<pre><code>Param = bool | int | float | str\n</code></pre> <p>A parameter value for a pipeline, can be a bool, int, float, or str.</p>"},{"location":"ref/types/#evalio.types.Duration","title":"Duration","text":"<p>Duration class for representing a positive or negative delta time. </p> <p>Uses int64 as the underlying data storage for nanoseconds.</p> <p>Methods:</p> <ul> <li> <code>__add__</code>             \u2013              <p>Add two Durations</p> </li> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__gt__</code>             \u2013              <p>Compare two Durations</p> </li> <li> <code>__lt__</code>             \u2013              <p>Compare two Durations</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> <li> <code>__sub__</code>             \u2013              <p>Compute the difference between two Durations</p> </li> <li> <code>from_nsec</code>             \u2013              <p>Create a Duration from nanoseconds</p> </li> <li> <code>from_sec</code>             \u2013              <p>Create a Duration from seconds</p> </li> <li> <code>to_nsec</code>             \u2013              <p>Convert to nanoseconds</p> </li> <li> <code>to_sec</code>             \u2013              <p>Convert to seconds</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>nsec</code>               (<code>int</code>)           \u2013            <p>Underlying nanoseconds representation</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class Duration:\n    \"\"\"\n    Duration class for representing a positive or negative delta time. \n\n    Uses int64 as the underlying data storage for nanoseconds.\n    \"\"\"\n\n    @staticmethod\n    def from_sec(sec: float) -&gt; Duration:\n        \"\"\"Create a Duration from seconds\"\"\"\n\n    @staticmethod\n    def from_nsec(nsec: int) -&gt; Duration:\n        \"\"\"Create a Duration from nanoseconds\"\"\"\n\n    def to_sec(self) -&gt; float:\n        \"\"\"Convert to seconds\"\"\"\n\n    def to_nsec(self) -&gt; int:\n        \"\"\"Convert to nanoseconds\"\"\"\n\n    @property\n    def nsec(self) -&gt; int:\n        \"\"\"Underlying nanoseconds representation\"\"\"\n\n    def __lt__(self, arg: Duration, /) -&gt; bool:\n        \"\"\"Compare two Durations\"\"\"\n\n    def __gt__(self, arg: Duration, /) -&gt; bool:\n        \"\"\"Compare two Durations\"\"\"\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    def __sub__(self, arg: Duration, /) -&gt; Duration:\n        \"\"\"Compute the difference between two Durations\"\"\"\n\n    def __add__(self, arg: Duration, /) -&gt; Duration:\n        \"\"\"Add two Durations\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __copy__(self) -&gt; Duration: ...\n\n    def __deepcopy__(self, memo: dict[Any, Any]) -&gt; Duration: ...\n\n    def __getstate__(self) -&gt; tuple[int]: ...\n\n    def __setstate__(self, arg: tuple[int], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.nsec","title":"nsec  <code>property</code>","text":"<pre><code>nsec: int\n</code></pre> <p>Underlying nanoseconds representation</p>"},{"location":"ref/types/#evalio.types.Duration.__add__","title":"__add__","text":"<pre><code>__add__(arg: Duration) -&gt; Duration\n</code></pre> <p>Add two Durations</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __add__(self, arg: Duration, /) -&gt; Duration:\n    \"\"\"Add two Durations\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.__gt__","title":"__gt__","text":"<pre><code>__gt__(arg: Duration) -&gt; bool\n</code></pre> <p>Compare two Durations</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __gt__(self, arg: Duration, /) -&gt; bool:\n    \"\"\"Compare two Durations\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.__lt__","title":"__lt__","text":"<pre><code>__lt__(arg: Duration) -&gt; bool\n</code></pre> <p>Compare two Durations</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __lt__(self, arg: Duration, /) -&gt; bool:\n    \"\"\"Compare two Durations\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.__sub__","title":"__sub__","text":"<pre><code>__sub__(arg: Duration) -&gt; Duration\n</code></pre> <p>Compute the difference between two Durations</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __sub__(self, arg: Duration, /) -&gt; Duration:\n    \"\"\"Compute the difference between two Durations\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.from_nsec","title":"from_nsec  <code>staticmethod</code>","text":"<pre><code>from_nsec(nsec: int) -&gt; Duration\n</code></pre> <p>Create a Duration from nanoseconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef from_nsec(nsec: int) -&gt; Duration:\n    \"\"\"Create a Duration from nanoseconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.from_sec","title":"from_sec  <code>staticmethod</code>","text":"<pre><code>from_sec(sec: float) -&gt; Duration\n</code></pre> <p>Create a Duration from seconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef from_sec(sec: float) -&gt; Duration:\n    \"\"\"Create a Duration from seconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.to_nsec","title":"to_nsec","text":"<pre><code>to_nsec() -&gt; int\n</code></pre> <p>Convert to nanoseconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def to_nsec(self) -&gt; int:\n    \"\"\"Convert to nanoseconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Duration.to_sec","title":"to_sec","text":"<pre><code>to_sec() -&gt; float\n</code></pre> <p>Convert to seconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def to_sec(self) -&gt; float:\n    \"\"\"Convert to seconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Experiment","title":"Experiment  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>An experiment is a single run of a pipeline on a dataset.</p> <p>It contains all the information needed to reproduce the run, including the pipeline parameters, dataset, and status.</p> <p>Methods:</p> <ul> <li> <code>from_pl_ds</code>             \u2013              <p>Create an Experiment from a pipeline and dataset.</p> </li> <li> <code>setup</code>             \u2013              <p>Setup the experiment by initializing the pipeline and dataset.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>max_elapsed</code>               (<code>Optional[float]</code>)           \u2013            <p>Maximum time taken for a single step in the experiment, as a string.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the experiment.</p> </li> <li> <code>pipeline</code>               (<code>str | type[Pipeline]</code>)           \u2013            <p>Pipeline used to generate the trajectory.</p> </li> <li> <code>pipeline_params</code>               (<code>dict[str, Param]</code>)           \u2013            <p>Parameters used for the pipeline.</p> </li> <li> <code>pipeline_version</code>               (<code>str</code>)           \u2013            <p>Version of the pipeline used.</p> </li> <li> <code>sequence</code>               (<code>str | Dataset</code>)           \u2013            <p>Dataset used to run the experiment.</p> </li> <li> <code>sequence_length</code>               (<code>int</code>)           \u2013            <p>Length of the sequence</p> </li> <li> <code>status</code>               (<code>ExperimentStatus</code>)           \u2013            <p>Status of the experiment, e.g. \"success\", \"failure\", etc.</p> </li> <li> <code>total_elapsed</code>               (<code>Optional[float]</code>)           \u2013            <p>Total time taken for the experiment, as a string.</p> </li> </ul> Source code in <code>python/evalio/types/extended.py</code> <pre><code>@dataclass(kw_only=True)\nclass Experiment(Metadata):\n    \"\"\"An experiment is a single run of a pipeline on a dataset.\n\n    It contains all the information needed to reproduce the run, including\n    the pipeline parameters, dataset, and status.\n    \"\"\"\n\n    name: str\n    \"\"\"Name of the experiment.\"\"\"\n    sequence: str | ds.Dataset\n    \"\"\"Dataset used to run the experiment.\"\"\"\n    sequence_length: int\n    \"\"\"Length of the sequence\"\"\"\n    pipeline: str | type[pl.Pipeline]\n    \"\"\"Pipeline used to generate the trajectory.\"\"\"\n    pipeline_version: str\n    \"\"\"Version of the pipeline used.\"\"\"\n    pipeline_params: dict[str, Param]\n    \"\"\"Parameters used for the pipeline.\"\"\"\n    status: ExperimentStatus = ExperimentStatus.NotRun\n    \"\"\"Status of the experiment, e.g. \"success\", \"failure\", etc.\"\"\"\n    total_elapsed: Optional[float] = None\n    \"\"\"Total time taken for the experiment, as a string.\"\"\"\n    max_elapsed: Optional[float] = None\n    \"\"\"Maximum time taken for a single step in the experiment, as a string.\"\"\"\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        d = super().to_dict()\n        d[\"status\"] = self.status.value\n        if isinstance(self.pipeline, type):\n            d[\"pipeline\"] = self.pipeline.name()\n        if isinstance(self.sequence, ds.Dataset):\n            d[\"sequence\"] = self.sequence.full_name\n\n        return d\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -&gt; Self:\n        if \"status\" in data:\n            data[\"status\"] = ExperimentStatus(data[\"status\"])\n        else:\n            data[\"status\"] = ExperimentStatus.Started\n\n        return super().from_dict(data)\n\n    @classmethod\n    def from_pl_ds(\n        cls, pipe: type[pl.Pipeline], ds_obj: ds.Dataset, **kwargs: Any\n    ) -&gt; Self:\n        \"\"\"Create an Experiment from a pipeline and dataset.\n\n        Args:\n            pipe (type[pl.Pipeline]): The pipeline class.\n            ds_obj (ds.Dataset): The dataset object.\n            **kwargs: Additional keyword arguments to pass to the Experiment constructor.\n\n        Returns:\n            Self: The created Experiment instance.\n        \"\"\"\n        return cls(\n            name=pipe.name(),\n            sequence=ds_obj,\n            sequence_length=len(ds_obj),\n            pipeline=pipe,\n            pipeline_version=pipe.version(),\n            pipeline_params=pipe.default_params() | kwargs,\n        )\n\n    def setup(\n        self,\n    ) -&gt; tuple[pl.Pipeline, ds.Dataset] | ds.SequenceNotFound | pl.PipelineNotFound:\n        \"\"\"Setup the experiment by initializing the pipeline and dataset.\n\n        Args:\n            self (Experiment): The experiment instance.\n\n        Returns:\n            Tuple containing the initialized pipeline and dataset, or an error if the pipeline or dataset could not be found or configured.\n        \"\"\"\n        if isinstance(self.pipeline, str):\n            ThisPipeline = pl.get_pipeline(self.pipeline)\n            if isinstance(ThisPipeline, pl.PipelineNotFound):\n                return ThisPipeline\n        else:\n            ThisPipeline = self.pipeline\n\n        if isinstance(self.sequence, ds.Dataset):\n            dataset = self.sequence\n        else:\n            dataset = ds.get_sequence(self.sequence)\n            if isinstance(dataset, ds.SequenceNotFound):\n                return dataset\n\n        pipe = ThisPipeline()\n\n        # Set user params\n        params = pipe.set_params(self.pipeline_params)\n        if len(params) &gt; 0:\n            for k, v in params.items():\n                print_warning(\n                    f\"Pipeline {self.name} has unused parameters: {k}={v}. \"\n                    \"Please check your configuration.\"\n                )\n\n        # Set dataset params\n        pipe.set_imu_params(dataset.imu_params())\n        pipe.set_lidar_params(dataset.lidar_params())\n        pipe.set_imu_T_lidar(dataset.imu_T_lidar())\n\n        # Initialize pipeline\n        pipe.initialize()\n\n        return pipe, dataset\n</code></pre>"},{"location":"ref/types/#evalio.types.Experiment.max_elapsed","title":"max_elapsed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_elapsed: Optional[float] = None\n</code></pre> <p>Maximum time taken for a single step in the experiment, as a string.</p>"},{"location":"ref/types/#evalio.types.Experiment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the experiment.</p>"},{"location":"ref/types/#evalio.types.Experiment.pipeline","title":"pipeline  <code>instance-attribute</code>","text":"<pre><code>pipeline: str | type[Pipeline]\n</code></pre> <p>Pipeline used to generate the trajectory.</p>"},{"location":"ref/types/#evalio.types.Experiment.pipeline_params","title":"pipeline_params  <code>instance-attribute</code>","text":"<pre><code>pipeline_params: dict[str, Param]\n</code></pre> <p>Parameters used for the pipeline.</p>"},{"location":"ref/types/#evalio.types.Experiment.pipeline_version","title":"pipeline_version  <code>instance-attribute</code>","text":"<pre><code>pipeline_version: str\n</code></pre> <p>Version of the pipeline used.</p>"},{"location":"ref/types/#evalio.types.Experiment.sequence","title":"sequence  <code>instance-attribute</code>","text":"<pre><code>sequence: str | Dataset\n</code></pre> <p>Dataset used to run the experiment.</p>"},{"location":"ref/types/#evalio.types.Experiment.sequence_length","title":"sequence_length  <code>instance-attribute</code>","text":"<pre><code>sequence_length: int\n</code></pre> <p>Length of the sequence</p>"},{"location":"ref/types/#evalio.types.Experiment.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: ExperimentStatus = NotRun\n</code></pre> <p>Status of the experiment, e.g. \"success\", \"failure\", etc.</p>"},{"location":"ref/types/#evalio.types.Experiment.total_elapsed","title":"total_elapsed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_elapsed: Optional[float] = None\n</code></pre> <p>Total time taken for the experiment, as a string.</p>"},{"location":"ref/types/#evalio.types.Experiment.from_pl_ds","title":"from_pl_ds  <code>classmethod</code>","text":"<pre><code>from_pl_ds(\n    pipe: type[Pipeline], ds_obj: Dataset, **kwargs: Any\n) -&gt; Self\n</code></pre> <p>Create an Experiment from a pipeline and dataset.</p> <p>Parameters:</p> <ul> <li> <code>pipe</code>               (<code>type[Pipeline]</code>)           \u2013            <p>The pipeline class.</p> </li> <li> <code>ds_obj</code>               (<code>Dataset</code>)           \u2013            <p>The dataset object.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the Experiment constructor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The created Experiment instance.</p> </li> </ul> Source code in <code>python/evalio/types/extended.py</code> <pre><code>@classmethod\ndef from_pl_ds(\n    cls, pipe: type[pl.Pipeline], ds_obj: ds.Dataset, **kwargs: Any\n) -&gt; Self:\n    \"\"\"Create an Experiment from a pipeline and dataset.\n\n    Args:\n        pipe (type[pl.Pipeline]): The pipeline class.\n        ds_obj (ds.Dataset): The dataset object.\n        **kwargs: Additional keyword arguments to pass to the Experiment constructor.\n\n    Returns:\n        Self: The created Experiment instance.\n    \"\"\"\n    return cls(\n        name=pipe.name(),\n        sequence=ds_obj,\n        sequence_length=len(ds_obj),\n        pipeline=pipe,\n        pipeline_version=pipe.version(),\n        pipeline_params=pipe.default_params() | kwargs,\n    )\n</code></pre>"},{"location":"ref/types/#evalio.types.Experiment.setup","title":"setup","text":"<pre><code>setup() -&gt; (\n    tuple[Pipeline, Dataset]\n    | SequenceNotFound\n    | PipelineNotFound\n)\n</code></pre> <p>Setup the experiment by initializing the pipeline and dataset.</p> <p>Parameters:</p> <ul> <li> <code>self</code>               (<code>Experiment</code>)           \u2013            <p>The experiment instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Pipeline, Dataset] | SequenceNotFound | PipelineNotFound</code>           \u2013            <p>Tuple containing the initialized pipeline and dataset, or an error if the pipeline or dataset could not be found or configured.</p> </li> </ul> Source code in <code>python/evalio/types/extended.py</code> <pre><code>def setup(\n    self,\n) -&gt; tuple[pl.Pipeline, ds.Dataset] | ds.SequenceNotFound | pl.PipelineNotFound:\n    \"\"\"Setup the experiment by initializing the pipeline and dataset.\n\n    Args:\n        self (Experiment): The experiment instance.\n\n    Returns:\n        Tuple containing the initialized pipeline and dataset, or an error if the pipeline or dataset could not be found or configured.\n    \"\"\"\n    if isinstance(self.pipeline, str):\n        ThisPipeline = pl.get_pipeline(self.pipeline)\n        if isinstance(ThisPipeline, pl.PipelineNotFound):\n            return ThisPipeline\n    else:\n        ThisPipeline = self.pipeline\n\n    if isinstance(self.sequence, ds.Dataset):\n        dataset = self.sequence\n    else:\n        dataset = ds.get_sequence(self.sequence)\n        if isinstance(dataset, ds.SequenceNotFound):\n            return dataset\n\n    pipe = ThisPipeline()\n\n    # Set user params\n    params = pipe.set_params(self.pipeline_params)\n    if len(params) &gt; 0:\n        for k, v in params.items():\n            print_warning(\n                f\"Pipeline {self.name} has unused parameters: {k}={v}. \"\n                \"Please check your configuration.\"\n            )\n\n    # Set dataset params\n    pipe.set_imu_params(dataset.imu_params())\n    pipe.set_lidar_params(dataset.lidar_params())\n    pipe.set_imu_T_lidar(dataset.imu_T_lidar())\n\n    # Initialize pipeline\n    pipe.initialize()\n\n    return pipe, dataset\n</code></pre>"},{"location":"ref/types/#evalio.types.ExperimentStatus","title":"ExperimentStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Status of the experiment.</p> Source code in <code>python/evalio/types/extended.py</code> <pre><code>class ExperimentStatus(Enum):\n    \"\"\"Status of the experiment.\"\"\"\n\n    Complete = \"complete\"\n    Fail = \"fail\"\n    Started = \"started\"\n    NotRun = \"not_run\"\n</code></pre>"},{"location":"ref/types/#evalio.types.FailedMetadataParse","title":"FailedMetadataParse","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when metadata parsing fails.</p> Source code in <code>python/evalio/types/base.py</code> <pre><code>class FailedMetadataParse(Exception):\n    \"\"\"Exception raised when metadata parsing fails.\"\"\"\n\n    def __init__(self, reason: str):\n        super().__init__(f\"Failed to parse metadata: {reason}\")\n        self.reason = reason\n</code></pre>"},{"location":"ref/types/#evalio.types.GroundTruth","title":"GroundTruth  <code>dataclass</code>","text":"<p>               Bases: <code>Metadata</code></p> <p>Metadata for ground truth trajectories.</p> <p>Attributes:</p> <ul> <li> <code>sequence</code>               (<code>str</code>)           \u2013            <p>Dataset used to run the experiment.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@dataclass(kw_only=True)\nclass GroundTruth(Metadata):\n    \"\"\"Metadata for ground truth trajectories.\"\"\"\n\n    sequence: str\n    \"\"\"Dataset used to run the experiment.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.GroundTruth.sequence","title":"sequence  <code>instance-attribute</code>","text":"<pre><code>sequence: str\n</code></pre> <p>Dataset used to run the experiment.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement","title":"ImuMeasurement","text":"<p>ImuMeasurement is a simple structure for storing an IMU measurement.</p> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>accel</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Accelerometer measurement as a 3D vector.</p> </li> <li> <code>gyro</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Gyroscope measurement as a 3D vector.</p> </li> <li> <code>stamp</code>               (<code>Stamp</code>)           \u2013            <p>Timestamp of the IMU measurement.</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class ImuMeasurement:\n    \"\"\"ImuMeasurement is a simple structure for storing an IMU measurement.\"\"\"\n\n    def __init__(self, stamp: Stamp, gyro: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], accel: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -&gt; None: ...\n\n    @property\n    def stamp(self) -&gt; Stamp:\n        \"\"\"Timestamp of the IMU measurement.\"\"\"\n\n    @property\n    def gyro(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n        \"\"\"Gyroscope measurement as a 3D vector.\"\"\"\n\n    @property\n    def accel(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n        \"\"\"Accelerometer measurement as a 3D vector.\"\"\"\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __getstate__(self) -&gt; tuple[Stamp, Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]]: ...\n\n    def __setstate__(self, arg: tuple[Stamp, Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')], Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.ImuMeasurement.accel","title":"accel  <code>property</code>","text":"<pre><code>accel: NDArray[float64]\n</code></pre> <p>Accelerometer measurement as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.gyro","title":"gyro  <code>property</code>","text":"<pre><code>gyro: NDArray[float64]\n</code></pre> <p>Gyroscope measurement as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.stamp","title":"stamp  <code>property</code>","text":"<pre><code>stamp: Stamp\n</code></pre> <p>Timestamp of the IMU measurement.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.ImuMeasurement.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.ImuParams","title":"ImuParams","text":"<p>ImuParams is a structure for storing the parameters of an IMU</p> <p>Methods:</p> <ul> <li> <code>down</code>             \u2013              <p>Simple helper for initializing with a <code>down</code> gravity vector.</p> </li> <li> <code>up</code>             \u2013              <p>Simple helper for initializing with an <code>up</code> gravity vector.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>accel</code>               (<code>float</code>)           \u2013            <p>Accelerometer standard deviation, in m/s^2/sqrt(Hz).</p> </li> <li> <code>accel_bias</code>               (<code>float</code>)           \u2013            <p>Accelerometer bias standard deviation, in m/s^3/sqrt(Hz).</p> </li> <li> <code>bias_init</code>               (<code>float</code>)           \u2013            <p>Initial bias standard deviation.</p> </li> <li> <code>brand</code>               (<code>str</code>)           \u2013            <p>Brand of the IMU sensor.</p> </li> <li> <code>gravity</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Gravity vector as a 3D vector.</p> </li> <li> <code>gyro</code>               (<code>float</code>)           \u2013            <p>Gyroscope standard deviation, in rad/s/sqrt(Hz).</p> </li> <li> <code>gyro_bias</code>               (<code>float</code>)           \u2013            <p>Gyroscope bias standard deviation, in rad/s^2/sqrt(Hz).</p> </li> <li> <code>integration</code>               (<code>float</code>)           \u2013            <p>Integration standard deviation.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>Model of the IMU sensor.</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class ImuParams:\n    \"\"\"ImuParams is a structure for storing the parameters of an IMU\"\"\"\n\n    def __init__(self, *, gyro: float = 1e-05, accel: float = 1e-05, gyro_bias: float = 1e-06, accel_bias: float = 1e-06, bias_init: float = 1e-07, integration: float = 1e-07, gravity: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')] = ..., brand: str = '-', model: str = '-') -&gt; None: ...\n\n    @staticmethod\n    def up() -&gt; ImuParams:\n        \"\"\"Simple helper for initializing with an `up` gravity vector.\"\"\"\n\n    @staticmethod\n    def down() -&gt; ImuParams:\n        \"\"\"Simple helper for initializing with a `down` gravity vector.\"\"\"\n\n    @property\n    def gyro(self) -&gt; float:\n        \"\"\"Gyroscope standard deviation, in rad/s/sqrt(Hz).\"\"\"\n\n    @property\n    def accel(self) -&gt; float:\n        \"\"\"Accelerometer standard deviation, in m/s^2/sqrt(Hz).\"\"\"\n\n    @property\n    def gyro_bias(self) -&gt; float:\n        \"\"\"Gyroscope bias standard deviation, in rad/s^2/sqrt(Hz).\"\"\"\n\n    @property\n    def accel_bias(self) -&gt; float:\n        \"\"\"Accelerometer bias standard deviation, in m/s^3/sqrt(Hz).\"\"\"\n\n    @property\n    def bias_init(self) -&gt; float:\n        \"\"\"Initial bias standard deviation.\"\"\"\n\n    @property\n    def integration(self) -&gt; float:\n        \"\"\"Integration standard deviation.\"\"\"\n\n    @property\n    def gravity(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n        \"\"\"Gravity vector as a 3D vector.\"\"\"\n\n    @property\n    def brand(self) -&gt; str:\n        \"\"\"Brand of the IMU sensor.\"\"\"\n\n    @property\n    def model(self) -&gt; str:\n        \"\"\"Model of the IMU sensor.\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.ImuParams.accel","title":"accel  <code>property</code>","text":"<pre><code>accel: float\n</code></pre> <p>Accelerometer standard deviation, in m/s^2/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.accel_bias","title":"accel_bias  <code>property</code>","text":"<pre><code>accel_bias: float\n</code></pre> <p>Accelerometer bias standard deviation, in m/s^3/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.bias_init","title":"bias_init  <code>property</code>","text":"<pre><code>bias_init: float\n</code></pre> <p>Initial bias standard deviation.</p>"},{"location":"ref/types/#evalio.types.ImuParams.brand","title":"brand  <code>property</code>","text":"<pre><code>brand: str\n</code></pre> <p>Brand of the IMU sensor.</p>"},{"location":"ref/types/#evalio.types.ImuParams.gravity","title":"gravity  <code>property</code>","text":"<pre><code>gravity: NDArray[float64]\n</code></pre> <p>Gravity vector as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.ImuParams.gyro","title":"gyro  <code>property</code>","text":"<pre><code>gyro: float\n</code></pre> <p>Gyroscope standard deviation, in rad/s/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.gyro_bias","title":"gyro_bias  <code>property</code>","text":"<pre><code>gyro_bias: float\n</code></pre> <p>Gyroscope bias standard deviation, in rad/s^2/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.integration","title":"integration  <code>property</code>","text":"<pre><code>integration: float\n</code></pre> <p>Integration standard deviation.</p>"},{"location":"ref/types/#evalio.types.ImuParams.model","title":"model  <code>property</code>","text":"<pre><code>model: str\n</code></pre> <p>Model of the IMU sensor.</p>"},{"location":"ref/types/#evalio.types.ImuParams.down","title":"down  <code>staticmethod</code>","text":"<pre><code>down() -&gt; ImuParams\n</code></pre> <p>Simple helper for initializing with a <code>down</code> gravity vector.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef down() -&gt; ImuParams:\n    \"\"\"Simple helper for initializing with a `down` gravity vector.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.ImuParams.up","title":"up  <code>staticmethod</code>","text":"<pre><code>up() -&gt; ImuParams\n</code></pre> <p>Simple helper for initializing with an <code>up</code> gravity vector.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef up() -&gt; ImuParams:\n    \"\"\"Simple helper for initializing with an `up` gravity vector.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarMeasurement","title":"LidarMeasurement","text":"<p>LidarMeasurement is a structure for storing a point cloud measurement, with a timestamp and a vector of points.</p> <p>Note, the stamp always represents the start of the scan. Additionally, the points are always in row major format.</p> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> <li> <code>to_vec_positions</code>             \u2013              <p>Convert the point cloud to a (n,3) numpy array.</p> </li> <li> <code>to_vec_stamps</code>             \u2013              <p>Convert the point stamps to a list of durations.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>points</code>               (<code>list[Point]</code>)           \u2013            <p>List of points in the point cloud. Note, this is always in row major format.</p> </li> <li> <code>stamp</code>               (<code>Stamp</code>)           \u2013            <p>Timestamp of the point cloud, always at the start of the scan.</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class LidarMeasurement:\n    \"\"\"\n    LidarMeasurement is a structure for storing a point cloud measurement, with a timestamp and a vector of points.\n\n    Note, the stamp always represents the _start_ of the scan. Additionally, the points are always in row major format.\n    \"\"\"\n\n    @overload\n    def __init__(self, stamp: Stamp) -&gt; None: ...\n\n    @overload\n    def __init__(self, stamp: Stamp, points: Sequence[Point]) -&gt; None: ...\n\n    @property\n    def stamp(self) -&gt; Stamp:\n        \"\"\"Timestamp of the point cloud, always at the start of the scan.\"\"\"\n\n    @stamp.setter\n    def stamp(self, arg: Stamp, /) -&gt; None: ...\n\n    @property\n    def points(self) -&gt; list[Point]:\n        \"\"\"\n        List of points in the point cloud. Note, this is always in row major format.\n        \"\"\"\n\n    @points.setter\n    def points(self, arg: Sequence[Point], /) -&gt; None: ...\n\n    def to_vec_positions(self) -&gt; list[Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]]:\n        \"\"\"Convert the point cloud to a (n,3) numpy array.\"\"\"\n\n    def to_vec_stamps(self) -&gt; list[float]:\n        \"\"\"Convert the point stamps to a list of durations.\"\"\"\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __getstate__(self) -&gt; tuple[Stamp, list[Point]]: ...\n\n    def __setstate__(self, arg: tuple[Stamp, Sequence[Point]], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarMeasurement.points","title":"points  <code>property</code> <code>writable</code>","text":"<pre><code>points: list[Point]\n</code></pre> <p>List of points in the point cloud. Note, this is always in row major format.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.stamp","title":"stamp  <code>property</code> <code>writable</code>","text":"<pre><code>stamp: Stamp\n</code></pre> <p>Timestamp of the point cloud, always at the start of the scan.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarMeasurement.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarMeasurement.to_vec_positions","title":"to_vec_positions","text":"<pre><code>to_vec_positions() -&gt; list[NDArray[float64]]\n</code></pre> <p>Convert the point cloud to a (n,3) numpy array.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def to_vec_positions(self) -&gt; list[Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]]:\n    \"\"\"Convert the point cloud to a (n,3) numpy array.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarMeasurement.to_vec_stamps","title":"to_vec_stamps","text":"<pre><code>to_vec_stamps() -&gt; list[float]\n</code></pre> <p>Convert the point stamps to a list of durations.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def to_vec_stamps(self) -&gt; list[float]:\n    \"\"\"Convert the point stamps to a list of durations.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarParams","title":"LidarParams","text":"<p>LidarParams is a structure for storing the parameters of a lidar sensor.</p> <p>Methods:</p> <ul> <li> <code>delta_time</code>             \u2013              <p>Get the time between two consecutive scans as a Duration. Inverse of the rate.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>brand</code>               (<code>str</code>)           \u2013            <p>Brand of the lidar sensor.</p> </li> <li> <code>max_range</code>               (<code>float</code>)           \u2013            <p>Maximum range of the lidar sensor, in meters.</p> </li> <li> <code>min_range</code>               (<code>float</code>)           \u2013            <p>Minimum range of the lidar sensor, in meters.</p> </li> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>Model of the lidar sensor.</p> </li> <li> <code>num_columns</code>               (<code>int</code>)           \u2013            <p>Number of columns in the point cloud, also known as the number of points per scanline.</p> </li> <li> <code>num_rows</code>               (<code>int</code>)           \u2013            <p>Number of rows in the point cloud, also known as the scanlines.</p> </li> <li> <code>rate</code>               (<code>float</code>)           \u2013            <p>Rate of the lidar sensor, in Hz.</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class LidarParams:\n    \"\"\"\n    LidarParams is a structure for storing the parameters of a lidar sensor.\n    \"\"\"\n\n    def __init__(self, *, num_rows: int, num_columns: int, min_range: float, max_range: float, rate: float = 10.0, brand: str = '-', model: str = '-') -&gt; None: ...\n\n    @property\n    def num_rows(self) -&gt; int:\n        \"\"\"Number of rows in the point cloud, also known as the scanlines.\"\"\"\n\n    @property\n    def num_columns(self) -&gt; int:\n        \"\"\"\n        Number of columns in the point cloud, also known as the number of points per scanline.\n        \"\"\"\n\n    @property\n    def min_range(self) -&gt; float:\n        \"\"\"Minimum range of the lidar sensor, in meters.\"\"\"\n\n    @property\n    def max_range(self) -&gt; float:\n        \"\"\"Maximum range of the lidar sensor, in meters.\"\"\"\n\n    @property\n    def rate(self) -&gt; float:\n        \"\"\"Rate of the lidar sensor, in Hz.\"\"\"\n\n    @property\n    def brand(self) -&gt; str:\n        \"\"\"Brand of the lidar sensor.\"\"\"\n\n    @property\n    def model(self) -&gt; str:\n        \"\"\"Model of the lidar sensor.\"\"\"\n\n    def delta_time(self) -&gt; Duration:\n        \"\"\"\n        Get the time between two consecutive scans as a Duration. Inverse of the rate.\n        \"\"\"\n\n    def __repr__(self) -&gt; str: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.LidarParams.brand","title":"brand  <code>property</code>","text":"<pre><code>brand: str\n</code></pre> <p>Brand of the lidar sensor.</p>"},{"location":"ref/types/#evalio.types.LidarParams.max_range","title":"max_range  <code>property</code>","text":"<pre><code>max_range: float\n</code></pre> <p>Maximum range of the lidar sensor, in meters.</p>"},{"location":"ref/types/#evalio.types.LidarParams.min_range","title":"min_range  <code>property</code>","text":"<pre><code>min_range: float\n</code></pre> <p>Minimum range of the lidar sensor, in meters.</p>"},{"location":"ref/types/#evalio.types.LidarParams.model","title":"model  <code>property</code>","text":"<pre><code>model: str\n</code></pre> <p>Model of the lidar sensor.</p>"},{"location":"ref/types/#evalio.types.LidarParams.num_columns","title":"num_columns  <code>property</code>","text":"<pre><code>num_columns: int\n</code></pre> <p>Number of columns in the point cloud, also known as the number of points per scanline.</p>"},{"location":"ref/types/#evalio.types.LidarParams.num_rows","title":"num_rows  <code>property</code>","text":"<pre><code>num_rows: int\n</code></pre> <p>Number of rows in the point cloud, also known as the scanlines.</p>"},{"location":"ref/types/#evalio.types.LidarParams.rate","title":"rate  <code>property</code>","text":"<pre><code>rate: float\n</code></pre> <p>Rate of the lidar sensor, in Hz.</p>"},{"location":"ref/types/#evalio.types.LidarParams.delta_time","title":"delta_time","text":"<pre><code>delta_time() -&gt; Duration\n</code></pre> <p>Get the time between two consecutive scans as a Duration. Inverse of the rate.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def delta_time(self) -&gt; Duration:\n    \"\"\"\n    Get the time between two consecutive scans as a Duration. Inverse of the rate.\n    \"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Metadata","title":"Metadata  <code>dataclass</code>","text":"<p>Base class for metadata associated with a trajectory.</p> <p>Methods:</p> <ul> <li> <code>from_dict</code>             \u2013              <p>Create an instance of the metadata class from a dictionary.</p> </li> <li> <code>from_yaml</code>             \u2013              <p>Create an instance of the metadata class from a YAML string.</p> </li> <li> <code>tag</code>             \u2013              <p>Get the tag for the metadata class. Will be used for serialization and deserialization.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Convert the metadata instance to a dictionary.</p> </li> <li> <code>to_yaml</code>             \u2013              <p>Convert the metadata instance to a YAML string.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>file</code>               (<code>Optional[Path]</code>)           \u2013            <p>File where the metadata was loaded to and from, if any.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@dataclass(kw_only=True)\nclass Metadata:\n    \"\"\"Base class for metadata associated with a trajectory.\"\"\"\n\n    file: Optional[Path] = None\n    \"\"\"File where the metadata was loaded to and from, if any.\"\"\"\n    _registry: ClassVar[dict[str, type[Self]]] = {}\n\n    def __init_subclass__(cls) -&gt; None:\n        cls._registry[cls.tag()] = cls\n\n    @classmethod\n    def tag(cls) -&gt; str:\n        \"\"\"Get the tag for the metadata class. Will be used for serialization and deserialization.\n\n        Returns:\n            The tag for the metadata class.\n        \"\"\"\n        return pascal_to_snake(cls.__name__)\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Create an instance of the metadata class from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The dictionary containing the metadata.\n\n        Returns:\n            An instance of the metadata class.\n        \"\"\"\n        if \"type\" in data:\n            del data[\"type\"]\n        return cls(**data)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the metadata instance to a dictionary.\n\n        Returns:\n            The dictionary representation of the metadata.\n        \"\"\"\n        d = asdict(self)\n        d[\"type\"] = self.tag()  # add type tag for deserialization\n        del d[\"file\"]  # don't serialize the file path\n        return d\n\n    def to_yaml(self) -&gt; str:\n        \"\"\"Convert the metadata instance to a YAML string.\n\n        Returns:\n            The YAML representation of the metadata.\n        \"\"\"\n        data = self.to_dict()\n        return yaml.safe_dump(data)\n\n    @classmethod\n    def from_yaml(cls, yaml_str: str) -&gt; Metadata | FailedMetadataParse:\n        \"\"\"Create an instance of the metadata class from a YAML string.\n\n        Will return the appropriate subclass based on the \"type\" field in the YAML.\n\n        Args:\n            yaml_str (str): The YAML string containing the metadata.\n\n        Returns:\n            An instance of the metadata class or an error.\n        \"\"\"\n        try:\n            Loader = yaml.CSafeLoader\n        except Exception as _:\n            print_warning(\"Failed to import yaml.CSafeLoader, trying yaml.SafeLoader\")\n            Loader = yaml.SafeLoader\n\n        data = yaml.load(yaml_str, Loader=Loader)\n\n        if data is None:\n            return FailedMetadataParse(\"Metadata failed to parse.\")\n        elif \"type\" not in data:\n            return FailedMetadataParse(\"No type field found in metadata.\")\n\n        for name, subclass in cls._registry.items():\n            if data[\"type\"] == name:\n                try:\n                    return subclass.from_dict(data)\n                except Exception as e:\n                    return FailedMetadataParse(f\"Failed to parse {name}: {e}\")\n\n        return FailedMetadataParse(f\"Unknown metadata type '{data['type']}'\")\n</code></pre>"},{"location":"ref/types/#evalio.types.Metadata.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Optional[Path] = None\n</code></pre> <p>File where the metadata was loaded to and from, if any.</p>"},{"location":"ref/types/#evalio.types.Metadata.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; Self\n</code></pre> <p>Create an instance of the metadata class from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary containing the metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instance of the metadata class.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Create an instance of the metadata class from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The dictionary containing the metadata.\n\n    Returns:\n        An instance of the metadata class.\n    \"\"\"\n    if \"type\" in data:\n        del data[\"type\"]\n    return cls(**data)\n</code></pre>"},{"location":"ref/types/#evalio.types.Metadata.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(yaml_str: str) -&gt; Metadata | FailedMetadataParse\n</code></pre> <p>Create an instance of the metadata class from a YAML string.</p> <p>Will return the appropriate subclass based on the \"type\" field in the YAML.</p> <p>Parameters:</p> <ul> <li> <code>yaml_str</code>               (<code>str</code>)           \u2013            <p>The YAML string containing the metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Metadata | FailedMetadataParse</code>           \u2013            <p>An instance of the metadata class or an error.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml_str: str) -&gt; Metadata | FailedMetadataParse:\n    \"\"\"Create an instance of the metadata class from a YAML string.\n\n    Will return the appropriate subclass based on the \"type\" field in the YAML.\n\n    Args:\n        yaml_str (str): The YAML string containing the metadata.\n\n    Returns:\n        An instance of the metadata class or an error.\n    \"\"\"\n    try:\n        Loader = yaml.CSafeLoader\n    except Exception as _:\n        print_warning(\"Failed to import yaml.CSafeLoader, trying yaml.SafeLoader\")\n        Loader = yaml.SafeLoader\n\n    data = yaml.load(yaml_str, Loader=Loader)\n\n    if data is None:\n        return FailedMetadataParse(\"Metadata failed to parse.\")\n    elif \"type\" not in data:\n        return FailedMetadataParse(\"No type field found in metadata.\")\n\n    for name, subclass in cls._registry.items():\n        if data[\"type\"] == name:\n            try:\n                return subclass.from_dict(data)\n            except Exception as e:\n                return FailedMetadataParse(f\"Failed to parse {name}: {e}\")\n\n    return FailedMetadataParse(f\"Unknown metadata type '{data['type']}'\")\n</code></pre>"},{"location":"ref/types/#evalio.types.Metadata.tag","title":"tag  <code>classmethod</code>","text":"<pre><code>tag() -&gt; str\n</code></pre> <p>Get the tag for the metadata class. Will be used for serialization and deserialization.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The tag for the metadata class.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@classmethod\ndef tag(cls) -&gt; str:\n    \"\"\"Get the tag for the metadata class. Will be used for serialization and deserialization.\n\n    Returns:\n        The tag for the metadata class.\n    \"\"\"\n    return pascal_to_snake(cls.__name__)\n</code></pre>"},{"location":"ref/types/#evalio.types.Metadata.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the metadata instance to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The dictionary representation of the metadata.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the metadata instance to a dictionary.\n\n    Returns:\n        The dictionary representation of the metadata.\n    \"\"\"\n    d = asdict(self)\n    d[\"type\"] = self.tag()  # add type tag for deserialization\n    del d[\"file\"]  # don't serialize the file path\n    return d\n</code></pre>"},{"location":"ref/types/#evalio.types.Metadata.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml() -&gt; str\n</code></pre> <p>Convert the metadata instance to a YAML string.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation of the metadata.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    \"\"\"Convert the metadata instance to a YAML string.\n\n    Returns:\n        The YAML representation of the metadata.\n    \"\"\"\n    data = self.to_dict()\n    return yaml.safe_dump(data)\n</code></pre>"},{"location":"ref/types/#evalio.types.Point","title":"Point","text":"<p>Point is the general point structure in evalio, with common point cloud attributes included.</p> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__init__</code>             \u2013              <p>Create a Point from x, y, z, intensity, t, range, row, col</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Column index of the point in the point cloud.</p> </li> <li> <code>intensity</code>               (<code>float</code>)           \u2013            <p>Intensity value as a float.</p> </li> <li> <code>range</code>               (<code>int</code>)           \u2013            <p>Range value as a uint32.</p> </li> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Row index of the point in the point cloud. Also known as the scanline index.</p> </li> <li> <code>t</code>               (<code>Duration</code>)           \u2013            <p>Timestamp of the point as a Duration. In evalio, this is always relative to the point cloud stamp, which occurs at the start of the scan.</p> </li> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>X coordinate</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>Y coordinate</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>Z coordinate</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class Point:\n    \"\"\"\n    Point is the general point structure in evalio, with common point cloud attributes included.\n    \"\"\"\n\n    def __init__(self, *, x: float = 0, y: float = 0, z: float = 0, intensity: float = 0, t: Duration = ..., range: int = 0, row: int = 0, col: int = 0) -&gt; None:\n        \"\"\"Create a Point from x, y, z, intensity, t, range, row, col\"\"\"\n\n    @property\n    def x(self) -&gt; float:\n        \"\"\"X coordinate\"\"\"\n\n    @x.setter\n    def x(self, arg: float, /) -&gt; None: ...\n\n    @property\n    def y(self) -&gt; float:\n        \"\"\"Y coordinate\"\"\"\n\n    @y.setter\n    def y(self, arg: float, /) -&gt; None: ...\n\n    @property\n    def z(self) -&gt; float:\n        \"\"\"Z coordinate\"\"\"\n\n    @z.setter\n    def z(self, arg: float, /) -&gt; None: ...\n\n    @property\n    def intensity(self) -&gt; float:\n        \"\"\"Intensity value as a float.\"\"\"\n\n    @intensity.setter\n    def intensity(self, arg: float, /) -&gt; None: ...\n\n    @property\n    def range(self) -&gt; int:\n        \"\"\"Range value as a uint32.\"\"\"\n\n    @range.setter\n    def range(self, arg: int, /) -&gt; None: ...\n\n    @property\n    def t(self) -&gt; Duration:\n        \"\"\"\n        Timestamp of the point as a Duration. In evalio, this is always relative to the point cloud stamp, which occurs at the start of the scan.\n        \"\"\"\n\n    @t.setter\n    def t(self, arg: Duration, /) -&gt; None: ...\n\n    @property\n    def row(self) -&gt; int:\n        \"\"\"\n        Row index of the point in the point cloud. Also known as the scanline index.\n        \"\"\"\n\n    @row.setter\n    def row(self, arg: int, /) -&gt; None: ...\n\n    @property\n    def col(self) -&gt; int:\n        \"\"\"Column index of the point in the point cloud.\"\"\"\n\n    @col.setter\n    def col(self, arg: int, /) -&gt; None: ...\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __getstate__(self) -&gt; tuple[float, float, float, float, Duration, int, int, int]: ...\n\n    def __setstate__(self, arg: tuple[float, float, float, float, Duration, int, int, int], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.Point.col","title":"col  <code>property</code> <code>writable</code>","text":"<pre><code>col: int\n</code></pre> <p>Column index of the point in the point cloud.</p>"},{"location":"ref/types/#evalio.types.Point.intensity","title":"intensity  <code>property</code> <code>writable</code>","text":"<pre><code>intensity: float\n</code></pre> <p>Intensity value as a float.</p>"},{"location":"ref/types/#evalio.types.Point.range","title":"range  <code>property</code> <code>writable</code>","text":"<pre><code>range: int\n</code></pre> <p>Range value as a uint32.</p>"},{"location":"ref/types/#evalio.types.Point.row","title":"row  <code>property</code> <code>writable</code>","text":"<pre><code>row: int\n</code></pre> <p>Row index of the point in the point cloud. Also known as the scanline index.</p>"},{"location":"ref/types/#evalio.types.Point.t","title":"t  <code>property</code> <code>writable</code>","text":"<pre><code>t: Duration\n</code></pre> <p>Timestamp of the point as a Duration. In evalio, this is always relative to the point cloud stamp, which occurs at the start of the scan.</p>"},{"location":"ref/types/#evalio.types.Point.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x: float\n</code></pre> <p>X coordinate</p>"},{"location":"ref/types/#evalio.types.Point.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y: float\n</code></pre> <p>Y coordinate</p>"},{"location":"ref/types/#evalio.types.Point.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z: float\n</code></pre> <p>Z coordinate</p>"},{"location":"ref/types/#evalio.types.Point.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Point.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    x: float = 0,\n    y: float = 0,\n    z: float = 0,\n    intensity: float = 0,\n    t: Duration = ...,\n    range: int = 0,\n    row: int = 0,\n    col: int = 0,\n) -&gt; None\n</code></pre> <p>Create a Point from x, y, z, intensity, t, range, row, col</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __init__(self, *, x: float = 0, y: float = 0, z: float = 0, intensity: float = 0, t: Duration = ..., range: int = 0, row: int = 0, col: int = 0) -&gt; None:\n    \"\"\"Create a Point from x, y, z, intensity, t, range, row, col\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Point.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3","title":"SE3","text":"<p>SE3 class for representing a 3D rigid body transformation using a quaternion and a translation vector.</p> <p>This is outfitted with some basic functionality, but is mostly intended for storage and converting between types.</p> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__mul__</code>             \u2013              <p>Compose two rigid body transformations.</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> <li> <code>distance</code>             \u2013              <p>Compute the distance between two SE3s.</p> </li> <li> <code>error</code>             \u2013              <p>Compute the rotational (degrees) and translational (meters) error between two SE3s as a tuple (rot, trans).</p> </li> <li> <code>exp</code>             \u2013              <p>Create a SE3 from a 3D vector.</p> </li> <li> <code>fromMat</code>             \u2013              <p>Create a SE3 from a 4x4 transformation matrix.</p> </li> <li> <code>identity</code>             \u2013              <p>Create an identity SE3.</p> </li> <li> <code>inverse</code>             \u2013              <p>Compute the inverse.</p> </li> <li> <code>log</code>             \u2013              <p>Compute the logarithm of the transformation.</p> </li> <li> <code>toMat</code>             \u2013              <p>Convert to a 4x4 matrix.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>rot</code>               (<code>SO3</code>)           \u2013            <p>Rotation as a SO3 object.</p> </li> <li> <code>trans</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Translation as a 3D vector.</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class SE3:\n    \"\"\"\n    SE3 class for representing a 3D rigid body transformation using a quaternion and a translation vector.\n\n    This is outfitted with some basic functionality, but is mostly intended for storage and converting between types.\n    \"\"\"\n\n    @overload\n    def __init__(self, rot: SO3, trans: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -&gt; None:\n        \"\"\"Create a SE3 from a rotation and translation.\"\"\"\n\n    @overload\n    def __init__(self, other: SE3) -&gt; None:\n        \"\"\"Copy constructor for SE3.\"\"\"\n\n    @staticmethod\n    def identity() -&gt; SE3:\n        \"\"\"Create an identity SE3.\"\"\"\n\n    @staticmethod\n    def fromMat(mat: Annotated[NDArray[numpy.float64], dict(shape=(4, 4), order='F')]) -&gt; SE3:\n        \"\"\"Create a SE3 from a 4x4 transformation matrix.\"\"\"\n\n    @property\n    def rot(self) -&gt; SO3:\n        \"\"\"Rotation as a SO3 object.\"\"\"\n\n    @property\n    def trans(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n        \"\"\"Translation as a 3D vector.\"\"\"\n\n    def toMat(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(4, 4), order='F')]:\n        \"\"\"Convert to a 4x4 matrix.\"\"\"\n\n    def inverse(self) -&gt; SE3:\n        \"\"\"Compute the inverse.\"\"\"\n\n    @staticmethod\n    def error(a: SE3, b: SE3) -&gt; tuple[float, float]:\n        \"\"\"\n        Compute the rotational (degrees) and translational (meters) error between two SE3s as a tuple (rot, trans).\n        \"\"\"\n\n    @staticmethod\n    def distance(a: SE3, b: SE3) -&gt; float:\n        \"\"\"Compute the distance between two SE3s.\"\"\"\n\n    @staticmethod\n    def exp(xi: Annotated[NDArray[numpy.float64], dict(shape=(6), order='C')]) -&gt; SE3:\n        \"\"\"Create a SE3 from a 3D vector.\"\"\"\n\n    def log(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(6), order='C')]:\n        \"\"\"Compute the logarithm of the transformation.\"\"\"\n\n    def __mul__(self, arg: SE3, /) -&gt; SE3:\n        \"\"\"Compose two rigid body transformations.\"\"\"\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __copy__(self) -&gt; SE3: ...\n\n    def __deepcopy__(self, memo: dict[Any, Any]) -&gt; SE3: ...\n\n    def __getstate__(self) -&gt; tuple[float, float, float, float, float, float, float]: ...\n\n    def __setstate__(self, arg: tuple[float, float, float, float, float, float, float], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.rot","title":"rot  <code>property</code>","text":"<pre><code>rot: SO3\n</code></pre> <p>Rotation as a SO3 object.</p>"},{"location":"ref/types/#evalio.types.SE3.trans","title":"trans  <code>property</code>","text":"<pre><code>trans: NDArray[float64]\n</code></pre> <p>Translation as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.SE3.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.__mul__","title":"__mul__","text":"<pre><code>__mul__(arg: SE3) -&gt; SE3\n</code></pre> <p>Compose two rigid body transformations.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __mul__(self, arg: SE3, /) -&gt; SE3:\n    \"\"\"Compose two rigid body transformations.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.distance","title":"distance  <code>staticmethod</code>","text":"<pre><code>distance(a: SE3, b: SE3) -&gt; float\n</code></pre> <p>Compute the distance between two SE3s.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef distance(a: SE3, b: SE3) -&gt; float:\n    \"\"\"Compute the distance between two SE3s.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.error","title":"error  <code>staticmethod</code>","text":"<pre><code>error(a: SE3, b: SE3) -&gt; tuple[float, float]\n</code></pre> <p>Compute the rotational (degrees) and translational (meters) error between two SE3s as a tuple (rot, trans).</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef error(a: SE3, b: SE3) -&gt; tuple[float, float]:\n    \"\"\"\n    Compute the rotational (degrees) and translational (meters) error between two SE3s as a tuple (rot, trans).\n    \"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.exp","title":"exp  <code>staticmethod</code>","text":"<pre><code>exp(xi: NDArray[float64]) -&gt; SE3\n</code></pre> <p>Create a SE3 from a 3D vector.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef exp(xi: Annotated[NDArray[numpy.float64], dict(shape=(6), order='C')]) -&gt; SE3:\n    \"\"\"Create a SE3 from a 3D vector.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.fromMat","title":"fromMat  <code>staticmethod</code>","text":"<pre><code>fromMat(mat: NDArray[float64]) -&gt; SE3\n</code></pre> <p>Create a SE3 from a 4x4 transformation matrix.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef fromMat(mat: Annotated[NDArray[numpy.float64], dict(shape=(4, 4), order='F')]) -&gt; SE3:\n    \"\"\"Create a SE3 from a 4x4 transformation matrix.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.identity","title":"identity  <code>staticmethod</code>","text":"<pre><code>identity() -&gt; SE3\n</code></pre> <p>Create an identity SE3.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef identity() -&gt; SE3:\n    \"\"\"Create an identity SE3.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; SE3\n</code></pre> <p>Compute the inverse.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def inverse(self) -&gt; SE3:\n    \"\"\"Compute the inverse.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.log","title":"log","text":"<pre><code>log() -&gt; NDArray[float64]\n</code></pre> <p>Compute the logarithm of the transformation.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def log(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(6), order='C')]:\n    \"\"\"Compute the logarithm of the transformation.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SE3.toMat","title":"toMat","text":"<pre><code>toMat() -&gt; NDArray[float64]\n</code></pre> <p>Convert to a 4x4 matrix.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def toMat(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(4, 4), order='F')]:\n    \"\"\"Convert to a 4x4 matrix.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3","title":"SO3","text":"<p>SO3 class for representing a 3D rotation using a quaternion.</p> <p>This is outfitted with some basic functionality, but mostly intended for storage and converting between types.</p> <p>Methods:</p> <ul> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__mul__</code>             \u2013              <p>Compose two rotations.</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> <li> <code>exp</code>             \u2013              <p>Create a rotation from a 3D vector.</p> </li> <li> <code>fromMat</code>             \u2013              <p>Create a rotation from a 3x3 rotation matrix.</p> </li> <li> <code>identity</code>             \u2013              <p>Create an identity rotation.</p> </li> <li> <code>inverse</code>             \u2013              <p>Compute the inverse of the rotation.</p> </li> <li> <code>log</code>             \u2013              <p>Compute the logarithm of the rotation.</p> </li> <li> <code>rotate</code>             \u2013              <p>Rotate a 3D vector by the rotation.</p> </li> <li> <code>toMat</code>             \u2013              <p>Convert the rotation to a 3x3 matrix.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>qw</code>               (<code>float</code>)           \u2013            <p>Scalar component of the quaternion.</p> </li> <li> <code>qx</code>               (<code>float</code>)           \u2013            <p>X component of the quaternion.</p> </li> <li> <code>qy</code>               (<code>float</code>)           \u2013            <p>Y component of the quaternion.</p> </li> <li> <code>qz</code>               (<code>float</code>)           \u2013            <p>Z component of the quaternion.</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class SO3:\n    \"\"\"\n    SO3 class for representing a 3D rotation using a quaternion.\n\n    This is outfitted with some basic functionality, but mostly intended for storage and converting between types.\n    \"\"\"\n\n    def __init__(self, *, qx: float, qy: float, qz: float, qw: float) -&gt; None: ...\n\n    @property\n    def qx(self) -&gt; float:\n        \"\"\"X component of the quaternion.\"\"\"\n\n    @property\n    def qy(self) -&gt; float:\n        \"\"\"Y component of the quaternion.\"\"\"\n\n    @property\n    def qz(self) -&gt; float:\n        \"\"\"Z component of the quaternion.\"\"\"\n\n    @property\n    def qw(self) -&gt; float:\n        \"\"\"Scalar component of the quaternion.\"\"\"\n\n    @staticmethod\n    def identity() -&gt; SO3:\n        \"\"\"Create an identity rotation.\"\"\"\n\n    @staticmethod\n    def fromMat(mat: Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]) -&gt; SO3:\n        \"\"\"Create a rotation from a 3x3 rotation matrix.\"\"\"\n\n    @staticmethod\n    def exp(v: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -&gt; SO3:\n        \"\"\"Create a rotation from a 3D vector.\"\"\"\n\n    def inverse(self) -&gt; SO3:\n        \"\"\"Compute the inverse of the rotation.\"\"\"\n\n    def log(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n        \"\"\"Compute the logarithm of the rotation.\"\"\"\n\n    def toMat(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]:\n        \"\"\"Convert the rotation to a 3x3 matrix.\"\"\"\n\n    def rotate(self, v: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n        \"\"\"Rotate a 3D vector by the rotation.\"\"\"\n\n    def __mul__(self, arg: SO3, /) -&gt; SO3:\n        \"\"\"Compose two rotations.\"\"\"\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __copy__(self) -&gt; SO3: ...\n\n    def __deepcopy__(self, memo: dict[Any, Any]) -&gt; SO3: ...\n\n    def __getstate__(self) -&gt; tuple[float, float, float, float]: ...\n\n    def __setstate__(self, arg: tuple[float, float, float, float], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.qw","title":"qw  <code>property</code>","text":"<pre><code>qw: float\n</code></pre> <p>Scalar component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.qx","title":"qx  <code>property</code>","text":"<pre><code>qx: float\n</code></pre> <p>X component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.qy","title":"qy  <code>property</code>","text":"<pre><code>qy: float\n</code></pre> <p>Y component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.qz","title":"qz  <code>property</code>","text":"<pre><code>qz: float\n</code></pre> <p>Z component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.__mul__","title":"__mul__","text":"<pre><code>__mul__(arg: SO3) -&gt; SO3\n</code></pre> <p>Compose two rotations.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __mul__(self, arg: SO3, /) -&gt; SO3:\n    \"\"\"Compose two rotations.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.exp","title":"exp  <code>staticmethod</code>","text":"<pre><code>exp(v: NDArray[float64]) -&gt; SO3\n</code></pre> <p>Create a rotation from a 3D vector.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef exp(v: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -&gt; SO3:\n    \"\"\"Create a rotation from a 3D vector.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.fromMat","title":"fromMat  <code>staticmethod</code>","text":"<pre><code>fromMat(mat: NDArray[float64]) -&gt; SO3\n</code></pre> <p>Create a rotation from a 3x3 rotation matrix.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef fromMat(mat: Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]) -&gt; SO3:\n    \"\"\"Create a rotation from a 3x3 rotation matrix.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.identity","title":"identity  <code>staticmethod</code>","text":"<pre><code>identity() -&gt; SO3\n</code></pre> <p>Create an identity rotation.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef identity() -&gt; SO3:\n    \"\"\"Create an identity rotation.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; SO3\n</code></pre> <p>Compute the inverse of the rotation.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def inverse(self) -&gt; SO3:\n    \"\"\"Compute the inverse of the rotation.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.log","title":"log","text":"<pre><code>log() -&gt; NDArray[float64]\n</code></pre> <p>Compute the logarithm of the rotation.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def log(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n    \"\"\"Compute the logarithm of the rotation.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.rotate","title":"rotate","text":"<pre><code>rotate(v: NDArray[float64]) -&gt; NDArray[float64]\n</code></pre> <p>Rotate a 3D vector by the rotation.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def rotate(self, v: Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3), order='C')]:\n    \"\"\"Rotate a 3D vector by the rotation.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.SO3.toMat","title":"toMat","text":"<pre><code>toMat() -&gt; NDArray[float64]\n</code></pre> <p>Convert the rotation to a 3x3 matrix.</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def toMat(self) -&gt; Annotated[NDArray[numpy.float64], dict(shape=(3, 3), order='F')]:\n    \"\"\"Convert the rotation to a 3x3 matrix.\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp","title":"Stamp","text":"<p>Stamp class for representing an absolute point in time.</p> <p>Uses uint32 as the underlying data storage for seconds and nanoseconds.</p> <p>Methods:</p> <ul> <li> <code>__add__</code>             \u2013              <p>Add a Duration to a Stamp</p> </li> <li> <code>__eq__</code>             \u2013              <p>Check for equality</p> </li> <li> <code>__gt__</code>             \u2013              <p>Compare two Stamps to see which happened first</p> </li> <li> <code>__lt__</code>             \u2013              <p>Compare two Stamps to see which happened first</p> </li> <li> <code>__ne__</code>             \u2013              <p>Check for inequality</p> </li> <li> <code>from_nsec</code>             \u2013              <p>Create a Stamp from nanoseconds</p> </li> <li> <code>from_sec</code>             \u2013              <p>Create a Stamp from seconds</p> </li> <li> <code>to_nsec</code>             \u2013              <p>Convert to nanoseconds</p> </li> <li> <code>to_sec</code>             \u2013              <p>Convert to seconds</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>nsec</code>               (<code>int</code>)           \u2013            <p>Underlying nanoseconds storage</p> </li> <li> <code>sec</code>               (<code>int</code>)           \u2013            <p>Underlying seconds storage</p> </li> </ul> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>class Stamp:\n    \"\"\"\n    Stamp class for representing an absolute point in time.\n\n    Uses uint32 as the underlying data storage for seconds and nanoseconds.\n    \"\"\"\n\n    @overload\n    def __init__(self, *, sec: int, nsec: int) -&gt; None:\n        \"\"\"Create a Stamp from seconds and nanoseconds\"\"\"\n\n    @overload\n    def __init__(self, other: Stamp) -&gt; None:\n        \"\"\"Copy constructor for Stamp.\"\"\"\n\n    @staticmethod\n    def from_sec(sec: float) -&gt; Stamp:\n        \"\"\"Create a Stamp from seconds\"\"\"\n\n    @staticmethod\n    def from_nsec(nsec: int) -&gt; Stamp:\n        \"\"\"Create a Stamp from nanoseconds\"\"\"\n\n    def to_sec(self) -&gt; float:\n        \"\"\"Convert to seconds\"\"\"\n\n    def to_nsec(self) -&gt; int:\n        \"\"\"Convert to nanoseconds\"\"\"\n\n    @property\n    def sec(self) -&gt; int:\n        \"\"\"Underlying seconds storage\"\"\"\n\n    @property\n    def nsec(self) -&gt; int:\n        \"\"\"Underlying nanoseconds storage\"\"\"\n\n    def __lt__(self, arg: Stamp, /) -&gt; bool:\n        \"\"\"Compare two Stamps to see which happened first\"\"\"\n\n    def __gt__(self, arg: Stamp, /) -&gt; bool:\n        \"\"\"Compare two Stamps to see which happened first\"\"\"\n\n    def __eq__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for equality\"\"\"\n\n    def __ne__(self, arg: object, /) -&gt; bool:\n        \"\"\"Check for inequality\"\"\"\n\n    @overload\n    def __sub__(self, arg: Stamp, /) -&gt; Duration:\n        \"\"\"Compute the difference between two Stamps, returning a duration\"\"\"\n\n    @overload\n    def __sub__(self, arg: Duration, /) -&gt; Stamp:\n        \"\"\"Subtract a Duration from a Stamp\"\"\"\n\n    def __add__(self, arg: Duration, /) -&gt; Stamp:\n        \"\"\"Add a Duration to a Stamp\"\"\"\n\n    def __repr__(self) -&gt; str: ...\n\n    def __copy__(self) -&gt; Stamp: ...\n\n    def __deepcopy__(self, memo: dict[Any, Any]) -&gt; Stamp: ...\n\n    def __getstate__(self) -&gt; tuple[int, int]: ...\n\n    def __setstate__(self, arg: tuple[int, int], /) -&gt; None: ...\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.nsec","title":"nsec  <code>property</code>","text":"<pre><code>nsec: int\n</code></pre> <p>Underlying nanoseconds storage</p>"},{"location":"ref/types/#evalio.types.Stamp.sec","title":"sec  <code>property</code>","text":"<pre><code>sec: int\n</code></pre> <p>Underlying seconds storage</p>"},{"location":"ref/types/#evalio.types.Stamp.__add__","title":"__add__","text":"<pre><code>__add__(arg: Duration) -&gt; Stamp\n</code></pre> <p>Add a Duration to a Stamp</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __add__(self, arg: Duration, /) -&gt; Stamp:\n    \"\"\"Add a Duration to a Stamp\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: object) -&gt; bool\n</code></pre> <p>Check for equality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __eq__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for equality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(arg: Stamp) -&gt; bool\n</code></pre> <p>Compare two Stamps to see which happened first</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __gt__(self, arg: Stamp, /) -&gt; bool:\n    \"\"\"Compare two Stamps to see which happened first\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(arg: Stamp) -&gt; bool\n</code></pre> <p>Compare two Stamps to see which happened first</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __lt__(self, arg: Stamp, /) -&gt; bool:\n    \"\"\"Compare two Stamps to see which happened first\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: object) -&gt; bool\n</code></pre> <p>Check for inequality</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def __ne__(self, arg: object, /) -&gt; bool:\n    \"\"\"Check for inequality\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.from_nsec","title":"from_nsec  <code>staticmethod</code>","text":"<pre><code>from_nsec(nsec: int) -&gt; Stamp\n</code></pre> <p>Create a Stamp from nanoseconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef from_nsec(nsec: int) -&gt; Stamp:\n    \"\"\"Create a Stamp from nanoseconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.from_sec","title":"from_sec  <code>staticmethod</code>","text":"<pre><code>from_sec(sec: float) -&gt; Stamp\n</code></pre> <p>Create a Stamp from seconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>@staticmethod\ndef from_sec(sec: float) -&gt; Stamp:\n    \"\"\"Create a Stamp from seconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.to_nsec","title":"to_nsec","text":"<pre><code>to_nsec() -&gt; int\n</code></pre> <p>Convert to nanoseconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def to_nsec(self) -&gt; int:\n    \"\"\"Convert to nanoseconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Stamp.to_sec","title":"to_sec","text":"<pre><code>to_sec() -&gt; float\n</code></pre> <p>Convert to seconds</p> Source code in <code>python/evalio/_cpp/types.pyi</code> <pre><code>def to_sec(self) -&gt; float:\n    \"\"\"Convert to seconds\"\"\"\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory","title":"Trajectory  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[M]</code></p> <p>A trajectory of poses with associated timestamps and metadata.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Get a (stamp, pose) pair by index.</p> </li> <li> <code>__iter__</code>             \u2013              <p>Iterate over the trajectory.</p> </li> <li> <code>__len__</code>             \u2013              <p>Get the length of the trajectory.</p> </li> <li> <code>append</code>             \u2013              <p>Append a new pose to the trajectory.</p> </li> <li> <code>close</code>             \u2013              <p>Close the CSV file if it was opened with open.</p> </li> <li> <code>from_csv</code>             \u2013              <p>Flexible loader for stamped poses stored in csv files.</p> </li> <li> <code>from_file</code>             \u2013              <p>Load a saved evalio trajectory from file.</p> </li> <li> <code>from_tum</code>             \u2013              <p>Load a TUM dataset pose file. Simple wrapper around from_csv.</p> </li> <li> <code>open</code>             \u2013              <p>Open a CSV file for writing.</p> </li> <li> <code>rewrite</code>             \u2013              <p>Update the contents of an open file.</p> </li> <li> <code>to_file</code>             \u2013              <p>Save the trajectory to a CSV file.</p> </li> <li> <code>transform_in_place</code>             \u2013              <p>Apply a transformation to all poses in the trajectory.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>metadata</code>               (<code>M</code>)           \u2013            <p>Metadata associated with the trajectory, such as the dataset name or other information.</p> </li> <li> <code>poses</code>               (<code>list[SE3]</code>)           \u2013            <p>List of poses, in the same order as the timestamps.</p> </li> <li> <code>stamps</code>               (<code>list[Stamp]</code>)           \u2013            <p>List of timestamps for each pose.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@dataclass(kw_only=True)\nclass Trajectory(Generic[M]):\n    \"\"\"A trajectory of poses with associated timestamps and metadata.\"\"\"\n\n    stamps: list[Stamp] = field(default_factory=list)\n    \"\"\"List of timestamps for each pose.\"\"\"\n    poses: list[SE3] = field(default_factory=list)\n    \"\"\"List of poses, in the same order as the timestamps.\"\"\"\n    metadata: M = None  # type: ignore\n    \"\"\"Metadata associated with the trajectory, such as the dataset name or other information.\"\"\"\n    _file: Optional[TextIOWrapper] = None\n    _csv_writer: Optional[Writer] = None\n\n    def __post_init__(self):\n        if len(self.stamps) != len(self.poses):\n            raise ValueError(\"Stamps and poses must have the same length.\")\n\n    def __getitem__(self, idx: int) -&gt; tuple[Stamp, SE3]:\n        \"\"\"Get a (stamp, pose) pair by index.\n\n        Args:\n            idx (int): The index of the (stamp, pose) pair.\n\n        Returns:\n            The (stamp, pose) pair at the given index.\n        \"\"\"\n        return self.stamps[idx], self.poses[idx]\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get the length of the trajectory.\n\n        Returns:\n            The number of (stamp, pose) pairs in the trajectory.\n        \"\"\"\n        return len(self.stamps)\n\n    def __iter__(self) -&gt; Iterator[tuple[Stamp, SE3]]:\n        \"\"\"Iterate over the trajectory.\n\n        Returns:\n            An iterator over the (stamp, pose) pairs.\n        \"\"\"\n        return iter(zip(self.stamps, self.poses))\n\n    def append(self, stamp: Stamp, pose: SE3):\n        \"\"\"Append a new pose to the trajectory.\n\n        Will also write to file if the trajectory was opened with [open][evalio.types.Trajectory.open].\n\n        Args:\n            stamp (Stamp): The timestamp of the pose.\n            pose (SE3): The pose to append.\n        \"\"\"\n        self.stamps.append(stamp)\n        self.poses.append(pose)\n\n        if self._csv_writer is not None:\n            self._csv_writer.writerow(self._serialize_pose(stamp, pose))\n\n    def transform_in_place(self, T: SE3):\n        \"\"\"Apply a transformation to all poses in the trajectory.\n\n        Args:\n            T (SE3): The transformation to apply.\n        \"\"\"\n        for i in range(len(self.poses)):\n            self.poses[i] = self.poses[i] * T\n\n    # ------------------------- Loading from file ------------------------- #\n    @staticmethod\n    def from_csv(\n        path: Path,\n        fieldnames: list[str],\n        delimiter: str = \",\",\n        skip_lines: int = 0,\n    ) -&gt; Trajectory:\n        \"\"\"Flexible loader for stamped poses stored in csv files.\n\n        Will automatically skip any lines that start with a #.\n\n        ``` py\n        from evalio.types import Trajectory\n\n        fieldnames = [\"sec\", \"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"]\n        trajectory = Trajectory.from_csv(path, fieldnames)\n        ```\n\n        Args:\n            path (Path): Location of file.\n            fieldnames (list[str]): List of field names to use, in their expected order. See above for an example.\n            delimiter (str, optional): Delimiter between elements. Defaults to \",\".\n            skip_lines (int, optional): Number of lines to skip, useful for skipping headers. Defaults to 0.\n\n        Returns:\n            Stored trajectory\n        \"\"\"\n        poses: list[SE3] = []\n        stamps: list[Stamp] = []\n\n        fields = {name: i for i, name in enumerate(fieldnames)}\n\n        with open(path) as f:\n            csvfile = filter(lambda row: row[0] != \"#\", f)\n            for i, line in enumerate(csvfile):\n                if i &lt; skip_lines:\n                    continue\n                stamp, pose = parse_csv_line(line, delimiter, fields)\n\n                poses.append(pose)\n                stamps.append(stamp)\n\n        return Trajectory(stamps=stamps, poses=poses)\n\n    @staticmethod\n    def from_tum(path: Path) -&gt; Trajectory:\n        \"\"\"Load a TUM dataset pose file. Simple wrapper around [from_csv][evalio.types.Trajectory].\n\n        Args:\n            path (Path): Location of file.\n\n        Returns:\n            Stored trajectory\n        \"\"\"\n        return Trajectory.from_csv(path, [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"])\n\n    @staticmethod\n    def from_file(\n        path: Path,\n    ) -&gt; Trajectory[Metadata] | FailedMetadataParse | FileNotFoundError:\n        \"\"\"Load a saved evalio trajectory from file.\n\n        Works identically to [from_tum][evalio.types.Trajectory.from_tum], but also loads metadata from the file.\n\n        Args:\n            path (Path): Location of trajectory results.\n\n        Returns:\n            Loaded trajectory with metadata, stamps, and poses.\n        \"\"\"\n        if not path.exists():\n            return FileNotFoundError(f\"File {path} does not exist.\")\n\n        with open(path) as file:\n            metadata_filter = filter(\n                lambda row: row[0] == \"#\" and not row.startswith(\"# timestamp,\"), file\n            )\n            metadata_list = [row[1:] for row in metadata_filter]\n            metadata_str = \"\".join(metadata_list)\n\n            metadata = Metadata.from_yaml(metadata_str)\n            if isinstance(metadata, FailedMetadataParse):\n                return metadata\n\n            metadata.file = path\n\n        trajectory = Trajectory.from_csv(\n            path,\n            fieldnames=[\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n        )\n        trajectory = cast(Trajectory[Metadata], trajectory)\n        trajectory.metadata = metadata\n\n        return trajectory\n\n    # ------------------------- Saving to file ------------------------- #\n    def _serialize_pose(self, stamp: Stamp, pose: SE3) -&gt; list[str | float]:\n        return [\n            f\"{stamp.sec}.{stamp.nsec:09}\",\n            pose.trans[0],\n            pose.trans[1],\n            pose.trans[2],\n            pose.rot.qx,\n            pose.rot.qy,\n            pose.rot.qz,\n            pose.rot.qw,\n        ]\n\n    def _serialize_metadata(self) -&gt; str:\n        if self.metadata is None:\n            return \"\"\n\n        metadata_str = self.metadata.to_yaml()\n        metadata_str = metadata_str.replace(\"\\n\", \"\\n# \")\n        return f\"# {metadata_str}\\n\"\n\n    def _write(self):\n        if self._file is None or self._csv_writer is None:\n            return\n\n        # write everything we've got so far\n        if self.metadata is not None:\n            self._file.write(self._serialize_metadata())\n\n        self._file.write(\"# timestamp, x, y, z, qx, qy, qz, qw\\n\")\n        self._csv_writer.writerows(self._serialize_pose(s, p) for s, p in self)\n\n    def open(self, path: Optional[Path] = None):\n        \"\"\"Open a CSV file for writing.\n\n        This will overwrite any existing file. If no path is provided, will use the path in the metadata, if it exists.\n\n        Args:\n            path (Optional[Path], optional): Path to the CSV file. Defaults to None.\n        \"\"\"\n        if path is not None:\n            pass\n        elif self.metadata is not None and self.metadata.file is not None:\n            path = self.metadata.file\n        else:\n            print_warning(\n                \"Trajectory.open: No metadata or path provided, cannot set metadata file.\"\n            )\n            return\n\n        path.parent.mkdir(parents=True, exist_ok=True)\n        self._file = path.open(\"w\")\n        self._csv_writer = csv.writer(self._file)\n        self._write()\n\n    def close(self):\n        \"\"\"Close the CSV file if it was opened with [open][evalio.types.Trajectory.open].\"\"\"\n        if self._file is not None:\n            self._file.close()\n            self._file = None\n            self._csv_writer = None\n        else:\n            print_warning(\"Trajectory.close: No file to close.\")\n\n    def to_file(self, path: Optional[Path] = None):\n        \"\"\"Save the trajectory to a CSV file.\n\n        Args:\n            path (Optional[Path], optional): Path to the CSV file. If not specified, utilizes the path in the metadata, if it exists. Defaults to None.\n        \"\"\"\n        self.open(path)\n        self.close()\n\n    def rewrite(self):\n        \"\"\"Update the contents of an open file.\"\"\"\n        if self._file is None or self._csv_writer is None:\n            print_warning(\"Trajectory.rewrite: No file is open.\")\n            return\n\n        if self.metadata is None:\n            print_warning(\"Trajectory.rewrite: No metadata to update.\")\n            return\n\n        # Go to start, empty, and rewrite\n        self._file.seek(0)\n        self._file.truncate()\n        self._write()\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: M = None\n</code></pre> <p>Metadata associated with the trajectory, such as the dataset name or other information.</p>"},{"location":"ref/types/#evalio.types.Trajectory.poses","title":"poses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>poses: list[SE3] = field(default_factory=list)\n</code></pre> <p>List of poses, in the same order as the timestamps.</p>"},{"location":"ref/types/#evalio.types.Trajectory.stamps","title":"stamps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stamps: list[Stamp] = field(default_factory=list)\n</code></pre> <p>List of timestamps for each pose.</p>"},{"location":"ref/types/#evalio.types.Trajectory.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; tuple[Stamp, SE3]\n</code></pre> <p>Get a (stamp, pose) pair by index.</p> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>The index of the (stamp, pose) pair.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Stamp, SE3]</code>           \u2013            <p>The (stamp, pose) pair at the given index.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; tuple[Stamp, SE3]:\n    \"\"\"Get a (stamp, pose) pair by index.\n\n    Args:\n        idx (int): The index of the (stamp, pose) pair.\n\n    Returns:\n        The (stamp, pose) pair at the given index.\n    \"\"\"\n    return self.stamps[idx], self.poses[idx]\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[tuple[Stamp, SE3]]\n</code></pre> <p>Iterate over the trajectory.</p> <p>Returns:</p> <ul> <li> <code>Iterator[tuple[Stamp, SE3]]</code>           \u2013            <p>An iterator over the (stamp, pose) pairs.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def __iter__(self) -&gt; Iterator[tuple[Stamp, SE3]]:\n    \"\"\"Iterate over the trajectory.\n\n    Returns:\n        An iterator over the (stamp, pose) pairs.\n    \"\"\"\n    return iter(zip(self.stamps, self.poses))\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get the length of the trajectory.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of (stamp, pose) pairs in the trajectory.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get the length of the trajectory.\n\n    Returns:\n        The number of (stamp, pose) pairs in the trajectory.\n    \"\"\"\n    return len(self.stamps)\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.append","title":"append","text":"<pre><code>append(stamp: Stamp, pose: SE3)\n</code></pre> <p>Append a new pose to the trajectory.</p> <p>Will also write to file if the trajectory was opened with open.</p> <p>Parameters:</p> <ul> <li> <code>stamp</code>               (<code>Stamp</code>)           \u2013            <p>The timestamp of the pose.</p> </li> <li> <code>pose</code>               (<code>SE3</code>)           \u2013            <p>The pose to append.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def append(self, stamp: Stamp, pose: SE3):\n    \"\"\"Append a new pose to the trajectory.\n\n    Will also write to file if the trajectory was opened with [open][evalio.types.Trajectory.open].\n\n    Args:\n        stamp (Stamp): The timestamp of the pose.\n        pose (SE3): The pose to append.\n    \"\"\"\n    self.stamps.append(stamp)\n    self.poses.append(pose)\n\n    if self._csv_writer is not None:\n        self._csv_writer.writerow(self._serialize_pose(stamp, pose))\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the CSV file if it was opened with open.</p> Source code in <code>python/evalio/types/base.py</code> <pre><code>def close(self):\n    \"\"\"Close the CSV file if it was opened with [open][evalio.types.Trajectory.open].\"\"\"\n    if self._file is not None:\n        self._file.close()\n        self._file = None\n        self._csv_writer = None\n    else:\n        print_warning(\"Trajectory.close: No file to close.\")\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.from_csv","title":"from_csv  <code>staticmethod</code>","text":"<pre><code>from_csv(\n    path: Path,\n    fieldnames: list[str],\n    delimiter: str = \",\",\n    skip_lines: int = 0,\n) -&gt; Trajectory\n</code></pre> <p>Flexible loader for stamped poses stored in csv files.</p> <p>Will automatically skip any lines that start with a #.</p> <pre><code>from evalio.types import Trajectory\n\nfieldnames = [\"sec\", \"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"]\ntrajectory = Trajectory.from_csv(path, fieldnames)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of file.</p> </li> <li> <code>fieldnames</code>               (<code>list[str]</code>)           \u2013            <p>List of field names to use, in their expected order. See above for an example.</p> </li> <li> <code>delimiter</code>               (<code>str</code>, default:                   <code>','</code> )           \u2013            <p>Delimiter between elements. Defaults to \",\".</p> </li> <li> <code>skip_lines</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of lines to skip, useful for skipping headers. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code>           \u2013            <p>Stored trajectory</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@staticmethod\ndef from_csv(\n    path: Path,\n    fieldnames: list[str],\n    delimiter: str = \",\",\n    skip_lines: int = 0,\n) -&gt; Trajectory:\n    \"\"\"Flexible loader for stamped poses stored in csv files.\n\n    Will automatically skip any lines that start with a #.\n\n    ``` py\n    from evalio.types import Trajectory\n\n    fieldnames = [\"sec\", \"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"]\n    trajectory = Trajectory.from_csv(path, fieldnames)\n    ```\n\n    Args:\n        path (Path): Location of file.\n        fieldnames (list[str]): List of field names to use, in their expected order. See above for an example.\n        delimiter (str, optional): Delimiter between elements. Defaults to \",\".\n        skip_lines (int, optional): Number of lines to skip, useful for skipping headers. Defaults to 0.\n\n    Returns:\n        Stored trajectory\n    \"\"\"\n    poses: list[SE3] = []\n    stamps: list[Stamp] = []\n\n    fields = {name: i for i, name in enumerate(fieldnames)}\n\n    with open(path) as f:\n        csvfile = filter(lambda row: row[0] != \"#\", f)\n        for i, line in enumerate(csvfile):\n            if i &lt; skip_lines:\n                continue\n            stamp, pose = parse_csv_line(line, delimiter, fields)\n\n            poses.append(pose)\n            stamps.append(stamp)\n\n    return Trajectory(stamps=stamps, poses=poses)\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.from_file","title":"from_file  <code>staticmethod</code>","text":"<pre><code>from_file(\n    path: Path,\n) -&gt; (\n    Trajectory[Metadata]\n    | FailedMetadataParse\n    | FileNotFoundError\n)\n</code></pre> <p>Load a saved evalio trajectory from file.</p> <p>Works identically to from_tum, but also loads metadata from the file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of trajectory results.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory[Metadata] | FailedMetadataParse | FileNotFoundError</code>           \u2013            <p>Loaded trajectory with metadata, stamps, and poses.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@staticmethod\ndef from_file(\n    path: Path,\n) -&gt; Trajectory[Metadata] | FailedMetadataParse | FileNotFoundError:\n    \"\"\"Load a saved evalio trajectory from file.\n\n    Works identically to [from_tum][evalio.types.Trajectory.from_tum], but also loads metadata from the file.\n\n    Args:\n        path (Path): Location of trajectory results.\n\n    Returns:\n        Loaded trajectory with metadata, stamps, and poses.\n    \"\"\"\n    if not path.exists():\n        return FileNotFoundError(f\"File {path} does not exist.\")\n\n    with open(path) as file:\n        metadata_filter = filter(\n            lambda row: row[0] == \"#\" and not row.startswith(\"# timestamp,\"), file\n        )\n        metadata_list = [row[1:] for row in metadata_filter]\n        metadata_str = \"\".join(metadata_list)\n\n        metadata = Metadata.from_yaml(metadata_str)\n        if isinstance(metadata, FailedMetadataParse):\n            return metadata\n\n        metadata.file = path\n\n    trajectory = Trajectory.from_csv(\n        path,\n        fieldnames=[\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"],\n    )\n    trajectory = cast(Trajectory[Metadata], trajectory)\n    trajectory.metadata = metadata\n\n    return trajectory\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.from_tum","title":"from_tum  <code>staticmethod</code>","text":"<pre><code>from_tum(path: Path) -&gt; Trajectory\n</code></pre> <p>Load a TUM dataset pose file. Simple wrapper around from_csv.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code>           \u2013            <p>Stored trajectory</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>@staticmethod\ndef from_tum(path: Path) -&gt; Trajectory:\n    \"\"\"Load a TUM dataset pose file. Simple wrapper around [from_csv][evalio.types.Trajectory].\n\n    Args:\n        path (Path): Location of file.\n\n    Returns:\n        Stored trajectory\n    \"\"\"\n    return Trajectory.from_csv(path, [\"sec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"])\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.open","title":"open","text":"<pre><code>open(path: Optional[Path] = None)\n</code></pre> <p>Open a CSV file for writing.</p> <p>This will overwrite any existing file. If no path is provided, will use the path in the metadata, if it exists.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the CSV file. Defaults to None.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def open(self, path: Optional[Path] = None):\n    \"\"\"Open a CSV file for writing.\n\n    This will overwrite any existing file. If no path is provided, will use the path in the metadata, if it exists.\n\n    Args:\n        path (Optional[Path], optional): Path to the CSV file. Defaults to None.\n    \"\"\"\n    if path is not None:\n        pass\n    elif self.metadata is not None and self.metadata.file is not None:\n        path = self.metadata.file\n    else:\n        print_warning(\n            \"Trajectory.open: No metadata or path provided, cannot set metadata file.\"\n        )\n        return\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n    self._file = path.open(\"w\")\n    self._csv_writer = csv.writer(self._file)\n    self._write()\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.rewrite","title":"rewrite","text":"<pre><code>rewrite()\n</code></pre> <p>Update the contents of an open file.</p> Source code in <code>python/evalio/types/base.py</code> <pre><code>def rewrite(self):\n    \"\"\"Update the contents of an open file.\"\"\"\n    if self._file is None or self._csv_writer is None:\n        print_warning(\"Trajectory.rewrite: No file is open.\")\n        return\n\n    if self.metadata is None:\n        print_warning(\"Trajectory.rewrite: No metadata to update.\")\n        return\n\n    # Go to start, empty, and rewrite\n    self._file.seek(0)\n    self._file.truncate()\n    self._write()\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.to_file","title":"to_file","text":"<pre><code>to_file(path: Optional[Path] = None)\n</code></pre> <p>Save the trajectory to a CSV file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the CSV file. If not specified, utilizes the path in the metadata, if it exists. Defaults to None.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def to_file(self, path: Optional[Path] = None):\n    \"\"\"Save the trajectory to a CSV file.\n\n    Args:\n        path (Optional[Path], optional): Path to the CSV file. If not specified, utilizes the path in the metadata, if it exists. Defaults to None.\n    \"\"\"\n    self.open(path)\n    self.close()\n</code></pre>"},{"location":"ref/types/#evalio.types.Trajectory.transform_in_place","title":"transform_in_place","text":"<pre><code>transform_in_place(T: SE3)\n</code></pre> <p>Apply a transformation to all poses in the trajectory.</p> <p>Parameters:</p> <ul> <li> <code>T</code>               (<code>SE3</code>)           \u2013            <p>The transformation to apply.</p> </li> </ul> Source code in <code>python/evalio/types/base.py</code> <pre><code>def transform_in_place(self, T: SE3):\n    \"\"\"Apply a transformation to all poses in the trajectory.\n\n    Args:\n        T (SE3): The transformation to apply.\n    \"\"\"\n    for i in range(len(self.poses)):\n        self.poses[i] = self.poses[i] * T\n</code></pre>"}]}