{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"evalio","text":"<p>evalio is a tool for Evaluating Lidar-Inertial Odometry.</p> <p>Specifically, it provides a common interface for using LIO datasets and LIO pipelines. This allows for easy addition of new datasets and pipelines as well as a common location to evaluate them. This makes benchmarks significantly easier to run and data significantly easier to access. It features,</p> <ul> <li>Download and manage datasets via the CLI interface</li> <li>Simple to use python package API for friction-free access to data</li> <li>No ROS dependency! (though it can still load rosbag datasets using the wonderful rosbags package)</li> <li>Easy to add new datasets and pipelines, see the example</li> <li>Unified representation of lidar scan, e.g. row (scan-line) major order, stamped at the start of the scan, point stamps are relative from the start of the scan.</li> <li>Run pipelines via the CLI interface and yaml config files</li> <li>Compute statistics for resulting trajectory runs</li> </ul> <p>Checkout quickstart for a quick overview of the package. Additionally, evalio eases a number of common tasks, check out the examples for some common use cases. </p>"},{"location":"install/","title":"Source Build","text":"<p>For the majority of use cases, we simply recommend installing via your favorite python package manager, <pre><code>uv add evalio      # uv\npip install evalio # pip\n</code></pre></p>"},{"location":"install/#building-from-source","title":"Building from Source","text":"<p>Building all the available pipelines together is difficult, so we've done our best to separate a build option for just the core types of evalio, and then pipelines can be optionally added in.</p>"},{"location":"install/#base","title":"Base","text":"<p>We've attempted to make building from source as easy as possible. We generally build through scikit-core-build which provides a simple wrapper for building CMake projects as python packages. <code>uv</code> is our frontend of choice for this process, but it is also possible via pip <pre><code>uv sync --verbose  # uv version\npip install -e .   # pip version\n</code></pre></p> <p>Of course, building via the usual <code>CMake</code> way is also possible, with the only default dependency being <code>Eigen3</code>, <pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre></p>"},{"location":"install/#pipelines","title":"Pipelines","text":"<p>By default, pipelines are not included due to their large dependencies. We use vpckg to handle a reliable build of these dependencies and pipelines. vcpkg and the pipelines can be setup via running <pre><code>./cpp/setup_pipelines.sh\n</code></pre></p> <p>This will clone and setup vcpkg in the <code>.vcpkg</code> directory, and the pipelines (including some minor patches) to <code>cpp/bindings/pipelines-src</code>. vcpkg will automatically be picked up by CMake in this directory, so the build process then continues as in the base section.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>evalio is available on PyPi, so simply install via your favorite python package manager, <pre><code>uv add evalio      # uv\npip install evalio # pip\n</code></pre></p> <p>evalio can be used both as a python library and as a CLI for both datasets and pipelines.</p>"},{"location":"quickstart/#datasets","title":"Datasets","text":"<p>Once evalio is installed, datasets can be listed and downloaded via the CLI interface. For example, to list all datasets and then download a sequence from the hilti-2022 dataset, <pre><code>evalio ls datasets\nevalio download hilti_2022/basement_2\n</code></pre> evalio downloads data to the path given by <code>-D</code>, <code>EVALIO_DATA</code> environment variable, or if both are unset to the local folder <code>./evalio_data</code>. All the trajectories in a dataset can also be downloaded by using the wildcard <code>hilti_2022/*</code>, making sure to escape the asterisk as needed.</p> <p>Tip</p> <p>evalio also comes with autocomplete, which makes typing the long dataset and pipeline names much easier. To install, do one of the following, <pre><code>eval \"$(evalio --show-completion)\" # install for the current session\nevalio --install-completion        # install for all future sessions\n</code></pre></p> <p>Note</p> <p>Many datasets use gdown to download datasets from google drive. Unfortunately, this can occasionally be finicky due to google's download limits, however downloading cookies from your browser can often help.</p> <p>Once downloaded, a trajectory can then be easily used in python, <pre><code>from evalio.datasets import Hilti2022\n\n# for all data\nfor mm in Hilti2022.basement_2:\n    print(mm)\n\n# for lidars\nfor scan in Hilti2022.basement_2.lidar():\n    print(scan)\n\n# for imu\nfor imu in Hilti2022.basement_2.imu():\n    print(imu)\n</code></pre></p> <p>For example, you can easily get a single scan to plot a bird-eye view, <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# get the 10th scan\nscan = Hilti2022.basement_2.get_one_lidar(10)\n# always in row-major order, with stamp at start of scan\nx = np.array([p.x for p in scan.points])\ny = np.array([p.y for p in scan.points])\nz = np.array([p.z for p in scan.points])\nplt.scatter(x, y, c=z, s=1)\nplt.axis('equal')\nplt.show()\n</code></pre> evalio also comes with a built wrapper for converting to rerun types, <pre><code>import rerun as rr\nfrom evalio.rerun import convert\n\nrr.init(\"evalio\")\nrr.connect_tcp()\nfor scan in Hilti2022.basement_2.lidar():\n    rr.set_time(\"timeline\", timestamp=scan.stamp.to_sec())\n    rr.log(\"lidar\", convert(scan, color=[255, 0, 255]))\n</code></pre></p> <p>Note</p> <p>To run the rerun visualization, rerun must be installed. This can be done by installing <code>rerun-sdk</code> or <code>evalio[vis]</code> from PyPi.</p> <p>Once installed, rerun must be spawned from the CLI simply by running <code>rerun</code> in a terminal. This will start the rerun viewer, which can then be used to visualize the data logged by evalio.</p> <p>We recommend checking out the API reference for more information on how to interact with datasets, and the example for an example of how to create your own dataset.</p>"},{"location":"quickstart/#pipelines","title":"Pipelines","text":"<p>The other half of evalio is the pipelines that can be run on various datasets. All pipelines and their parameters can be shown via, <pre><code>evalio ls pipelines\n</code></pre> For example, to run KissICP on a dataset, <pre><code>evalio run -o results -d hilti_2022/basement_2 -p kiss\n</code></pre> This will run the pipeline on the dataset and save the results to the <code>results</code> folder. The results can then be used to compute statistics on the trajectory, <pre><code>evalio stats results\n</code></pre></p> <p>Note</p> <p>KissICP does poorly by default on hilti_2022/basement_2, due to the close range and large default voxel size. You can visualize this by adding <code>-s ms</code> to the <code>run</code> command to visualize the map and scan in rerun.</p> <p>More complex experiments can be run, including varying pipeline parameters, via specifying a config file, <pre><code>output_dir: ./results/\n\ndatasets:\n  # Run on all of newer college trajectories\n  - hilti_2022/*\n  # Run on first 1000 scans of multi campus\n  - name: multi_campus/ntu_day_01\n    length: 1000\n\npipelines:\n  # Run vanilla kiss with default parameters\n  - kiss\n  # Tweak kiss parameters\n  - name: kiss_tweaked\n    pipeline: kiss\n    deskew: true\n    # Some of these datasets need smaller voxel sizes\n    sweep:\n      voxel_size: [0.1, 0.5, 1.0]\n</code></pre> This can then be run via <pre><code>evalio run -c config.yml\n</code></pre></p> <p>Additionally, the run command supports visualization via rerun as well. <code>-v</code> will do a simple visualization of the ground truth trajectory and odometry, while <code>-s</code> can be used to enable additional visualizations, <pre><code>evalio run -o results -d hilti_2022/basement_2 -p kiss -s msif\n</code></pre> where m -&gt; map, s -&gt; scan, i -&gt; intensity image, and f -&gt; extracted features can all be selectively visualized in rerun. </p> <p>Note</p> <p>As mentioned above, rerun must be installed and launched to visualize the results.</p> <p>That's about the gist of it! Try playing around the CLI interface to see what else is possible. Feel free to open an issue if you have any questions, suggestions, or problems. </p> <p>Additionally, we recommend checking out the examples section for specific use cases for evalio.</p>"},{"location":"examples/data_loading/","title":"Data Loading","text":"<p>Loading robotics datasets can be tedious and time-consuming due to the lack of standardization in the datasets formats. evalio provides a unified interface for loading datasets, making it trivial to get up and running with real-world lidar and IMU data.</p> <p>Datasets are managed via the CLI interface, specifically, using <code>evalio dl</code> to download datasets and <code>evalio rm</code> command to remove unwanted datasets. <code>evalio ls datasets</code> is also useful to visualize what has been installed. </p> <p>Once a dataset is downloaded, it can be used via the <code>evalio</code> library. Each dataset is an enum, with each sequence being a member.</p> <pre><code>from evalio.datasets import Hilti2022\n\ndata = Hilti2022.basement_2\n</code></pre> <p>Each datasets provides helpers for iterating over data,</p> <pre><code>from evalio.datasets import Hilti2022\n\n# Iterate through all data in the dataset\nfor mm in Hilti2022.basement_2:\n    print(mm)\n\n# Access only lidar scans\nfor scan in Hilti2022.basement_2.lidar():\n    print(scan)\n\n# Access only IMU data\nfor imu in Hilti2022.basement_2.imu():\n    print(imu)\n</code></pre> <p>Each time an iteration function is called, it will reload the data from the beginning. This obviously has a performance cost, so use wisely.</p> <p>Helpers also exist for just gathering a single data point,</p> <pre><code>from evalio.datasets import Hilti2022\n\n# Get the 10th IMU data point\nimu = Hilti2022.basement_2.get_one_imu(10)\n\n# Get the 10th lidar data point\nlidar = Hilti2022.basement_2.get_one_lidar(10)\n</code></pre> <p>Warning</p> <p>There is a cost to these single data point functions; at the moment this will cause a full iteration over the dataset to find the data point. This is a known issue and will be fixed in the future.</p> <p>Each lidar measurement (type LidarMeasurement) consists of a stamp and a vector of points (type Point). The measurement follows a meticulous order, and always adhered to the following properties,</p> <ul> <li>The measurement stamp is always at the start of the scan</li> <li>Scans are in row-major order</li> <li>Scans contain all points, i.e. invalid points are NOT dropped. This is important information that is used in some algorithms for feature extractions. For example, a 128x1024 scan will contain 128x1024 points</li> <li>Points stamps are always relative to the start of the scan, so absolute point times can be calculated via <code>scan.stamp + scan.points[i].stamp</code></li> </ul> <p>Points are then easy to work with, as can be seen below. <pre><code>from evalio.datasets import Hilti2022\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nscan = Hilti2022.basement_2.get_one_lidar(10)\n\n# Extract x, y, z coordinates\nx = np.array([p.x for p in scan.points])\ny = np.array([p.y for p in scan.points])\nz = np.array([p.z for p in scan.points])\n\n# Plot the bird's-eye view\nplt.scatter(x, y, c=z, s=1)\nplt.axis('equal')\nplt.title(\"Bird's-Eye View of Point Cloud\")\nplt.show()\n</code></pre></p> <p>Additionally, a conversion to rerun types is also available for easy visualization, see rerun for more details.</p> <pre><code>import rerun as rr\nfrom evalio.rerun import convert\n\n# Initialize rerun\nrr.init(\"evalio\")\nrr.connect_tcp()\n\n# Stream lidar scans to rerun\nfor scan in Hilti2022.basement_2.lidar():\n    rr.set_time(\"timeline\", timestamp=scan.stamp.to_sec())\n    rr.log(\"lidar\", convert(scan, color=\"z\"))\n</code></pre> <p>If anything is unclear, please open an issue on the evalio repository. We are always looking to improve the documentation and make it easier to use.</p>"},{"location":"examples/dataset/","title":"Custom Dataset","text":"<p>While evalio comes with a number of built-in datasets, you can also easily create your own dataset without having to build any of evalio from source. In addition to this guide, we also provide evalio-example with examples. </p> <p>To get evalio to find your custom dataset, simply point the environment variable <code>EVALIO_CUSTOM=my_module</code> to the module where your dataset is defined.</p> <p>To create a dataset, one simply has to inherit from the <code>Dataset</code> class,</p> <p><pre><code>from evalio.datasets import Dataset, DatasetIterator\nfrom evalio.types import Trajectory, SE3, ImuParams, LidarParams\n\nfrom typing import Sequence, Optional\nfrom pathlib import Path\nfrom enum import auto\n\nclass MyDataset(Dataset):\n    sequence_1 = auto()\n    sequence_2 = auto()\n    sequence_3 = auto()\n\n    def data_iter(self) -&gt; DatasetIterator: ...\n\n    def ground_truth_raw(self) -&gt; Trajectory: ...\n\n    def files(self) -&gt; Sequence[str | Path]: ...\n\n    def imu_T_lidar(self) -&gt; SE3: ...\n\n    def imu_T_gt(self) -&gt; SE3: ...\n\n    def imu_params(self) -&gt; ImuParams: ...\n\n    def lidar_params(self) -&gt; LidarParams: ...\n</code></pre> The most obvious thing to note is the list of sequences; as each Dataset class is an enum, we list all of the sequences as enum members.</p> <p>After that are the methods. The last four methods are fairly self-explanatory, but we'll elaborate more on the first three.</p>"},{"location":"examples/dataset/#data_iter","title":"data_iter","text":"<p>Arguably the most important method, as is the main interface to the actual data. It returns a <code>DatasetIterator</code> object, which provides iterators over the data.</p> <p>While you are welcome to provide a custom <code>DatasetIterator</code>, evalio provides some for the most common use cases in <code>RosbagIter</code> that iterates over topics found in a rosbag, and <code>RawDataIter</code> takes in iterators for imu and lidar data to return.</p> <p>An example of <code>RosbagIter</code> can be found in the Hilti2022 source code and <code>RawDataIter</code> in the Helipr source code. There is also examples of each in evalio-example.</p>"},{"location":"examples/dataset/#ground_truth_raw","title":"ground_truth_raw","text":"<p>This method provides the ground truth trajectory in an arbitrary frame (often a GPS or prism frame). Many times this is provided in a csv file, which can be loaded via <code>Trajectory.from_tum</code> or<code>Trajectory.from_csv</code>. Naturally, <code>Trajectory</code> can also be created manually from a list of <code>Stamp</code> and <code>SE3</code> objects.</p> <p>It will be transformed into the IMU frame using transform given by the <code>imu_T_gt</code> method.</p>"},{"location":"examples/dataset/#files","title":"files","text":"<p>This provides a list of files that are required to run the dataset. evalio will internally use them to check to make sure the dataset is complete before running anything.</p> <p>If a returned file is a <code>str</code> it is assumed to be a path relative to the sequence directory in <code>EVALIO_DATA</code>, which is given by <code>folder</code>. If it is a <code>Path</code> object, it is assumed to be an absolute path stored wherever you desire.</p>"},{"location":"examples/dataset/#optionals","title":"optionals","text":"<p>Additionally, there is a number of optional methods that you can implement to add more functionality and information to the <code>evalio ls</code> command. Each of these already have default implementations. These methods are (continuing from the above example):</p> <p><pre><code>    @classmethod\n    def dataset_name(cls) -&gt; str: ...\n\n    @staticmethod\n    def url() -&gt; str: ...\n\n    def environment(self) -&gt; str: ...\n\n    def vehicle(self) -&gt; str: ...\n\n    def download(self) -&gt; str: ...\n\n    def quick_len(self) -&gt; Optional[int]: ...\n</code></pre> The first one provides a base dataset name to be used. By default this is the class name converted to snake case, but it can be overridden. This will be the name used when running CLI commands.</p> <p>The next three are again self-explanatory, all of which provide information for the <code>evalio ls</code> command.</p> <p><code>download</code> does exactly what it says - downloads the datasets. See the newer college 2020 for an example downloading from google drive, and hilti 2022 for an example downloading directly from a url.</p> <p><code>quick_len</code> returns a hardcoded number of scans in a dataset, used for <code>evalio ls</code> and for computing time estimates in <code>evalio run</code>. If not set, evalio will load the data to compute the length.</p> <p>That's all there is to it! Datasets are fairly simple - mostly just parameter setting and easy-to-use iterator wrappers. If you have an dataset implementation of an open-source dataset, feel free to make a PR to add it to evalio so others can use it as well.</p>"},{"location":"examples/evaluation/","title":"Evaluation","text":"<p>One of the main uses of <code>evalio</code> is to evaluate the performance of lidar-inertial odometry pipelines. The <code>evalio run</code> command is dedicated to this task. It has usage both as a quick command, and via loading of a config file. See cli for more details.</p> <p>Tip</p> <p>evalio also comes with autocomplete, which makes typing the long dataset and pipeline names much easier. To install, do one of the following, <pre><code>eval \"$(evalio --show-completion)\" # install for the current session\nevalio --install-completion        # install for all future sessions\n</code></pre></p>"},{"location":"examples/evaluation/#quick-command","title":"Quick command","text":"<p>For one off evaluations without parameter changes, <code>evalio run</code> can be used directly, <pre><code>evalio run -d newer_college_2020/short_experiment \\\n            -d hilti_2022/basement_2 \\\n            -p kiss -p liosam \\\n            -o evalio_results\n</code></pre> Also available are the <code>-l/--length</code> which will set a maximum length for every dataset run on, and <code>-s/--show</code> which will visualize the results in an open rerun window, with <code>m</code> showing the map, <code>s</code> the scan, <code>f</code> the extracted features, and <code>i</code> the intensity image.</p>"},{"location":"examples/evaluation/#config-file","title":"Config file","text":"<p>For more complex evaluations, a config file can be used. Here's an example config file, <pre><code>output_dir: ./results/\n\ndatasets:\n  # Run on all of newer college trajectories\n  - hilti_2022/*\n  # Run on first 1000 scans of multi campus\n  - name: multi_campus/ntu_day_01\n    length: 1000\n\npipelines:\n  # Run vanilla kiss with default parameters\n  - kiss\n  # Tweak kiss parameters\n  - name: kiss_tweaked\n    pipeline: kiss\n    deskew: true\n    # Some of these datasets need smaller voxel sizes\n    sweep:\n      voxel_size: [0.1, 0.5, 1.0]\n</code></pre></p> <p>A few notes, - For datasets, a wildcard <code>*</code> can be used to run on all sequences in that dataset. - In the dataset section, a bare item <code>- hilti_2022/basement_2</code> is shorthand for <code>- name: hilti_2022/basement_2</code>. - Similarly for pipelines, a bare item <code>- kiss</code> is shorthand for <code>- pipeline: kiss</code>. - If a pipeline name is not set, it defaults to the pipeline name. - The <code>sweep</code> section is used to run the pipeline with different parameters. The parameters are set as a list, and the pipeline will be run for each parameter in the list, with the name of the pipeline being set to <code>name__parameter_value</code>.</p> <p>The config file can be run with, <pre><code>evalio run -c config.yaml\n</code></pre> Results will be saved to the <code>output_dir</code> specified in the config file, with nested results based on the dataset. Visualization options can also be used here. Mixing the config file and command line options is not allowed, just for reducing the number of possible combinations.</p>"},{"location":"examples/evaluation/#evaluating","title":"Evaluating","text":"<p>Once trajectories have been run, statistics can be calculated, <pre><code>evalio stats -d results -m mean -w 200 -s RTEt\n</code></pre> With <code>-m/--metric</code> specifying the metric to calculate with options including mean, median, and sse and <code>-w/--window</code> specifying the window size for RTE, with a default of 100 scans. Only first part of all trajectories can also be done using the <code>-l/--length</code> option. Sorting of the results can be done with the <code>-s/--sort</code> option, with any column heading being an allowed option. </p>"},{"location":"examples/odometry/","title":"Odometry","text":"<p>If one off odometry is needed, such as for testing a loop closure algorithm, evalio can generate it for you. For example, to generate odometry for the first 2000 scans of the Newer College 2020 dataset using KissICP, <pre><code>evalio run -p kiss -d newer_college_2020/short_experiment -o odometry.csv -l 2000\n</code></pre></p> <p>The odometry will be in the IMU frame and saved in the TUM format,  $$ [t\\ \\text{(sec)}, p_x, p_y, p_z, q_x, q_y, q_z, q_w] $$ along with metadata about how the trajectory was generated behind the '#' character. The above for the first 10 scans would look like: <pre><code># name: kiss\n# pipeline: kiss\n# version: 1.2.2\n# convergence_criterion: 0.0001\n# deskew: False\n# initial_threshold: 2.0\n# max_num_iterations: 500\n# max_num_threads: 0\n# max_points_per_voxel: 20\n# min_motion_th: 0.1\n# voxel_size: 1.0\n#\n# dataset: newer_college_2020\n# sequence: short_experiment\n# length: 100\n#\n# timestamp, x, y, z, qx, qy, qz, qw\n1583836591.082580992,0.006252999883145094,-0.011775000020861626,-0.007644999772310257,0.0,0.0,-1.0,0.0\n1583836591.182590976,0.002104584749512301,-0.014210604585971584,-0.007355713813266136,-2.675152057596367e-05,-8.363399211902303e-06,-0.9999999975888385,-6.353528931178803e-05\n1583836591.282592512,0.0027150532454897226,-0.004297982387396928,-0.015746353734418864,-4.334993947940944e-05,-6.124874074873121e-05,-0.999999996655854,3.2521785965193945e-05\n1583836591.382579456,0.00597131720748457,-0.011520632994006833,-0.006492858132001103,6.470950992969571e-05,-4.590305780285223e-05,-0.9999999968522549,1.0386708003358978e-06\n1583836591.482568704,0.007478720199430491,-0.009223450849391,-0.003496780595402071,1.4720267758293692e-06,3.463391730777789e-05,-0.9999999993679838,7.896668660298116e-06\n1583836591.582553088,0.0012911112076719805,-0.012163729075573013,-0.001935118832270371,1.711692196181323e-05,5.2587891622865136e-05,-0.9999999978422404,3.545481795975868e-05\n1583836591.682529024,0.0026154127249510307,-0.0111173632560525,-0.005718297889001694,-2.7387527703120896e-05,2.907679171021379e-05,-0.9999999988611495,-2.6118280969886083e-05\n1583836591.782496512,0.0042376370480087765,-0.01660435415391814,-0.004709413029178095,-5.202183158898017e-05,6.121947284618483e-05,-0.9999999961629367,-3.492895473336578e-05\n1583836591.882515968,0.003165756615792398,-0.012502098488453172,-0.0014189397620055577,-1.48525422597923e-05,6.736687040505698e-05,-0.9999999976119399,4.150543609892368e-06\n1583836591.982548736,-0.000298752072032382,-0.009307858981044354,-0.01089797673030992,-1.0989202198288011e-05,-4.521269654356091e-05,-0.999999998085071,4.0803279324257364e-05\n</code></pre></p> <p>This file can then by loaded and aligned to the ground truth as needed using the python API. <pre><code>from evalio.types import Trajectory\nfrom evalio.datasets import NewerCollege2020\nfrom evalio import stats\n\ntraj = Trajectory.from_experiment(\"odometry.csv\")\ngt = NewerCollege2020.short_experiment.ground_truth()\n\n# Align the odometry to the ground truth\ntraj_aligned, gt_aligned = stats.align(traj, gt)\n\n# Compute metrics as desired (will align if not already aligned)\nerror =  stats.rte(traj, gt).mean()\n</code></pre></p>"},{"location":"examples/pipeline/","title":"Custom Pipeline","text":"<p>evalio comes with a small number of built-in pipelines, but is made to be easily extensible. Custom pipelines can be created in C++ with nanobind, or in Python. See evalio-example for some examples of building C++ pipelines as well as custom python pipelines.</p> <p>To get evalio to find your custom pipeline, simply point the environment variable <code>EVALIO_CUSTOM=my_module</code> to the module where your pipeline is defined.</p> <p>To create a pipeline, simply inherit from the <code>Pipeline</code> class,</p> PythonC++ <pre><code>from evalio.pipelines import Pipeline\nfrom evalio.types import (\n    SE3,\n    Point,\n    ImuParams,\n    LidarParams,\n    ImuMeasurement,\n    LidarMeasurement,\n)\n\nclass MyPipeline(Pipeline):\n    def __init__(self):\n        super().__init__()\n\n    # Info\n    @staticmethod\n    def version() -&gt; str: ...\n    @staticmethod\n    def url() -&gt; str: ...\n    @staticmethod\n    def name() -&gt; str: ...\n    @staticmethod\n    def default_params() -&gt; dict[str, bool | int | float | str]: ...;\n\n    # Getters\n    def pose(self) -&gt; SE3: ...\n    def map(self) -&gt; list[Point]: ...\n\n    # Setters\n    def set_imu_params(self, params: ImuParams): ...\n    def set_lidar_params(self, params: LidarParams): ...\n    def set_imu_T_lidar(self, T: SE3): ...\n    def set_params(self, params: dict[str, bool | int | float | str]): ...\n\n    # Doers\n    def initialize(self): ...\n    def add_imu(self, mm: ImuMeasurement): ...\n    def add_lidar(self, mm: LidarMeasurement) -&gt; list[Point]: ...\n</code></pre> <pre><code>#include \"evalio/pipeline.h\"\n#include \"evalio/types.h\"\n\n#include &lt;nanobind/nanobind.h&gt;\n#include &lt;nanobind/stl/map.h&gt;\n#include &lt;nanobind/stl/string.h&gt;\n#include &lt;nanobind/stl/variant.h&gt;\n\nnamespace nb = nanobind;\n\nclass MyPipeline : public evalio::Pipeline {\npublic:\n    MyPipeline() : evalio::Pipeline() {}\n\n    // Info\n    static std::string version() { ... }\n    static std::string url() { ... }\n    static std::string name() { ... }\n    static std::map&lt;std::string, Param&gt; default_params() { ... };\n\n    // Getters\n    const SE3 pose() { ... };\n    const std::vector&lt;Point&gt; map() { ... };\n\n    // Setters\n    void set_imu_params(ImuParams params) { ... };\n    void set_lidar_params(LidarParams params) { ... };\n    void set_imu_T_lidar(SE3 T) { ... };\n    void set_params(std::map&lt;std::string, Param&gt;) { ... };\n\n    // Doers\n    void initialize() { ... };\n    void add_imu(ImuMeasurement mm) { ... };\n    std::vector&lt;Point&gt; add_lidar(LidarMeasurement mm) { ... };\n}\n</code></pre> <p>We'll cover each section of methods in turn.</p>"},{"location":"examples/pipeline/#info","title":"Info","text":"<p>The first four methods are all static methods that provide information about the pipeline. <code>version</code>, <code>url</code>, and <code>name</code> are all self-explanatory. <code>default_params</code> is a static method that returns a dictionary of the default parameters for the pipeline. This is used to verify parameters before they are passed in, as well as ensure a consistent output for each run.</p>"},{"location":"examples/pipeline/#getters","title":"Getters","text":"<p>The next two methods are getters for the pose and map. The pose is the most up-to-date estimate for the IMU and is polled after each lidar measurement is passed in. </p> <p>The map current map/submap/etc and is only used for visualization purposes.</p>"},{"location":"examples/pipeline/#setters","title":"Setters","text":"<p>These are to set both dataset specific parameters and pipeline specific parameters. The dataset specific parameters are <code>imu_params</code>, <code>lidar_params</code>, and <code>imu_T_lidar</code>. These are all set before the pipeline is run.</p> <p>The pipeline specific parameters are set using <code>set_params</code>, which takes in a dictionary of parameters. This is used to set any parameters that are specific to the pipeline, such as the number of iterations or the convergence threshold. <code>default_params</code> is updated with any parameters and passed at the start of each run.</p>"},{"location":"examples/pipeline/#doers","title":"Doers","text":"<p>Arguably the most important part. </p> <p><code>initialize</code> is called right after all parameters are set. Think of it as a delayed constructor.</p> <p><code>add_imu</code> is called for each IMU measurement. This is where the IMU data is processed and used to update the pose.</p> <p><code>add_lidar</code> is called for each lidar measurement. This is where the lidar data is processed and used to update the map. It returns a list of features were extracted from the scan and are used for visualization.</p>"},{"location":"examples/pipeline/#c-building","title":"C++ Building","text":"<p>If done in C++, you will need to build the pipeline as a shared library. This is done by a nanobind wrapper, which can be defined at the bottom of your file as follows, <pre><code>NB_MODULE(_core, m) {\n  m.doc() = \"Custom evalio pipeline example\";\n\n  nb::module_ evalio = nb::module_::import_(\"evalio\");\n\n  // Only have to override the static methods here\n  // All the others will be automatically inherited from the base class\n  nb::class_&lt;MyCppPipeline, evalio::Pipeline&gt;(m, \"MyCppPipeline\")\n      .def(nb::init&lt;&gt;())\n      .def_static(\"name\", &amp;MyCppPipeline::name)\n      .def_static(\"url\", &amp;MyCppPipeline::url)\n      .def_static(\"default_params\", &amp;MyCppPipeline::default_params);\n}\n</code></pre></p> <p>We recommend then setting everything up to be built with <code>scikit-build-core</code>. You can see evalio-example for an example of how to set this up.</p> <p>Warning</p> <p>In order for nanobind to share types between the <code>evalio</code> shared object and your custom pipeline, they will have to be compiled with the same version of <code>libstdc++</code>. This pybind PR discusses this in more detail.</p> <p>The \"abi_tag\" used in your version of evalio can be gotten using <code>evalio._abi_tag()</code>, or by running <code>python -c \"import evalio; print(evalio._abi_tag())</code>\". To make sure it matches your nanobind module's, add this to your <code>NB_MODULE</code> definition:</p> <pre><code>m.def(\"abi_tag\", []() { return nb::detail::abi_tag(); });\n</code></pre> <p>That's all there is to it! Pipelines should be fairly easy to implement and are usually just a simple wrapper around your existing code to provide a common interface. Once your pipeline is open-source/published/etc, feel free to make a PR to add it to evalio. This both improves the visibility of your work and of evalio.</p>"},{"location":"included/datasets/","title":"Datasets","text":"<p>evalio comes with a variety of datasets that can be used for easy loading. Below is a table of all datasets that are included, which mirrors the output of <code>evalio ls datasets</code>.</p> Name Sequences Len Env Vehicle IMU LiDAR Info botanic_garden b1005_00b1005_01b1005_07b1006_01b1008_03b1018_00b1018_13 \u00a09.7min\u00a07.9min\u00a09.1min12.4min10.5min\u00a02.4min\u00a03.5min Botanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0GardenBotanic\u00a0Garden ATVATVATVATVATVATVATV Xsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680GXsens\u00a0MTi\u2011680G Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116Velodyne\u00a0VLP\u201116 link cumulti kittredge_loop_robot1kittredge_loop_robot2kittredge_loop_robot3kittredge_loop_robot4main_campus_robot1main_campus_robot2main_campus_robot3main_campus_robot4 \u2011\u2011\u2011\u2011\u2011\u2011\u2011\u2011 CU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0CampusCU\u00a0Boulder\u00a0Campus ATVATVATVATVATVATVATVATV MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7MicroStrain\u00a03DM\u2011GQ7 Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07)Ouster\u00a0OS\u201164\u00a0(Rev\u00a07) link enwide field_dfield_sintersection_dintersection_skatzensee_dkatzensee_srunway_drunway_stunnel_dtunnel_s \u00a02.5min\u00a02.8min\u00a03.0min\u00a03.3min\u00a01.4min\u00a02.7min\u00a03.2min\u00a03.7min\u00a02.0min\u00a04.0min FieldFieldPlanar\u00a0RoadPlanar\u00a0RoadFieldFieldPlanar\u00a0RoadPlanar\u00a0RoadTunnelTunnel HandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheld TDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HTTDK\u00a0IAM\u201120680HT Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128Ouster\u00a0OS0\u2011128 link helipr kaist_05kaist_06dcc_05dcc_06riverside_05riverside_06 20.8min20.3min18.0min17.9min14.3min19.9min Urban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0DrivingUrban\u00a0Driving CarCarCarCarCarCar Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300Xsens\u00a0MTi\u2011300 Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128Ouster\u00a0OS2\u2011128 link hilti_2022 construction_upper_level_1construction_upper_level_2construction_upper_level_3basement_2attic_to_upper_gallery_2corridor_lower_gallery_2 \u00a02.1min\u00a02.1min\u00a02.5min\u00a01.2min\u00a03.3min\u00a01.8min IndoorIndoorIndoorIndoorIndoorIndoor HandheldHandheldHandheldHandheldHandheldHandheld Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085 Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132Hesai\u00a0PandarXT\u201132 link newer_college_2020 short_experimentlong_experimentquad_with_dynamicsdynamic_spinningparkland_mound 25.5min44.3min\u2011\u2011\u2011 Oxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0Campus HandheldHandheldHandheldHandheldHandheld TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948 Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164 link newer_college_2021 quad_easyquad_mediumquad_hardstairscloisterparkmaths_easymaths_mediummaths_hard \u00a03.3min\u00a03.2min\u00a03.1min\u00a02.0min\u00a04.6min26.2min\u00a03.6min\u00a03.0min\u00a04.1min Oxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0CampusOxford\u00a0Campus HandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheld TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948TDK\u00a0ICM\u201120948 Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128 link multi_campus ntu_day_01ntu_day_02ntu_day_10ntu_night_04ntu_night_08ntu_night_13kth_day_06kth_day_09kth_day_10kth_night_01kth_night_04kth_night_05tuhh_day_02tuhh_day_03tuhh_day_04tuhh_night_07tuhh_night_08tuhh_night_09 10.0min\u00a03.8min\u00a05.4min\u00a04.9min\u00a07.8min\u00a03.9min14.9min12.8min10.3min16.1min12.4min11.1min\u00a08.3min14.0min\u00a03.1min\u00a07.4min11.8min\u00a03.1min NTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusNTU\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusKTH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0CampusTUHH\u00a0Campus ATVATVATVATVATVATVHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheldHandheld VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011100VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200VectorNav\u00a0VN\u2011200 Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u2011128Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164Ouster\u00a0OS1\u201164 link oxford_spires blenheim_palace_01blenheim_palace_02blenheim_palace_05bodleian_library_02christ_church_01christ_church_02christ_church_03christ_church_05keble_college_02keble_college_03keble_college_04observatory_quarter_01observatory_quarter_02 \u00a06.8min\u00a06.1min\u00a05.7min\u00a08.3min\u2011\u2011\u00a05.2min13.3min\u00a05.0min\u00a04.8min\u2011\u00a04.8min\u00a04.6min Indoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusOxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusIndoor\u00a0&amp;\u00a0Oxford\u00a0CampusOxford\u00a0CampusOxford\u00a0Campus BackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpackBackpack Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085Bosch\u00a0BMI085 Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164Hesai\u00a0QT\u201164 link"},{"location":"included/pipelines/","title":"Pipelines","text":"<p>evalio comes with a variety of pipelines that can be used for evaluation. Below is a table of all pipelines that are included and their parameters, which mirrors the output of <code>evalio ls pipelines</code>.</p> Name Version Params Default Info kiss 1.2.2 convergence_criteriondeskewinitial_thresholdmax_num_iterationsmax_num_threadsmax_points_per_voxelmin_motion_thvoxel_size 0.0001False2.05000200.11.0 link liosam 0.1.0 downsampleRateedgeFeatureMinValidNumedgeThresholdglobalMapVisualizationLeafSizeglobalMapVisualizationPoseDensityglobalMapVisualizationSearchRadiusmappingCornerLeafSizemappingProcessIntervalmappingSurfLeafSizenumberOfCoresodometrySurfLeafSizerotation_tolerancesurfFeatureMinValidNumsurfThresholdsurroundingKeyframeDensitysurroundingKeyframeSearchRadiussurroundingkeyframeAddingAngleThresholdsurroundingkeyframeAddingDistThresholdz_tolerance 1101.01.010.01000.00.20.150.440.41000.01000.12.050.00.21.01000.0 link loam 1.0.0 edge_feat_thresholdmax_avg_point_plane_distmax_edge_feats_per_sectormax_edge_neighbor_distmax_icf_iterationsmax_planar_feats_per_sectormax_plane_neighbor_distmin_line_condition_numbermin_line_fit_pointsmin_plane_fit_pointsneighbor_pointsnum_edge_neighborsnum_local_map_scansnum_plane_neighborsnumber_sectorsocclusion_threshparallel_threshplanar_feat_thresholdposition_convergence_threshrotation_convergence_thresh 100.00.252.020504.05.034353560.51.01.00.0010.0001 link genz 0.2.0 convergence_criteriondesired_num_voxelized_pointsdeskewinitial_thresholdmax_num_iterationsmax_points_per_voxelmin_motion_thplanarity_thresholdvoxel_size 0.00012000False2.010010.10.20.3 link"},{"location":"ref/cli/","title":"<code>evalio</code>","text":"<p>Tool for evaluating Lidar-Inertial Odometry pipelines on open-source datasets</p> <p>Usage:</p> <pre><code>$ evalio [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>-D, --data-dir PATH</code>: Directory to store downloaded datasets.</li> <li><code>-V, --version</code>: Show version and exit.</li> <li><code>--install-completion</code>: Install completion for the current shell.</li> <li><code>--show-completion</code>: Show completion for the current shell, to copy it or customize the installation.</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>dl</code>: Download datasets</li> <li><code>rm</code>: Remove dataset(s)</li> <li><code>filter</code>: Filter rosbag dataset(s) to only include...</li> <li><code>ls</code>: List dataset and pipeline information</li> <li><code>run</code>: Run pipelines on datasets</li> <li><code>stats</code>: Evaluate the results of experiments.</li> </ul>"},{"location":"ref/cli/#evalio-dl","title":"<code>evalio dl</code>","text":"<p>Download datasets</p> <p>Usage:</p> <pre><code>$ evalio dl [OPTIONS] DATASETS...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DATASETS...</code>: The dataset(s) to use  [required]</li> </ul> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-rm","title":"<code>evalio rm</code>","text":"<p>Remove dataset(s)</p> <p>If --force is not used, will ask for confirmation.</p> <p>Usage:</p> <pre><code>$ evalio rm [OPTIONS] DATASETS...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DATASETS...</code>: The dataset(s) to use  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-f, --force</code>: Force deletion without confirmation</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-filter","title":"<code>evalio filter</code>","text":"<p>Filter rosbag dataset(s) to only include lidar and imu data. Useful for shrinking disk size.</p> <p>Usage:</p> <pre><code>$ evalio filter [OPTIONS] DATASETS...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DATASETS...</code>: The dataset(s) to use  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-f, --force</code>: Force deletion without confirmation</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-ls","title":"<code>evalio ls</code>","text":"<p>List dataset and pipeline information</p> <p>Usage:</p> <pre><code>$ evalio ls [OPTIONS] KIND:{datasets|pipelines}\n</code></pre> <p>Arguments:</p> <ul> <li><code>KIND:{datasets|pipelines}</code>: The kind of object to list  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-s, --search TEXT</code>: Fuzzy search for a pipeline or dataset by name</li> <li><code>-q, --quiet</code>: Output less verbose information</li> <li><code>--show-hyperlinks</code>: Output full links. For terminals that don't support hyperlinks (OSC 8).</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-run","title":"<code>evalio run</code>","text":"<p>Run pipelines on datasets</p> <p>Usage:</p> <pre><code>$ evalio run [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-c, --config PATH</code>: Config file to load from</li> <li><code>-d, --datasets TEXT</code>: The dataset(s) to use</li> <li><code>-p, --pipelines TEXT</code>: The pipeline(s) to use</li> <li><code>-o, --output PATH</code>: Output directory to save results</li> <li><code>-l, --length INTEGER</code>: Number of scans to process for each dataset</li> <li><code>-v, --visualize</code>: Visualize the results via rerun</li> <li><code>-s, --show PARSE</code>: Show visualization options (m: map, i: image, s: scan, f: features). Automatically implies -v.</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/cli/#evalio-stats","title":"<code>evalio stats</code>","text":"<p>Evaluate the results of experiments.</p> <p>Usage:</p> <pre><code>$ evalio stats [OPTIONS] DIRECTORIES...\n</code></pre> <p>Arguments:</p> <ul> <li><code>DIRECTORIES...</code>: Directory of results to evaluate.  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-v, --visualize</code>: Visualize results.</li> <li><code>-s, --sort TEXT</code>: Sort results by the name of a column.  [default: RTEt]</li> <li><code>-w, --window INTEGER</code>: Window size for RTE. Defaults to 100 time-steps.  [default: 200]</li> <li><code>-m, --metric [mean|median|sse]</code>: Metric to use for ATE/RTE computation. Defaults to sse.  [default: sse]</li> <li><code>-l, --length INTEGER</code>: Specify subset of trajectory to evaluate.</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"ref/datasets/","title":"evalio.datasets","text":"<p>For more information about the datasets included in evalio, see the included datasets section.</p>"},{"location":"ref/datasets/#evalio.datasets.Dataset","title":"Dataset","text":"<p>               Bases: <code>StrEnum</code></p> <p>The base class for all datasets.</p> <p>This class provides an interface for loading datasets, including loading parameters and iterating over measurements. All datasets are string enums, where each enum member represents a trajectory sequence in the dataset.</p>"},{"location":"ref/datasets/#evalio.datasets.Dataset.folder","title":"folder  <code>property</code>","text":"<pre><code>folder: Path\n</code></pre> <p>The folder in the global dataset directory where this dataset is stored.</p> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>Path to the dataset folder.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Full name of the dataset, including the dataset name and sequence name.</p> <p>Example: \"dataset_name/sequence_name\"</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Full name of the dataset.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.seq_name","title":"seq_name  <code>property</code>","text":"<pre><code>seq_name: str\n</code></pre> <p>Name of the sequence, in snake case.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Name of the sequence.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Measurement]\n</code></pre> <p>Main interface for iterating over measurements of all types.</p> <p>Returns:</p> <ul> <li> <code>Iterator[Measurement]</code>           \u2013            <p>Iterator[Measurement]: Iterator of all measurements (IMU and Lidar).</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of lidar scans.</p> <p>If quick_len is available, it will be used. Otherwise, it will load the entire dataset to get the length.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of lidar scans.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.data_iter","title":"data_iter","text":"<pre><code>data_iter() -&gt; DatasetIterator\n</code></pre> <p>Provides an iterator over the dataset's measurements.</p> <p>Returns:</p> <ul> <li> <code>DatasetIterator</code> (              <code>DatasetIterator</code> )          \u2013            <p>An iterator that yields measurements from the dataset.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.dataset_name","title":"dataset_name  <code>classmethod</code>","text":"<pre><code>dataset_name() -&gt; str\n</code></pre> <p>Name of the dataset, in snake case.</p> <p>This is the name that will be used when parsing directly from a string. Currently is automatically generated from the class name, but can be overridden.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>description</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.download","title":"download","text":"<pre><code>download() -&gt; None\n</code></pre> <p>Method to download the dataset.</p> <p>Completely optional to implement, although most datasets do.</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.environment","title":"environment","text":"<pre><code>environment() -&gt; str\n</code></pre> <p>Environment where the dataset was collected.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Environment where the dataset was collected.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.files","title":"files","text":"<pre><code>files() -&gt; Sequence[str | Path]\n</code></pre> <p>Return list of files required to run this dataset.</p> <p>If a returned type is a Path, it will be checked as is. If it is a string, it will be prepended with folder.</p> <p>Returns:</p> <ul> <li> <code>Sequence[str | Path]</code>           \u2013            <p>list[str]: description</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.get_one_imu","title":"get_one_imu","text":"<pre><code>get_one_imu(idx: int = 0) -&gt; ImuMeasurement\n</code></pre> <p>Get a single IMU measurement.</p> <p>Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.</p> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Index of measurement to get. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImuMeasurement</code> (              <code>ImuMeasurement</code> )          \u2013            <p>The IMU measurement at the given index.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.get_one_lidar","title":"get_one_lidar","text":"<pre><code>get_one_lidar(idx: int = 0) -&gt; LidarMeasurement\n</code></pre> <p>Get a single Lidar measurement.</p> <p>Note, this can be expensive to compute, as it will iterate over the entire dataset until it finds the measurement.</p> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Index of measurement to get. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LidarMeasurement</code> (              <code>LidarMeasurement</code> )          \u2013            <p>The Lidar measurement at the given index.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.ground_truth","title":"ground_truth","text":"<pre><code>ground_truth() -&gt; Trajectory\n</code></pre> <p>Get the ground truth trajectory in the IMU frame, rather than the ground truth frame as returned in ground_truth_raw.</p> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The ground truth trajectory in the IMU frame.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.ground_truth_raw","title":"ground_truth_raw","text":"<pre><code>ground_truth_raw() -&gt; Trajectory\n</code></pre> <p>Retrieves the raw ground truth trajectory, as represented in the ground truth frame.</p> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The raw ground truth trajectory data.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu","title":"imu","text":"<pre><code>imu() -&gt; Iterable[ImuMeasurement]\n</code></pre> <p>Iterate over just IMU measurements.</p> <p>Returns:</p> <ul> <li> <code>Iterable[ImuMeasurement]</code>           \u2013            <p>Iterable[ImuMeasurement]: Iterator of IMU measurements.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu_T_gt","title":"imu_T_gt","text":"<pre><code>imu_T_gt() -&gt; SE3\n</code></pre> <p>Retrieves the transformation from IMU to ground truth frame.</p> <p>Returns:</p> <ul> <li> <code>SE3</code> (              <code>SE3</code> )          \u2013            <p>Transformation from IMU to ground truth frame.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu_T_lidar","title":"imu_T_lidar","text":"<pre><code>imu_T_lidar() -&gt; SE3\n</code></pre> <p>Returns the transformation from IMU to Lidar frame.</p> <p>Returns:</p> <ul> <li> <code>SE3</code> (              <code>SE3</code> )          \u2013            <p>Transformation from IMU to Lidar frame.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.imu_params","title":"imu_params","text":"<pre><code>imu_params() -&gt; ImuParams\n</code></pre> <p>Specifies the parameters of the IMU.</p> <p>Returns:</p> <ul> <li> <code>ImuParams</code> (              <code>ImuParams</code> )          \u2013            <p>Parameters of the IMU.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.is_downloaded","title":"is_downloaded","text":"<pre><code>is_downloaded() -&gt; bool\n</code></pre> <p>Verify if the dataset is downloaded.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the dataset is downloaded, False otherwise.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.lidar","title":"lidar","text":"<pre><code>lidar() -&gt; Iterable[LidarMeasurement]\n</code></pre> <p>Iterate over just Lidar measurements.</p> <p>Returns:</p> <ul> <li> <code>Iterable[LidarMeasurement]</code>           \u2013            <p>Iterable[LidarMeasurement]: Iterator of Lidar measurements.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.lidar_params","title":"lidar_params","text":"<pre><code>lidar_params() -&gt; LidarParams\n</code></pre> <p>Specifies the parameters of the Lidar.</p> <p>Returns:</p> <ul> <li> <code>LidarParams</code> (              <code>LidarParams</code> )          \u2013            <p>Parameters of the Lidar.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.quick_len","title":"quick_len","text":"<pre><code>quick_len() -&gt; Optional[int]\n</code></pre> <p>Hardcoded number of lidar scans in the dataset, rather than computing by loading all the data (slow).</p> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>Optional[int]: Number of lidar scans in the dataset. None if not available.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.sequences","title":"sequences  <code>classmethod</code>","text":"<pre><code>sequences() -&gt; list[Dataset]\n</code></pre> <p>All sequences in the dataset.</p> <p>Returns:</p> <ul> <li> <code>list[Dataset]</code>           \u2013            <p>list[Dataset]: List of all sequences in the dataset.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.size_on_disk","title":"size_on_disk","text":"<pre><code>size_on_disk() -&gt; Optional[float]\n</code></pre> <p>Shows the size of the dataset on disk, in GB.</p> <p>Returns:</p> <ul> <li> <code>Optional[float]</code>           \u2013            <p>Optional[float]: Size of the dataset on disk, in GB. None if the dataset is not downloaded.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.url","title":"url  <code>staticmethod</code>","text":"<pre><code>url() -&gt; str\n</code></pre> <p>Webpage with the dataset information.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>URL of the dataset webpage.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.Dataset.vehicle","title":"vehicle","text":"<pre><code>vehicle() -&gt; str\n</code></pre> <p>Vehicle used to collect the dataset.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Vehicle used to collect the dataset.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator","title":"DatasetIterator","text":"<p>               Bases: <code>Iterable[Measurement]</code></p> <p>This is the base class for iterating over datasets.</p> <p>This class is the main interface used to iterate over the dataset's measurements. It provides an interface for iterating over IMU and Lidar measurements, as well as all measurements interleaved. This allows for standardizing access to loading data, while allowing for loading parameters in Dataset without having to load the data. Generally, will be created by the Dataset.data_iter method.</p>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Measurement]\n</code></pre> <p>Main interface for iterating over all measurements.</p> <p>Yields:</p> <ul> <li> <code>Measurement</code>           \u2013            <p>Iterator[Measurement]: Iterator of all measurements (IMU and Lidar).</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Number of lidar scans.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of lidar scans.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.imu_iter","title":"imu_iter","text":"<pre><code>imu_iter() -&gt; Iterator[ImuMeasurement]\n</code></pre> <p>Main interface for iterating over IMU measurements.</p> <p>Yields:</p> <ul> <li> <code>ImuMeasurement</code>           \u2013            <p>Iterator[ImuMeasurement]: Iterator of IMU measurements.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.DatasetIterator.lidar_iter","title":"lidar_iter","text":"<pre><code>lidar_iter() -&gt; Iterator[LidarMeasurement]\n</code></pre> <p>Main interface for iterating over Lidar measurements.</p> <p>Yields:</p> <ul> <li> <code>LidarMeasurement</code>           \u2013            <p>Iterator[LidarMeasurement]: Iterator of Lidar measurements.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.RosbagIter","title":"RosbagIter","text":"<p>               Bases: <code>DatasetIterator</code></p> <p>An iterator for loading from rosbag files.</p> <p>This is a wrapper around the rosbags library, with some niceties for converting ros PointCloud2 messages to a standardized format. Has identical methods to DatasetIterator.</p>"},{"location":"ref/datasets/#evalio.datasets.RosbagIter.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    lidar_topic: str,\n    imu_topic: str,\n    lidar_params: LidarParams,\n    type_store: Optional[Stores] = None,\n    lidar_format: Optional[LidarFormatParams] = None,\n    custom_col_func: Optional[\n        Callable[[LidarMeasurement], None]\n    ] = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of rosbag file(s) or dir(s). If a directory is passed containing multiple bags (ros1 or ros2), all will be loaded.</p> </li> <li> <code>lidar_topic</code>               (<code>str</code>)           \u2013            <p>Name of lidar topic.</p> </li> <li> <code>imu_topic</code>               (<code>str</code>)           \u2013            <p>Name of imu topic.</p> </li> <li> <code>lidar_params</code>               (<code>LidarParams</code>)           \u2013            <p>Lidar parameters, can be gotten from lidar_params.</p> </li> <li> <code>type_store</code>               (<code>Optional[Stores]</code>, default:                   <code>None</code> )           \u2013            <p>Additional type store to be loaded into rosbags. Defaults to None.</p> </li> <li> <code>lidar_format</code>               (<code>Optional[LidarFormatParams]</code>, default:                   <code>None</code> )           \u2013            <p>Various parameters for how lidar data is stored. If not specified, most will try to be inferred. We strongly recommend setting this to ensure data is standardized properly. Defaults to None.</p> </li> <li> <code>custom_col_func</code>               (<code>Optional[Callable[[LidarMeasurement], None]]</code>, default:                   <code>None</code> )           \u2013            <p>Function to put the point cloud in row major format. Will generally not be needed, except for strange default orderings. Defaults to None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the path is a directory and no .bag files are found.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the lidar or imu topic is not found in the bag file.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.RawDataIter","title":"RawDataIter","text":"<p>               Bases: <code>DatasetIterator</code></p> <p>An iterator for loading from python iterables.</p> <p>Interleaves imu and lidar iterables. Allows for arbitrary data to be loaded and presented in a consistent manner for the base Dataset class. Has identical methods to DatasetIterator.</p>"},{"location":"ref/datasets/#evalio.datasets.RawDataIter.__init__","title":"__init__","text":"<pre><code>__init__(\n    iter_lidar: Iterator[LidarMeasurement],\n    iter_imu: Iterator[ImuMeasurement],\n    num_lidar: int,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>iter_lidar</code>               (<code>Iterator[LidarMeasurement]</code>)           \u2013            <p>An iterator over LidarMeasurement</p> </li> <li> <code>iter_imu</code>               (<code>Iterator[ImuMeasurement]</code>)           \u2013            <p>An iterator over ImuMeasurement</p> </li> <li> <code>num_lidar</code>               (<code>int</code>)           \u2013            <p>The number of lidar measurements</p> </li> </ul> <pre><code>from evalio.datasets.loaders import RawDataIter\nfrom evalio.types import ImuMeasurement, LidarMeasurement, Stamp\nimport numpy as np\n\n# Create some fake data\nimu_iter = (\n    ImuMeasurement(Stamp.from_sec(i), np.zeros(3), np.zeros(3))\n    for i in range(10)\n)\nlidar_iter = (LidarMeasurement(Stamp.from_sec(i + 0.1)) for i in range(10))\n\n# Create the iterator\nrawdata = RawDataIter(imu_iter, lidar_iter, 10)\n</code></pre>"},{"location":"ref/datasets/#evalio.datasets.get_data_dir","title":"get_data_dir","text":"<pre><code>get_data_dir() -&gt; Path\n</code></pre> <p>Get the global data directory. This will be used to store the downloaded data.</p> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>Directory where datasets are stored.</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.set_data_dir","title":"set_data_dir","text":"<pre><code>set_data_dir(directory: Path)\n</code></pre> <p>Set the global location where datasets are stored. This will be used to store the downloaded data.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path</code>)           \u2013            <p>Directory</p> </li> </ul>"},{"location":"ref/datasets/#evalio.datasets.BotanicGarden","title":"BotanicGarden","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken from a botanical garden, specifically for testing unstructured environments. Ground truth is gathered using a survey grade lidar.</p> <p>Note, there is no automatic downloader for this dataset due to being uploaded on onedrive. Data can be downloaded manually and placed in the correct folder in <code>EVALIO_DATA</code>.</p> <p>Additionally, we only include the public datasets here; more are potentially available upon request.</p>"},{"location":"ref/datasets/#evalio.datasets.CUMulti","title":"CUMulti","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset collected by a ground robot (AgileX - Hunter) on the University of Colorado Boulder Campus.</p>"},{"location":"ref/datasets/#evalio.datasets.EnWide","title":"EnWide","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken in purposely degenerate locations such as a field, intersections, tunnels, and runways. All data comes directly from the Ouster unit.</p> <p>Note, this dataset does not have ground truth orientation, only ground truth positional values taken from a Leica MS60 Prism.</p>"},{"location":"ref/datasets/#evalio.datasets.HeLiPR","title":"HeLiPR","text":"<p>               Bases: <code>Dataset</code></p> <p>Self-driving car dataset taken in urban environments. Ground truth is generated using filtering of an RTK-GNSS system.</p> <p>The vehicle had multiple lidar sensors mounted; we utilize the high resolution Ouster at the top of the vehicle.</p>"},{"location":"ref/datasets/#evalio.datasets.Hilti2022","title":"Hilti2022","text":"<p>               Bases: <code>Dataset</code></p> <p>Sequences with ground truth taken from the Hilti 2022 SLAM Challenge, mostly taken from indoors.</p>"},{"location":"ref/datasets/#evalio.datasets.MultiCampus","title":"MultiCampus","text":"<p>               Bases: <code>Dataset</code></p> <p>Data taken from a variety of campus (KTH, NTU, TUHH) in Asia and Europe at different seasons, at day and night, and with an ATV and handheld platform.</p> <p>Ground truth was measured using a continuous optimization of lidar scans matched against a laser scanner map.</p>"},{"location":"ref/datasets/#evalio.datasets.NewerCollege2020","title":"NewerCollege2020","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken from outdoor Oxford Campus. Ground truth is generated using ICP matching against a laser scanner.</p> <p>Note, there have been some reports that the laser scanner and data were collected months apart, which may have caused some inaccuracies in the ground truth data.</p> <p>There are two IMUs on the handheld device, but the realsense IMU is not time-synced with the lidar data. Therefore, we utilize the Ouster IMU data instead.</p>"},{"location":"ref/datasets/#evalio.datasets.NewerCollege2021","title":"NewerCollege2021","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset outdoors on oxford campus with a handheld device consisting of an alphasense core and a Ouster lidar. Ground truth is captured ICP matching against a laser scanner map.</p> <p>Note there are two IMUs present; we utilize the Ouster IMU (ICM-20948)) instead of the alphasense one (Bosch BMI085). We expect the Ouster IMU to have more accurate extrinsics and the specs between the two IMUs are fairly similar.</p>"},{"location":"ref/datasets/#evalio.datasets.OxfordSpires","title":"OxfordSpires","text":"<p>               Bases: <code>Dataset</code></p> <p>Dataset taken both indoors and outdoors on the Oxford campus.</p> <p>Note, we skip over a number of trajectories due to missing ground truth data.</p> <p>Additionally, some of the ground truth has poses within a few milliseconds of each other - we skip over any ground truth values within 10 milliseconds of each other.</p>"},{"location":"ref/pipelines/","title":"evalio.pipelines","text":"<p>For more information about the pipelines included in evalio, see the included pipelines section.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline","title":"Pipeline","text":"<p>Base class for all pipelines. This class defines the interface for interacting with pipelines, and is intended to be subclassed by specific implementations.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Construct a new pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.add_imu","title":"add_imu","text":"<pre><code>add_imu(mm: ImuMeasurement) -&gt; None\n</code></pre> <p>Register an IMU measurement.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.add_lidar","title":"add_lidar","text":"<pre><code>add_lidar(mm: LidarMeasurement) -&gt; dict[str, list[Point]]\n</code></pre> <p>Register a LiDAR measurement.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.default_params","title":"default_params  <code>staticmethod</code>","text":"<pre><code>default_params() -&gt; dict[str, bool | int | float | str]\n</code></pre> <p>Default parameters for the pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; None\n</code></pre> <p>Initialize the pipeline. Must be called after constructing the object and before setting parameters.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.map","title":"map","text":"<pre><code>map() -&gt; dict[str, list[Point]]\n</code></pre> <p>Map of the environment.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.name","title":"name  <code>staticmethod</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Name of the pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.pose","title":"pose","text":"<pre><code>pose() -&gt; SE3\n</code></pre> <p>Most recent pose estimate.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_imu_T_lidar","title":"set_imu_T_lidar","text":"<pre><code>set_imu_T_lidar(T: SE3) -&gt; None\n</code></pre> <p>Set the transformation from IMU to LiDAR frame.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_imu_params","title":"set_imu_params","text":"<pre><code>set_imu_params(params: ImuParams) -&gt; None\n</code></pre> <p>Set IMU parameters for the pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_lidar_params","title":"set_lidar_params","text":"<pre><code>set_lidar_params(params: LidarParams) -&gt; None\n</code></pre> <p>Set LiDAR parameters for the pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.set_params","title":"set_params","text":"<pre><code>set_params(\n    params: Mapping[str, bool | int | float | str],\n) -&gt; dict[str, bool | int | float | str]\n</code></pre> <p>Set parameters for the pipeline. This will override any default parameters.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.url","title":"url  <code>staticmethod</code>","text":"<pre><code>url() -&gt; str\n</code></pre> <p>URL for more information about the pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.Pipeline.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Version of the pipeline.</p>"},{"location":"ref/pipelines/#evalio.pipelines.GenZICP","title":"GenZICP","text":"<p>               Bases: <code>Pipeline</code></p> <p>Genz-ICP LiDAR-only pipeline is an extension of KissICP that additionally estimates normals in the local submap voxel map for increased robustness. It also includes a novel weighting scheme for weighting point-to-plane and point-to-point correspondences.</p>"},{"location":"ref/pipelines/#evalio.pipelines.KissICP","title":"KissICP","text":"<p>               Bases: <code>Pipeline</code></p> <p>KissICP LiDAR-only pipeline for point cloud registration. KissICP is designed to be simple and easy to use, while still providing good performance with minimal parameter tuning required across datasets.</p>"},{"location":"ref/pipelines/#evalio.pipelines.LOAM","title":"LOAM","text":"<p>               Bases: <code>Pipeline</code></p> <p>Lidar Odometry and Mapping (LOAM) pipeline. LOAM is a baseline lidar-only odometry method that pioneered feature-based ICP. Our implementation permits both scan-to-scan or scan-to-map matching.</p>"},{"location":"ref/pipelines/#evalio.pipelines.LioSAM","title":"LioSAM","text":"<p>               Bases: <code>Pipeline</code></p> <p>Lidar-Inertial Smoothing and Mapping (LioSAM) pipeline. LioSAM is an extension of LOAM (=&gt; uses planar and edge features) that additionally utilizes an IMU for initializing ICP steps and for dewarping points</p>"},{"location":"ref/rerun/","title":"evalio.rerun","text":""},{"location":"ref/rerun/#evalio.rerun.convert","title":"convert","text":"<pre><code>convert(\n    obj: LidarMeasurement,\n    color: Optional[\n        Literal[\"z\", \"intensity\"]\n        | tuple[int, int, int]\n        | tuple[float, float, float]\n    ] = None,\n    radii: Optional[float] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: list[Point],\n    color: Optional[\n        Literal[\"z\", \"intensity\"]\n        | tuple[int, int, int]\n        | tuple[float, float, float]\n    ] = None,\n    radii: Optional[float] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: ndarray,\n    color: Optional[Literal[\"z\"] | ndarray] = None,\n    radii: Optional[float] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: list[SE3],\n    color: Optional[\n        tuple[int, int, int] | tuple[float, float, float]\n    ] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(\n    obj: Trajectory,\n    color: Optional[\n        tuple[int, int, int] | tuple[float, float, float]\n    ] = None,\n) -&gt; Points3D\n</code></pre><pre><code>convert(obj: SE3) -&gt; Transform3D\n</code></pre> <pre><code>convert(\n    obj: object,\n    color: Optional[Any] = None,\n    radii: Optional[float] = None,\n) -&gt; Transform3D | Points3D\n</code></pre> <p>Convert a variety of objects to rerun types.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>object</code>)           \u2013            <p>Object to convert. Can be a LidarMeasurement, list of Points, numpy array, SE3, or Trajectory.</p> </li> <li> <code>color</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Optional color to set. See overloads for additional literal options. Defaults to None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the color pass is invalid.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the object is not an implemented type for conversion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Transform3D | Points3D</code>           \u2013            <p>rr.Transform3D | rr.Points3D: Rerun type.</p> </li> </ul>"},{"location":"ref/stats/","title":"evalio.stats","text":""},{"location":"ref/stats/#evalio.stats.Error","title":"Error  <code>dataclass</code>","text":"<p>Dataclass to hold the error between two trajectories. Generally output from computing ate or rte.</p> <p>Contains a (n,) arrays of translation and rotation errors.</p>"},{"location":"ref/stats/#evalio.stats.Error.rot","title":"rot  <code>instance-attribute</code>","text":"<pre><code>rot: ndarray\n</code></pre> <p>rotation error, shape (n,), in degrees</p>"},{"location":"ref/stats/#evalio.stats.Error.trans","title":"trans  <code>instance-attribute</code>","text":"<pre><code>trans: ndarray\n</code></pre> <p>translation error, shape (n,), in meters</p>"},{"location":"ref/stats/#evalio.stats.Error.mean","title":"mean","text":"<pre><code>mean() -&gt; Metric\n</code></pre> <p>Compute the mean of the errors.</p>"},{"location":"ref/stats/#evalio.stats.Error.median","title":"median","text":"<pre><code>median() -&gt; Metric\n</code></pre> <p>Compute the median of the errors.</p>"},{"location":"ref/stats/#evalio.stats.Error.sse","title":"sse","text":"<pre><code>sse() -&gt; Metric\n</code></pre> <p>Compute the sqrt of sum of squared errors.</p>"},{"location":"ref/stats/#evalio.stats.Error.summarize","title":"summarize","text":"<pre><code>summarize(metric: MetricKind) -&gt; Metric\n</code></pre> <p>How to summarize the vector of errors.</p> <p>Parameters:</p> <ul> <li> <code>metric</code>               (<code>MetricKind</code>)           \u2013            <p>The metric to use for summarizing the error, either mean, median, or sse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Metric</code> (              <code>Metric</code> )          \u2013            <p>The summarized error</p> </li> </ul>"},{"location":"ref/stats/#evalio.stats.Metric","title":"Metric  <code>dataclass</code>","text":"<p>Simple dataclass to hold the resulting metrics. Likely output from Error.</p>"},{"location":"ref/stats/#evalio.stats.Metric.rot","title":"rot  <code>instance-attribute</code>","text":"<pre><code>rot: float\n</code></pre> <p>rotation error in degrees</p>"},{"location":"ref/stats/#evalio.stats.Metric.trans","title":"trans  <code>instance-attribute</code>","text":"<pre><code>trans: float\n</code></pre> <p>translation error in meters</p>"},{"location":"ref/stats/#evalio.stats.MetricKind","title":"MetricKind","text":"<p>               Bases: <code>StrEnum</code></p> <p>Simple enum to define the metric to use for summarizing the error. Used in Error.</p>"},{"location":"ref/stats/#evalio.stats.MetricKind.mean","title":"mean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mean = auto()\n</code></pre> <p>Mean</p>"},{"location":"ref/stats/#evalio.stats.MetricKind.median","title":"median  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>median = auto()\n</code></pre> <p>Median</p>"},{"location":"ref/stats/#evalio.stats.MetricKind.sse","title":"sse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sse = auto()\n</code></pre> <p>Sqrt of Sum of squared errors</p>"},{"location":"ref/stats/#evalio.stats.align","title":"align","text":"<pre><code>align(\n    traj: Trajectory, gt: Trajectory, in_place: bool = False\n) -&gt; tuple[Trajectory, Trajectory]\n</code></pre> <p>Align the trajectories both spatially and temporally.</p> <p>The resulting trajectories will be have the same origin as the second (\"gt\") trajectory. See align_poses and align_stamps for more details.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>One of the trajectories to align.</p> </li> <li> <code>gt</code>               (<code>Trajectory</code>)           \u2013            <p>The other trajectory to align to.</p> </li> <li> <code>in_place</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, the original trajectory will be modified. Defaults to False.</p> </li> </ul>"},{"location":"ref/stats/#evalio.stats.align_poses","title":"align_poses","text":"<pre><code>align_poses(traj: Trajectory, other: Trajectory)\n</code></pre> <p>Align the trajectory in place to another trajectory. Operates in place.</p> <p>This results in the current trajectory having an identical first pose to the other trajectory. Assumes the first pose of both trajectories have the same stamp.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory that will be modified</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory to align to.</p> </li> </ul>"},{"location":"ref/stats/#evalio.stats.align_stamps","title":"align_stamps","text":"<pre><code>align_stamps(traj1: Trajectory, traj2: Trajectory)\n</code></pre> <p>Select the closest poses in traj1 and traj2. Operates in place.</p> <p>Does this by finding the higher frame rate trajectory and subsampling it to the closest poses of the other one. Additionally it checks the beginning of the trajectories to make sure they start at about the same stamp.</p> <p>Parameters:</p> <ul> <li> <code>traj1</code>               (<code>Trajectory</code>)           \u2013            <p>One trajectory</p> </li> <li> <code>traj2</code>               (<code>Trajectory</code>)           \u2013            <p>Other trajectory</p> </li> </ul>"},{"location":"ref/stats/#evalio.stats.ate","title":"ate","text":"<pre><code>ate(traj: Trajectory, gt: Trajectory) -&gt; Error\n</code></pre> <p>Compute the Absolute Trajectory Error (ATE) between two trajectories.</p> <p>Will check if the two trajectories are aligned and if not, will align them. Will not modify the original trajectories.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>One of the trajectories</p> </li> <li> <code>gt</code>               (<code>Trajectory</code>)           \u2013            <p>The other trajectory</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Error</code> (              <code>Error</code> )          \u2013            <p>The computed error</p> </li> </ul>"},{"location":"ref/stats/#evalio.stats.rte","title":"rte","text":"<pre><code>rte(\n    traj: Trajectory, gt: Trajectory, window: int = 100\n) -&gt; Error\n</code></pre> <p>Compute the Relative Trajectory Error (RTE) between two trajectories.</p> <p>Will check if the two trajectories are aligned and if not, will align them. Will not modify the original trajectories.</p> <p>Parameters:</p> <ul> <li> <code>traj</code>               (<code>Trajectory</code>)           \u2013            <p>One of the trajectories</p> </li> <li> <code>gt</code>               (<code>Trajectory</code>)           \u2013            <p>The other trajectory</p> </li> <li> <code>window</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Window size for the RTE. Defaults to 100.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Error</code> (              <code>Error</code> )          \u2013            <p>The computed error</p> </li> </ul>"},{"location":"ref/types/","title":"evalio.types","text":""},{"location":"ref/types/#evalio.types.Duration","title":"Duration","text":"<p>Duration class for representing a positive or negative delta time, uses int64 as the underlying data storage for nanoseconds.</p>"},{"location":"ref/types/#evalio.types.Duration.nsec","title":"nsec  <code>property</code>","text":"<pre><code>nsec: int\n</code></pre> <p>Underlying nanoseconds representation</p>"},{"location":"ref/types/#evalio.types.Duration.__add__","title":"__add__","text":"<pre><code>__add__(arg: Duration) -&gt; Duration\n</code></pre> <p>Add two Durations</p>"},{"location":"ref/types/#evalio.types.Duration.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: Duration) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.Duration.__gt__","title":"__gt__","text":"<pre><code>__gt__(arg: Duration) -&gt; bool\n</code></pre> <p>Compare two Durations</p>"},{"location":"ref/types/#evalio.types.Duration.__lt__","title":"__lt__","text":"<pre><code>__lt__(arg: Duration) -&gt; bool\n</code></pre> <p>Compare two Durations</p>"},{"location":"ref/types/#evalio.types.Duration.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: Duration) -&gt; bool\n</code></pre> <p>Check for inequality</p>"},{"location":"ref/types/#evalio.types.Duration.__sub__","title":"__sub__","text":"<pre><code>__sub__(arg: Duration) -&gt; Duration\n</code></pre> <p>Compute the difference between two Durations</p>"},{"location":"ref/types/#evalio.types.Duration.from_nsec","title":"from_nsec  <code>staticmethod</code>","text":"<pre><code>from_nsec(nsec: int) -&gt; Duration\n</code></pre> <p>Create a Duration from nanoseconds</p>"},{"location":"ref/types/#evalio.types.Duration.from_sec","title":"from_sec  <code>staticmethod</code>","text":"<pre><code>from_sec(sec: float) -&gt; Duration\n</code></pre> <p>Create a Duration from seconds</p>"},{"location":"ref/types/#evalio.types.Duration.to_nsec","title":"to_nsec","text":"<pre><code>to_nsec() -&gt; int\n</code></pre> <p>Convert to nanoseconds</p>"},{"location":"ref/types/#evalio.types.Duration.to_sec","title":"to_sec","text":"<pre><code>to_sec() -&gt; float\n</code></pre> <p>Convert to seconds</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement","title":"ImuMeasurement","text":"<p>ImuMeasurement is a simple structure for storing an IMU measurement.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.accel","title":"accel  <code>property</code>","text":"<pre><code>accel: NDArray[float64]\n</code></pre> <p>Accelerometer measurement as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.gyro","title":"gyro  <code>property</code>","text":"<pre><code>gyro: NDArray[float64]\n</code></pre> <p>Gyroscope measurement as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.stamp","title":"stamp  <code>property</code>","text":"<pre><code>stamp: Stamp\n</code></pre> <p>Timestamp of the IMU measurement.</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: ImuMeasurement) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.ImuMeasurement.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: ImuMeasurement) -&gt; bool\n</code></pre> <p>Check for inequality</p>"},{"location":"ref/types/#evalio.types.ImuParams","title":"ImuParams","text":"<p>ImuParams is a structure for storing the parameters of an IMU</p>"},{"location":"ref/types/#evalio.types.ImuParams.accel","title":"accel  <code>property</code>","text":"<pre><code>accel: float\n</code></pre> <p>Accelerometer standard deviation, in m/s^2/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.accel_bias","title":"accel_bias  <code>property</code>","text":"<pre><code>accel_bias: float\n</code></pre> <p>Accelerometer bias standard deviation, in m/s^3/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.bias_init","title":"bias_init  <code>property</code>","text":"<pre><code>bias_init: float\n</code></pre> <p>Initial bias standard deviation.</p>"},{"location":"ref/types/#evalio.types.ImuParams.brand","title":"brand  <code>property</code>","text":"<pre><code>brand: str\n</code></pre> <p>Brand of the IMU sensor.</p>"},{"location":"ref/types/#evalio.types.ImuParams.gravity","title":"gravity  <code>property</code>","text":"<pre><code>gravity: NDArray[float64]\n</code></pre> <p>Gravity vector as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.ImuParams.gyro","title":"gyro  <code>property</code>","text":"<pre><code>gyro: float\n</code></pre> <p>Gyroscope standard deviation, in rad/s/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.gyro_bias","title":"gyro_bias  <code>property</code>","text":"<pre><code>gyro_bias: float\n</code></pre> <p>Gyroscope bias standard deviation, in rad/s^2/sqrt(Hz).</p>"},{"location":"ref/types/#evalio.types.ImuParams.integration","title":"integration  <code>property</code>","text":"<pre><code>integration: float\n</code></pre> <p>Integration standard deviation.</p>"},{"location":"ref/types/#evalio.types.ImuParams.model","title":"model  <code>property</code>","text":"<pre><code>model: str\n</code></pre> <p>Model of the IMU sensor.</p>"},{"location":"ref/types/#evalio.types.ImuParams.down","title":"down  <code>staticmethod</code>","text":"<pre><code>down() -&gt; ImuParams\n</code></pre> <p>Simple helper for initializing with a <code>down</code> gravity vector.</p>"},{"location":"ref/types/#evalio.types.ImuParams.up","title":"up  <code>staticmethod</code>","text":"<pre><code>up() -&gt; ImuParams\n</code></pre> <p>Simple helper for initializing with an <code>up</code> gravity vector.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement","title":"LidarMeasurement","text":"<p>LidarMeasurement is a structure for storing a point cloud measurement, with a timestamp and a vector of points. Note, the stamp always represents the start of the scan. Additionally, the points are always in row major format.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.points","title":"points  <code>property</code> <code>writable</code>","text":"<pre><code>points: list[Point]\n</code></pre> <p>List of points in the point cloud. Note, this is always in row major format.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.stamp","title":"stamp  <code>property</code> <code>writable</code>","text":"<pre><code>stamp: Stamp\n</code></pre> <p>Timestamp of the point cloud, always at the start of the scan.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: LidarMeasurement) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: LidarMeasurement) -&gt; bool\n</code></pre> <p>Check for inequality</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.to_vec_positions","title":"to_vec_positions","text":"<pre><code>to_vec_positions() -&gt; list[NDArray[float64]]\n</code></pre> <p>Convert the point cloud to a (n,3) numpy array.</p>"},{"location":"ref/types/#evalio.types.LidarMeasurement.to_vec_stamps","title":"to_vec_stamps","text":"<pre><code>to_vec_stamps() -&gt; list[float]\n</code></pre> <p>Convert the point stamps to a list of durations.</p>"},{"location":"ref/types/#evalio.types.LidarParams","title":"LidarParams","text":"<p>LidarParams is a structure for storing the parameters of a lidar sensor.</p>"},{"location":"ref/types/#evalio.types.LidarParams.brand","title":"brand  <code>property</code>","text":"<pre><code>brand: str\n</code></pre> <p>Brand of the lidar sensor.</p>"},{"location":"ref/types/#evalio.types.LidarParams.max_range","title":"max_range  <code>property</code>","text":"<pre><code>max_range: float\n</code></pre> <p>Maximum range of the lidar sensor, in meters.</p>"},{"location":"ref/types/#evalio.types.LidarParams.min_range","title":"min_range  <code>property</code>","text":"<pre><code>min_range: float\n</code></pre> <p>Minimum range of the lidar sensor, in meters.</p>"},{"location":"ref/types/#evalio.types.LidarParams.model","title":"model  <code>property</code>","text":"<pre><code>model: str\n</code></pre> <p>Model of the lidar sensor.</p>"},{"location":"ref/types/#evalio.types.LidarParams.num_columns","title":"num_columns  <code>property</code>","text":"<pre><code>num_columns: int\n</code></pre> <p>Number of columns in the point cloud, also known as the number of points per scanline.</p>"},{"location":"ref/types/#evalio.types.LidarParams.num_rows","title":"num_rows  <code>property</code>","text":"<pre><code>num_rows: int\n</code></pre> <p>Number of rows in the point cloud, also known as the scanlines.</p>"},{"location":"ref/types/#evalio.types.LidarParams.rate","title":"rate  <code>property</code>","text":"<pre><code>rate: float\n</code></pre> <p>Rate of the lidar sensor, in Hz.</p>"},{"location":"ref/types/#evalio.types.LidarParams.delta_time","title":"delta_time","text":"<pre><code>delta_time() -&gt; Duration\n</code></pre> <p>Get the time between two consecutive scans as a Duration. Inverse of the rate.</p>"},{"location":"ref/types/#evalio.types.Point","title":"Point","text":"<p>Point is a general point structure in evalio, with common point cloud attributes included.</p>"},{"location":"ref/types/#evalio.types.Point.col","title":"col  <code>property</code> <code>writable</code>","text":"<pre><code>col: int\n</code></pre> <p>Column index of the point in the point cloud.</p>"},{"location":"ref/types/#evalio.types.Point.intensity","title":"intensity  <code>property</code> <code>writable</code>","text":"<pre><code>intensity: float\n</code></pre> <p>Intensity value as a float.</p>"},{"location":"ref/types/#evalio.types.Point.range","title":"range  <code>property</code> <code>writable</code>","text":"<pre><code>range: int\n</code></pre> <p>Range value as a uint32.</p>"},{"location":"ref/types/#evalio.types.Point.row","title":"row  <code>property</code> <code>writable</code>","text":"<pre><code>row: int\n</code></pre> <p>Row index of the point in the point cloud. Also known as the scanline index.</p>"},{"location":"ref/types/#evalio.types.Point.t","title":"t  <code>property</code> <code>writable</code>","text":"<pre><code>t: Duration\n</code></pre> <p>Timestamp of the point as a Duration. In evalio, this is always relative to the point cloud stamp, which occurs at the start of the scan.</p>"},{"location":"ref/types/#evalio.types.Point.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x: float\n</code></pre> <p>X coordinate</p>"},{"location":"ref/types/#evalio.types.Point.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y: float\n</code></pre> <p>Y coordinate</p>"},{"location":"ref/types/#evalio.types.Point.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z: float\n</code></pre> <p>Z coordinate</p>"},{"location":"ref/types/#evalio.types.Point.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: Point) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.Point.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    x: float = 0,\n    y: float = 0,\n    z: float = 0,\n    intensity: float = 0,\n    t: Duration = ...,\n    range: int = 0,\n    row: int = 0,\n    col: int = 0,\n) -&gt; None\n</code></pre> <p>Create a Point from x, y, z, intensity, t, range, row, col</p>"},{"location":"ref/types/#evalio.types.Point.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: Point) -&gt; bool\n</code></pre> <p>Check for inequality</p>"},{"location":"ref/types/#evalio.types.SE3","title":"SE3","text":"<p>SE3 class for representing a 3D rigid body transformation using a quaternion and a translation vector. This is outfitted with some basic functionality, but mostly intended for storage and converting between types.</p>"},{"location":"ref/types/#evalio.types.SE3.rot","title":"rot  <code>property</code>","text":"<pre><code>rot: SO3\n</code></pre> <p>Rotation as a SO3 object.</p>"},{"location":"ref/types/#evalio.types.SE3.trans","title":"trans  <code>property</code>","text":"<pre><code>trans: NDArray[float64]\n</code></pre> <p>Translation as a 3D vector.</p>"},{"location":"ref/types/#evalio.types.SE3.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: SE3) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.SE3.__init__","title":"__init__","text":"<pre><code>__init__(rot: SO3, trans: NDArray[float64]) -&gt; None\n</code></pre> <p>Create a SE3 from a rotation and translation.</p>"},{"location":"ref/types/#evalio.types.SE3.__mul__","title":"__mul__","text":"<pre><code>__mul__(arg: SE3) -&gt; SE3\n</code></pre> <p>Compose two rigid body transformations.</p>"},{"location":"ref/types/#evalio.types.SE3.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: SE3) -&gt; bool\n</code></pre> <p>Check for inequality</p>"},{"location":"ref/types/#evalio.types.SE3.fromMat","title":"fromMat  <code>staticmethod</code>","text":"<pre><code>fromMat(mat: NDArray[float64]) -&gt; SE3\n</code></pre> <p>Create a SE3 from a 4x4 transformation matrix.</p>"},{"location":"ref/types/#evalio.types.SE3.identity","title":"identity  <code>staticmethod</code>","text":"<pre><code>identity() -&gt; SE3\n</code></pre> <p>Create an identity SE3.</p>"},{"location":"ref/types/#evalio.types.SE3.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; SE3\n</code></pre> <p>Compute the inverse.</p>"},{"location":"ref/types/#evalio.types.SE3.toMat","title":"toMat","text":"<pre><code>toMat() -&gt; NDArray[float64]\n</code></pre> <p>Convert to a 4x4 matrix.</p>"},{"location":"ref/types/#evalio.types.SO3","title":"SO3","text":"<p>SO3 class for representing a 3D rotation using a quaternion. This is outfitted with some basic functionality, but mostly intended for storage and converting between types.</p>"},{"location":"ref/types/#evalio.types.SO3.qw","title":"qw  <code>property</code>","text":"<pre><code>qw: float\n</code></pre> <p>Scalar component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.qx","title":"qx  <code>property</code>","text":"<pre><code>qx: float\n</code></pre> <p>X component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.qy","title":"qy  <code>property</code>","text":"<pre><code>qy: float\n</code></pre> <p>Y component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.qz","title":"qz  <code>property</code>","text":"<pre><code>qz: float\n</code></pre> <p>Z component of the quaternion.</p>"},{"location":"ref/types/#evalio.types.SO3.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: SO3) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.SO3.__mul__","title":"__mul__","text":"<pre><code>__mul__(arg: SO3) -&gt; SO3\n</code></pre> <p>Compose two rotations.</p>"},{"location":"ref/types/#evalio.types.SO3.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: SO3) -&gt; bool\n</code></pre> <p>Check for inequality</p>"},{"location":"ref/types/#evalio.types.SO3.exp","title":"exp  <code>staticmethod</code>","text":"<pre><code>exp(v: NDArray[float64]) -&gt; SO3\n</code></pre> <p>Create a rotation from a 3D vector.</p>"},{"location":"ref/types/#evalio.types.SO3.fromMat","title":"fromMat  <code>staticmethod</code>","text":"<pre><code>fromMat(mat: NDArray[float64]) -&gt; SO3\n</code></pre> <p>Create a rotation from a 3x3 rotation matrix.</p>"},{"location":"ref/types/#evalio.types.SO3.identity","title":"identity  <code>staticmethod</code>","text":"<pre><code>identity() -&gt; SO3\n</code></pre> <p>Create an identity rotation.</p>"},{"location":"ref/types/#evalio.types.SO3.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; SO3\n</code></pre> <p>Compute the inverse of the rotation.</p>"},{"location":"ref/types/#evalio.types.SO3.log","title":"log","text":"<pre><code>log() -&gt; NDArray[float64]\n</code></pre> <p>Compute the logarithm of the rotation.</p>"},{"location":"ref/types/#evalio.types.SO3.rotate","title":"rotate","text":"<pre><code>rotate(v: NDArray[float64]) -&gt; NDArray[float64]\n</code></pre> <p>Rotate a 3D vector by the rotation.</p>"},{"location":"ref/types/#evalio.types.SO3.toMat","title":"toMat","text":"<pre><code>toMat() -&gt; NDArray[float64]\n</code></pre> <p>Convert the rotation to a 3x3 matrix.</p>"},{"location":"ref/types/#evalio.types.Stamp","title":"Stamp","text":"<p>Stamp class for representing an absolute point in time, uses uint32 as the underlying data storage for seconds and nanoseconds.</p>"},{"location":"ref/types/#evalio.types.Stamp.nsec","title":"nsec  <code>property</code>","text":"<pre><code>nsec: int\n</code></pre> <p>Underlying nanoseconds storage</p>"},{"location":"ref/types/#evalio.types.Stamp.sec","title":"sec  <code>property</code>","text":"<pre><code>sec: int\n</code></pre> <p>Underlying seconds storage</p>"},{"location":"ref/types/#evalio.types.Stamp.__add__","title":"__add__","text":"<pre><code>__add__(arg: Duration) -&gt; Stamp\n</code></pre> <p>Add a Duration to a Stamp</p>"},{"location":"ref/types/#evalio.types.Stamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg: Stamp) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.Stamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(arg: Stamp) -&gt; bool\n</code></pre> <p>Compare two Stamps to see which happened first</p>"},{"location":"ref/types/#evalio.types.Stamp.__init__","title":"__init__","text":"<pre><code>__init__(*, sec: int, nsec: int) -&gt; None\n</code></pre> <p>Create a Stamp from seconds and nanoseconds</p>"},{"location":"ref/types/#evalio.types.Stamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(arg: Stamp) -&gt; bool\n</code></pre> <p>Compare two Stamps to see which happened first</p>"},{"location":"ref/types/#evalio.types.Stamp.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg: Stamp) -&gt; bool\n</code></pre> <p>Check for equality</p>"},{"location":"ref/types/#evalio.types.Stamp.from_nsec","title":"from_nsec  <code>staticmethod</code>","text":"<pre><code>from_nsec(nsec: int) -&gt; Stamp\n</code></pre> <p>Create a Stamp from nanoseconds</p>"},{"location":"ref/types/#evalio.types.Stamp.from_sec","title":"from_sec  <code>staticmethod</code>","text":"<pre><code>from_sec(sec: float) -&gt; Stamp\n</code></pre> <p>Create a Stamp from seconds</p>"},{"location":"ref/types/#evalio.types.Stamp.to_nsec","title":"to_nsec","text":"<pre><code>to_nsec() -&gt; int\n</code></pre> <p>Convert to nanoseconds</p>"},{"location":"ref/types/#evalio.types.Stamp.to_sec","title":"to_sec","text":"<pre><code>to_sec() -&gt; float\n</code></pre> <p>Convert to seconds</p>"},{"location":"ref/types/#evalio.types.Trajectory","title":"Trajectory  <code>dataclass</code>","text":""},{"location":"ref/types/#evalio.types.Trajectory.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict = field(default_factory=dict)\n</code></pre> <p>Metadata associated with the trajectory, such as the dataset name or other information.</p>"},{"location":"ref/types/#evalio.types.Trajectory.poses","title":"poses  <code>instance-attribute</code>","text":"<pre><code>poses: list[SE3]\n</code></pre> <p>List of poses, in the same order as the timestamps.</p>"},{"location":"ref/types/#evalio.types.Trajectory.stamps","title":"stamps  <code>instance-attribute</code>","text":"<pre><code>stamps: list[Stamp]\n</code></pre> <p>List of timestamps for each pose.</p>"},{"location":"ref/types/#evalio.types.Trajectory.from_csv","title":"from_csv  <code>staticmethod</code>","text":"<pre><code>from_csv(\n    path: Path,\n    fieldnames: list[str],\n    delimiter=\",\",\n    skip_lines: Optional[int] = None,\n) -&gt; Trajectory\n</code></pre> <p>Flexible loader for stamped poses stored in csv files.</p> <p>Will automatically skip any lines that start with a #. Is most useful for loading ground truth data.</p> <pre><code>from evalio.types import Trajectory\n\nfieldnames = [\"sec\", \"nsec\", \"x\", \"y\", \"z\", \"qx\", \"qy\", \"qz\", \"qw\"]\ntrajectory = Trajectory.from_csv(path, fieldnames)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of file.</p> </li> <li> <code>fieldnames</code>               (<code>list[str]</code>)           \u2013            <p>List of field names to use, in their expected order. See above for an example.</p> </li> <li> <code>delimiter</code>               (<code>str</code>, default:                   <code>','</code> )           \u2013            <p>Delimiter between elements. Defaults to \",\".</p> </li> <li> <code>skip_lines</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of lines to skip, useful for skipping headers. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Stored dataset</p> </li> </ul>"},{"location":"ref/types/#evalio.types.Trajectory.from_experiment","title":"from_experiment  <code>staticmethod</code>","text":"<pre><code>from_experiment(path: Path) -&gt; Trajectory\n</code></pre> <p>Load a saved experiment trajectory from file.</p> <p>Works identically to from_tum, but also loads metadata from the file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of trajectory results.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Loaded trajectory with metadata, stamps, and poses.</p> </li> </ul>"},{"location":"ref/types/#evalio.types.Trajectory.from_tum","title":"from_tum  <code>staticmethod</code>","text":"<pre><code>from_tum(path: Path) -&gt; Trajectory\n</code></pre> <p>Load a TUM dataset pose file. Simple wrapper around from_csv.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>Location of file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Stored trajectory</p> </li> </ul>"}]}